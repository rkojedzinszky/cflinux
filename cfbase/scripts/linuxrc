#!/bin/sh

# This script is intended to run very first on the system
# to mount /etc, after it is done it invokes /sbin/init.
# With this, one can edit his own /etc/inittab file.
# And also to the system it is transparent that /etc is not
# on the root filesystem

# Make sure the shell does not exit on any error
set +e

# set the default path
export PATH=/bin:/sbin:/usr/bin:/usr/sbin

# try to guess the real system device
# if it is set through the kernel command line, accept that
if [ -z "$__system_device" ]; then
	# else try to guess it
	mount -n proc -t proc /proc
	if [ $? -ne 0 ]; then
		echo "Unable to mount proc, this is a big-big problem!"
		echo "Starting an emergency shell anyway..."
		exec /bin/sh
	fi
	if [ -f /proc/cmdline ]; then
		__system_device=$(sed -n \
			's/^.*root=\([\/a-zA-Z]\+\)[0-9].*$/\1/p' /proc/cmdline)
	else
		echo "/proc/cmdline does not exist. Why???"
		echo "Starting an emergency shell anyway..."
		exec /bin/sh
	fi
	umount -n /proc >/dev/null 2>&1
fi
if [ -z "$__system_device" ]; then
	# if it is still undefined, set it to the default /dev/hdc
	__system_device="/dev/hdc"
fi

. /usr/lib/cfmaint/common.sh
echo -n "Reading configuration: "
device=`get_fresh_and_valid`
if [ -z "$device" ]; then
	echo "no valid configuration found, using builtin defaults"
	device=/usr/share/defaults/etc.img
else
	echo -n "[found on $device] "
fi
dd if=$device of=/dev/ram0 bs=1k count=$conf_size 2>/dev/null
fsck.minix -a /dev/ram0 >/dev/null 2>&1
if [ $? -gt 2 ]
then
    echo -e "\n#"
    echo "# Check failed - should not happen, good luck!"
    echo "#"
    /bin/sh
    kill 1
    exit 0
fi

# place a \n at the end of the line
echo -ne "\n"

# Do the real mount
mount -t minix /dev/ram0 /etc 2>/dev/null

# Make /etc/mtab to be a symlink to /proc/mounts
ln -sf /proc/mounts /etc/mtab

# Invoke /sbin/init
export __system_device
exec /sbin/init

# vim: ts=2 sw=2
