diff -ruNP linux-2.4.24/Documentation/Configure.help linux-2.4.24-p/Documentation/Configure.help
--- linux-2.4.24/Documentation/Configure.help	Fri Nov 28 19:26:19 2003
+++ linux-2.4.24-p/Documentation/Configure.help	Tue Jan  6 19:59:48 2004
@@ -14142,14 +14142,27 @@
   This is the total bus width of the mapping of the flash chips
   on your particular board.
 
-JEDEC Flash device mapped on Mixcom piggyback card
+JEDEC Flash device mapped on MixMEM/FlashCOM cards
 CONFIG_MTD_MIXMEM
-  This supports the paging arrangement for access to flash chips
-  on the MixCOM piggyback card, allowing the flash chip drivers
-  to get on with their job of driving the flash chips without
-  having to know about the paging. If you have one of these boards,
-  you probably want to enable this mapping driver. More info is at
-  <http://www.itc.hu/>.
+  If you say Y here and create block special file(s) /dev/flash[x] with
+  major number 31 and minor number x (0 for first, but move on to 1, 2
+  etc. if you have more flash devices) using mknod ("man mknod"), you
+  will get support for the paging arrangement for access to flash chips
+  on the MixCOM piggyback card (MixMEM) and the FlashCOM board.
+
+  This allows the flash chip drivers to get on with their job of
+  driving the flash chips without having to know about the paging.
+  If you have one of these boards, you probably want to enable this
+  mapping driver. More info is at <http://www.itc.hu/>.
+
+  This driver needs jedec (JEDEC device support, jedec.o) (at
+  RAM/ROM/Flash chip drivers) and mtdblock (Caching block device
+  access to MTD devices, mtdblock.o) to work.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mixmem.o. If you want to compile it as
+  a module, say M here and read <file:Documentation/modules.txt>.
 
 JEDEC Flash device mapped on Octagon 5066 SBC
 CONFIG_MTD_OCTAGON
diff -ruNP linux-2.4.24/drivers/mtd/chips/jedec.c linux-2.4.24-p/drivers/mtd/chips/jedec.c
--- linux-2.4.24/drivers/mtd/chips/jedec.c	Fri Jun 13 16:51:34 2003
+++ linux-2.4.24-p/drivers/mtd/chips/jedec.c	Tue Jan  6 19:59:48 2004
@@ -15,6 +15,7 @@
  */
 
 #include <linux/mtd/jedec.h>
+#include <asm/delay.h>
 
 static struct mtd_info *jedec_probe(struct map_info *);
 static int jedec_probe8(struct map_info *map,unsigned long base,
@@ -33,13 +34,14 @@
 
 /* Listing of parts and sizes. We need this table to learn the sector
    size of the chip and the total length */
-static const struct JEDECTable JEDEC_table[] = 
-  {{0x013D,"AMD Am29F017D",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
-   {0x01AD,"AMD Am29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
-   {0x01D5,"AMD Am29F080",1*1024*1024,64*1024,MTD_CAP_NORFLASH},
-   {0x01A4,"AMD Am29F040",512*1024,64*1024,MTD_CAP_NORFLASH},
-   {0x20E3,"AMD Am29W040B",512*1024,64*1024,MTD_CAP_NORFLASH},
-   {0xC2AD,"Macronix MX29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+static const struct JEDECTable JEDEC_table[] = {
+   {0x013D, "AMD Am29F017D",	2*1024*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0x0141, "AMD Am29F032",     4*1024*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0x01AD, "AMD Am29F016",	2*1024*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0x01D5, "AMD Am29F080",	1*1024*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0x01A4, "AMD Am29F040",	512*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0x20E3, "AMD Am29W040B",	512*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0xC2AD, "Macronix MX29F016",2*1024*1024,	64*1024, MTD_CAP_NORFLASH},
    {}};
 
 static const struct JEDECTable *jedec_idtoinf(__u8 mfr,__u8 id);
@@ -79,6 +81,14 @@
    memset(MTD, 0, sizeof(struct mtd_info) + sizeof(struct jedec_private));
    priv = (struct jedec_private *)&MTD[1];
    
+   my_bank_size = 0;
+
+/*
+With this initialization, the loop would only run once, regardless of
+the number of chips on the card, thus failing to detect anything else
+than the first chip
+*/
+/*
    my_bank_size = map->size;
 
    if (map->size/my_bank_size > MAX_JEDEC_CHIPS)
@@ -87,6 +97,7 @@
       kfree(MTD);
       return 0;
    }
+*/
    
    for (Base = 0; Base < map->size; Base += my_bank_size)
    {
@@ -96,9 +107,8 @@
       
       if (map->buswidth == 1){
 	 if (jedec_probe8(map,Base,priv) == 0) {
-		 printk("did recognize jedec chip\n");
 		 kfree(MTD);
-	         return 0;
+	         break;
 	 }
       }
       if (map->buswidth == 2)
@@ -107,9 +117,16 @@
 	 jedec_probe32(map,Base,priv);
    }
    
+/* If there are really no chips, quit */
+   if(!priv->chips[0].jedec)
+   {
+       printk("Jedec: did not recognize jedec chip\n");
+       return 0;
+   }
+
    // Get the biggest sector size
    SectorSize = 0;
-   for (I = 0; priv->chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
+   for (I = 0; priv->chips[I].jedec && I < MAX_JEDEC_CHIPS; I++)
    {
 	   //	   printk("priv->chips[%d].jedec is %x\n",I,priv->chips[I].jedec);
 	   //	   printk("priv->chips[%d].sectorsize is %lx\n",I,priv->chips[I].sectorsize);
@@ -128,6 +145,8 @@
       }      
    }
    
+   printk(KERN_NOTICE "Jedec: detected %d chips total\n", I);
+
    /* Generate a part name that includes the number of different chips and
       other configuration information */
    count = 1;
@@ -193,7 +212,7 @@
 		      
 		      /* This even could be eliminated, but new de-optimized read/write
 			 functions have to be written */
-		      printk("priv->bank_fill[%d] is %lx, priv->bank_fill[0] is %lx\n",I,priv->bank_fill[I],priv->bank_fill[0]);
+//		      printk("priv->bank_fill[%d] is %lx, priv->bank_fill[0] is %lx\n",I,priv->bank_fill[I],priv->bank_fill[0]);
 		      if (priv->bank_fill[I] != priv->bank_fill[0])
 		      {
 			 printk("mtd: Failed. Cannot handle unsymmetric banking\n");
@@ -218,7 +237,7 @@
    //   printk("MTD->erasesize is %x\n",(unsigned int)MTD->erasesize);
    MTD->size = priv->size;
    //   printk("MTD->size is %x\n",(unsigned int)MTD->size);
-   //MTD->module = THIS_MODULE; // ? Maybe this should be the low level module?
+   MTD->module = THIS_MODULE; // ? Maybe this should be the low level module?
    MTD->erase = flash_erase;
    if (priv->is_banked == 1)
       MTD->read = jedec_read_banked;
@@ -312,12 +331,14 @@
 	 
       JEDEC = jedec_idtoinf(Mfg[J],Id[J]);
       priv->chips[I].jedec = (Mfg[J] << 8) | Id[J];
-      priv->chips[I].size = JEDEC->size;
+      my_bank_size = priv->chips[I].size = JEDEC->size;
       priv->chips[I].sectorsize = JEDEC->sectorsize;
       priv->chips[I].base = base + J;
       priv->chips[I].datashift = J*8;
       priv->chips[I].capabilities = JEDEC->capabilities;
       priv->chips[I].offset = priv->size + J;
+      printk(KERN_NOTICE "Jedec: found %s chip, size=0x%lX, sectorsize=0x%lX\n",
+      JEDEC->name, JEDEC->size, JEDEC->sectorsize);
 
       // log2 n :|
       priv->chips[I].addrshift = 0;
@@ -351,8 +372,8 @@
 static int jedec_probe8(struct map_info *map,unsigned long base,
 		  struct jedec_private *priv)
 { 
-   #define flread(x) map->read8(map,base+x)
-   #define flwrite(v,x) map->write8(map,v,base+x)
+#define flread(x) map->read8(map,base+x)
+#define flwrite(v,x) map->write8(map,v,base+x)
 
    const unsigned long AutoSel1 = 0xAA;
    const unsigned long AutoSel2 = 0x55;
@@ -396,8 +417,8 @@
    
    return 1;
    
-   #undef flread
-   #undef flwrite
+#undef flread
+#undef flwrite
 }
 
 // Look for flash using a 16 bit bus interface (ie 2 8-bit chips)
@@ -480,8 +501,8 @@
    
    return 1;
    
-   #undef flread
-   #undef flwrite
+#undef flread
+#undef flwrite
 }
 
 /* Linear read. */
@@ -545,8 +566,8 @@
 static int flash_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
    // Does IO to the currently selected chip
-   #define flread(x) map->read8(map,chip->base+((x)<<chip->addrshift))
-   #define flwrite(v,x) map->write8(map,v,chip->base+((x)<<chip->addrshift))
+#define flread(x) map->read8(map,chip->base+((x)<<chip->addrshift))
+#define flwrite(v,x) map->write8(map,v,chip->base+((x)<<chip->addrshift))
    
    unsigned long Time = 0;
    unsigned long NoTime = 0;
@@ -693,8 +714,8 @@
 	       todo_left--;
 	    }
 	    
-/*	    if (NoTime == 0)
-	       Time += HZ/10 - schedule_timeout(HZ/10);*/
+	    if (NoTime == 0)
+	       Time += HZ/10  - schedule_timeout(HZ/10);
 	    NoTime = 0;
 
 	    switch (map->buswidth) {
@@ -710,12 +731,12 @@
 	    }
 	    Count++;
 	    
-/*	    // Count time, max of 15s per sector (according to AMD)
+	    // Count time, max of 15s per sector (according to AMD)
 	    if (Time > 15*len/mtd->erasesize*HZ)
 	    {
 	       printk("mtd: Flash Erase Timed out\n");
 	       return -EIO;
-	    }	    */
+	    }
 	 }
 	 	 
 	 // Skip to the next chip if we used chip erase
@@ -743,8 +764,8 @@
 	instr->callback(instr);
    return 0;
    
-   #undef flread
-   #undef flwrite
+#undef flread
+#undef flwrite
 }
 
 /* This is the simple flash writing function. It writes to every byte, in
@@ -757,8 +778,8 @@
    /* Does IO to the currently selected chip. It takes the bank addressing
       base (which is divisable by the chip size) adds the necesary lower bits
       of addrshift (interleve index) and then adds the control register index. */
-   #define flread(x) map->read8(map,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
-   #define flwrite(v,x) map->write8(map,v,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
+#define flread(x) map->read8(map,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
+#define flwrite(v,x) map->write8(map,v,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
    
    struct map_info *map = (struct map_info *)mtd->priv;
    struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
@@ -806,9 +827,9 @@
 	    printk("mtd: warn: Trying to set a 0 to a 1\n");
 	     
 	 // Write
-	 flwrite(0xAA,0x555);
-	 flwrite(0x55,0x2AA);
-	 flwrite(0xA0,0x555);
+	 flwrite(0xAA, chip->base + 0x555);
+	 flwrite(0x55, chip->base + 0x2AA);
+	 flwrite(0xA0, chip->base + 0x555);
 	 map->write8(map,*buf,base + off);
 	 Last[0] = map->read8(map,base + off);
 	 Last[1] = map->read8(map,base + off);
@@ -819,8 +840,13 @@
 	    it failed. The toggle bits keep toggling when there is a 
 	    failure */
 	 for (Count = 3; Last[(Count - 1) % 4] != Last[(Count - 2) % 4] &&
-	      Count < 10000; Count++)
+        	Count < 50; Count++)
+	{
+       		udelay(3);
 	    Last[Count % 4] = map->read8(map,base + off);
+	}
+
+
 	 if (Last[(Count - 1) % 4] != *buf)
 	 {
 	    jedec_flash_failed(Last[(Count - 3) % 4]);
diff -ruNP linux-2.4.24/drivers/mtd/maps/Makefile linux-2.4.24-p/drivers/mtd/maps/Makefile
--- linux-2.4.24/drivers/mtd/maps/Makefile	Fri Jun 13 16:51:34 2003
+++ linux-2.4.24-p/drivers/mtd/maps/Makefile	Tue Jan  6 19:59:48 2004
@@ -34,6 +34,7 @@
     obj-$(CONFIG_MTD_PHYSMAP)	+= physmap.o 
   endif
 endif
+obj-$(CONFIG_MTD_MIXMEM)	+= mixmem.o
 obj-$(CONFIG_MTD_PNC2000)	+= pnc2000.o
 obj-$(CONFIG_MTD_PCMCIA)	+= pcmciamtd.o
 obj-$(CONFIG_MTD_RPXLITE)	+= rpxlite.o
diff -ruNP linux-2.4.24/drivers/mtd/maps/mixmem.c linux-2.4.24-p/drivers/mtd/maps/mixmem.c
--- linux-2.4.24/drivers/mtd/maps/mixmem.c	Thu Jan  1 01:00:00 1970
+++ linux-2.4.24-p/drivers/mtd/maps/mixmem.c	Tue Jan  6 19:59:48 2004
@@ -0,0 +1,430 @@
+/*
+* mixmem - device driver for flash rom found on the flashcom and
+*          piggyback board of the multi-purpose mixcom card
+*
+* Copyright: Szilard Pasztor <don@itc.hu> and
+*            ITConsult-Pro Co. <info@itc.hu>
+*
+* If compiled as a module, it can take a parameter that may contain
+* * "ro" (disable write to the flash)
+* * "force" (force module loading even if the memory address appears
+*            already mapped, this may occur if the flash contains an
+*            extension ROM image recognized by the kernel early on)
+* * or both ("roforce" for example).
+*
+* parts of code borrowed from nbd.c and xd.c
+* partly based on code by Gergely Madarasz <gorgo@itc.hu>
+*
+* This code is GPL
+*/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/ioport.h>
+#include <linux/malloc.h>
+#include <asm/delay.h>
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/init.h> 
+#include <linux/spinlock.h>
+#include <asm/io.h>
+
+#include <linux/mtd/map.h>
+
+/* This call is only needed to autoload the mtdblock module.            *
+ * WARNING: If the mtdblock_thread function becomes declared as static, *
+ * the module has to be loaded manually.                                */
+extern int mtdblock_thread(void);
+
+static unsigned int mixmem_addrs[] = { 0xc0000, 0xc4000, 0xc8000, 0xcc000,
+				       0xd0000, 0xd4000, 0xd8000, 0xdc000, 0 };
+
+static unsigned int mixcom_ports[] = { 0x180, 0x280, 0x380, 0 };
+static unsigned int flashcom_ports[] = { 0x300, 0x308, 0x310, 0x318, 0x320,
+					 0x328, 0x330, 0x338, 0x340, 0x348, 0x350,
+					 0x358, 0x360, 0x368, 0x370, 0x378, 0 };
+
+//#define MIXMEM_DEBUG
+
+static unsigned long iomapaddr, phys_address, pagesize;
+
+static void *virt_address;
+
+static int port, readonly, force;
+
+static char* mode = "rw";
+
+#define MIXCOM_ID_OFFSET 0xc10
+#define MIXCOM_PAGE_OFFSET 0xc11
+#define MIXCOM_ID 0x11
+
+#define FLASHCOM_ID 0x18
+
+#define FIRST_BLOCK_OFFSET 4096
+
+#define MIN(a, b) ((a < b) ? a : b)
+#define MAX(a, b) ((a > b) ? a : b)
+
+static spinlock_t mixmem_spin = SPIN_LOCK_UNLOCKED;
+
+MODULE_PARM(mode, "s");
+
+/* The paging function. 12 bits of the page register are relevant.
+   We store the page register in a private tag since paging costs time */
+static inline void mixmem_page(struct map_info *map, unsigned long linear_addr)
+{
+    int pagecount;
+
+    pagecount = linear_addr / pagesize;
+
+    if (map->map_priv_1 != pagecount)
+    {
+	outb(pagecount & 255, port + 1);
+	outb((pagecount >> 8) & 15, port + 2);
+	map->map_priv_1 = pagecount;
+    }
+}
+
+/* Read one byte from a linear address */
+static __u8 mixmem_read8(struct map_info *map, unsigned long flashaddr)
+{
+    __u8 ret;
+
+    spin_lock(&mixmem_spin);
+    mixmem_page(map, flashaddr);
+    ret = readb(virt_address + flashaddr % pagesize);
+    spin_unlock(&mixmem_spin);
+    return ret;
+}
+
+/* Just to have mtdblock loaded */
+static void nevercalled(void)
+{
+    mtdblock_thread();
+}
+
+/* Read a block beginning at the linear address */
+static void mixmem_copyfrom(struct map_info *map, void *mem_to,
+		unsigned long flash_from, ssize_t len)
+{
+    unsigned long thislen;
+    unsigned long mask = pagesize - 1;
+
+    while (len)
+    {
+	thislen = len;
+
+	if (len > (pagesize - (flash_from & mask)))
+	    thislen = pagesize - (flash_from & mask);
+	spin_lock(&mixmem_spin);
+	mixmem_page(map, flash_from);
+	memcpy_fromio(mem_to, iomapaddr + (flash_from & mask), thislen);
+	spin_unlock(&mixmem_spin);
+	mem_to += thislen;
+	flash_from += thislen;
+	len -= thislen;
+    }
+}
+
+/* Write one byte to a linear address */
+static void mixmem_write8(struct map_info *map, __u8 what, unsigned long flashaddr)
+{
+    if (readonly) return;
+
+    spin_lock(&mixmem_spin);
+    mixmem_page(map, flashaddr);
+    writeb(what, virt_address + flashaddr % pagesize);
+    spin_unlock(&mixmem_spin);
+}
+
+/* JEDEC does NOT use this function (yet?), it writes bytewise instead */
+/* Read a block beginning at the linear address */
+static void mixmem_copyto(struct map_info *map, unsigned long flash_to,
+			const void *mem_from, ssize_t len)
+{
+    unsigned long thislen;
+    unsigned long mask = pagesize - 1;
+
+    if (readonly) return;
+
+    while (len)
+    {
+	thislen = len;
+
+	if (len > (pagesize - (flash_to & mask)))
+	    thislen = pagesize - (flash_to & mask);
+	spin_lock(&mixmem_spin);
+	mixmem_page(map, flash_to);
+	memcpy_toio(iomapaddr + (flash_to & mask), mem_from, thislen);
+	spin_unlock(&mixmem_spin);
+	mem_from += thislen;
+	flash_to += thislen;
+	len -= thislen;
+    }
+}
+
+/* Our reference structure for the device */
+static struct map_info mixmem_map =
+{
+    name: "FlashCOM/MixCOM Onboard Flash",
+    buswidth: 1,
+    read8: mixmem_read8,
+    copy_from: mixmem_copyfrom,
+    write8: mixmem_write8,
+    copy_to: mixmem_copyto,
+    map_priv_1: 0	// always the current content of the page register
+};
+
+/* Expandable array if necessary (more cards) */
+static struct
+{
+    char *name;
+    unsigned int maxchips;
+    unsigned int pagereg_offset;
+} *cardtype, flash_card[] =
+{
+    { "FlashCOM", 8, 0 },
+    { "MixMEM", 4, 1 }
+};
+
+/* Is JEDEC supposed to do this task? So far, it seems to fail.
+   Or I fail in understanding the code. So this function stays in */
+int flash_probe(const void *base)
+{
+    int prev, curr;
+    unsigned long flags;
+
+    writeb(0xf0, base);
+    save_flags(flags);
+    cli();
+
+    prev = readw(base);
+
+    writeb(0xaa, base + 0x555);
+    writeb(0x55, base + 0x2AA);
+    writeb(0x90, base + 0x555);
+
+    curr = readw(base);
+
+    restore_flags(flags);
+#ifdef MIXMEM_DEBUG
+    printk("prev: 0x%04x, returned value: 0x%04x\n", prev, curr);
+#endif
+    writeb(0xf0, base);
+    return curr == 0xd501 ? curr : 0;
+    return prev == curr ? 0 : curr;
+}
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_mixmem init_module
+#define cleanup_mixmem cleanup_module
+#endif
+
+static struct mtd_info *mixmem_mtd = NULL;
+
+static int recursive_shutdown(unsigned char flagsbyte)
+{
+    int errcode = 0;
+
+    if (flagsbyte & 8)
+    {
+	printk(KERN_ERR "Mixmem: Terrible! Unable to allocate IO space for %s, try again\n", cardtype->name);
+	errcode = -EAGAIN;
+    }
+    if (flagsbyte & 4)
+    {
+	iounmap((void *) iomapaddr);
+	if (!errcode) errcode = -ENODEV;
+    }
+    if ((flagsbyte & 2) && !force)
+    {
+	release_mem_region(phys_address, pagesize * 2);
+	if (!errcode) errcode = -EIO;
+    }
+    if (flagsbyte & 1)
+    {
+	release_region(port + cardtype->pagereg_offset,
+		cardtype == &flash_card[0] ? 5 : 2);
+	if (!errcode) errcode = -ENXIO;
+    }
+    return errcode;
+}
+
+static void __exit cleanup_mixmem(void)
+{
+    if (mixmem_mtd)
+    {
+	del_mtd_device(mixmem_mtd);
+
+/* This call causes the kernel to collapse since do_map_probe
+   for jedec doesn't initialize the map->fldrv->destroy
+   pointer. So, for now, we just skip calling this function
+
+	map_destroy(mixmem_mtd);
+*/
+
+// Decrease JEDEC module's use count
+	__MOD_DEC_USE_COUNT(mixmem_mtd->module);
+    }
+    recursive_shutdown(7);
+}
+
+int __init init_mixmem(void)
+{
+    int i, id, mem_ro = 0;
+
+    for (port = i = 0; flashcom_ports[i]; i++)
+    {
+	id = inb(flashcom_ports[i]) & 0x7f;
+	if (id == FLASHCOM_ID)
+	{
+#ifdef MIXMEM_DEBUG
+	    printk("Mixmem: FlashCOM candidate at 0x%3X\n", flashcom_ports[i]);
+#endif
+	    if ((inb(flashcom_ports[i] + 3) & 0x7f) == id
+		    && (inb(flashcom_ports[i] + 3) & 0x7f) == id)
+	    {
+		cardtype = &flash_card[0];
+
+		if (!request_region
+			(flashcom_ports[i], 5, flash_card[0].name))
+		    return recursive_shutdown(8);
+
+		port = flashcom_ports[i];
+		break;
+	    }
+	}
+    }
+
+    if (!port)	// No flashcom. Is there a mixcom?
+    {
+	for (i = 0; mixcom_ports[i]; i++)
+	{
+	    id = inb(mixcom_ports[i] + MIXCOM_ID_OFFSET);
+	    if (id == MIXCOM_ID)
+	    {
+		cardtype = &flash_card[1];
+
+		if (!request_region
+			(mixcom_ports[i] +
+			 MIXCOM_PAGE_OFFSET, 2, flash_card[1].name))
+		    return recursive_shutdown(8);
+		port = mixcom_ports[i];
+		break;
+	    }
+	}
+    }
+
+    if (port)
+    {
+	printk("Mixmem: %s board (%s) found at IO=0x%3X", cardtype->name,
+	    strstr(mode, "ro") ? "read-only" : "read-write", port);
+    }
+    else
+    {
+	printk("Mixmem: no flash card found\n");
+	return -ENODEV;
+    }
+
+#ifdef MIXMEM_DEBUG
+    printk("\nMixmem: probing for flash\n");
+#endif
+    if (cardtype == &flash_card[0])	// Flashcom
+    {
+	printk("\n");
+	if (!(inb(port + 2) & 0x08))
+	{
+	    printk(KERN_ERR "Mixmem: flash memory enable jumper not present! Aborting...\n");
+	    return recursive_shutdown(1);
+	}
+	if ((inb(port + 2) & 0x80) && !mem_ro)
+	{
+	    printk(KERN_NOTICE "Mixmem: memory write disabled by jumper, treating as ROM\n");
+	    mem_ro = 1;
+	}
+
+	pagesize = 2 * FIRST_BLOCK_OFFSET;
+	phys_address = 0xC0000 + ((inb(port + 2) & 0x7) << 14);
+	mixmem_map.size = inb(port + 1) * 1024 * 1024;
+	virt_address = phys_to_virt(phys_address);
+    }
+    else				// Mixcom
+    {
+	for (i = 0; mixmem_addrs[i]; i++)
+	{
+	    id = flash_probe(phys_to_virt(mixmem_addrs[i] + 2 * FIRST_BLOCK_OFFSET));
+	    if (id)
+	    {
+		pagesize = 2 * FIRST_BLOCK_OFFSET;
+		break;
+	    }
+	    id = flash_probe(phys_to_virt(mixmem_addrs[i] + FIRST_BLOCK_OFFSET));
+	    if (id)
+	    {
+		pagesize = FIRST_BLOCK_OFFSET;
+		break;
+	    }
+	}
+	printk(" (at 0x%X, pagesize=%luK)\n", port +=
+		MIXCOM_ID_OFFSET, pagesize >> 10);
+
+	if (mixmem_addrs[i])
+	{
+	    phys_address = mixmem_addrs[i];
+	    virt_address = phys_to_virt(phys_address);
+	}
+	else
+	{
+	    printk(KERN_ERR "Mixmem: no flash chip found\n");
+	    return recursive_shutdown(1);
+	}
+
+	mixmem_map.size = 16 * 1024 * 1024;	// max flash size
+    }
+
+    force = strstr(mode, "force") ? 1 : 0;
+    mem_ro = (strstr(mode, "ro") || mem_ro) ? 1 : 0;
+
+    if (!request_mem_region(phys_address, pagesize * 2, cardtype->name) && !force)
+    {
+	printk(KERN_ERR "Mixmem: memory address conflict at %08lX\n", phys_address);
+	return recursive_shutdown(1);
+    }
+
+    iomapaddr = (unsigned long) ioremap_nocache(phys_address, pagesize * 2);
+    if (!iomapaddr)
+    {
+	printk(KERN_ERR "Mixmem: failed to ioremap memory region\n");
+	return recursive_shutdown(3);
+    }
+
+    outb(0, port + 1);	// We must initialize the page register
+    outb(0, port + 2);
+
+    if (!(mixmem_mtd = do_map_probe("jedec", &mixmem_map)))
+    {
+	printk(KERN_ERR "Mixmem: no flash chip found\n");
+	return recursive_shutdown(7);
+    }
+
+    printk("Mixmem: %s memory address=0x%lX, flash size=%uK\n",
+	cardtype->name, phys_address, mixmem_mtd->size >> 10);
+
+    if (add_mtd_device(mixmem_mtd))
+    {
+	map_destroy(mixmem_mtd);
+	recursive_shutdown(7);
+	return -ENOLCK;
+    }
+    readonly = mem_ro;
+    return 0;
+}
+
+module_init(init_mixmem);
+module_exit(cleanup_mixmem);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Pásztor Szilárd <don@itc.hu>");
+MODULE_DESCRIPTION("MTD map driver for FlashCOM and MixMEM boards");
diff -ruNP linux-2.4.24/drivers/net/3c59x.c linux-2.4.24-p/drivers/net/3c59x.c
--- linux-2.4.24/drivers/net/3c59x.c	Fri Nov 28 19:26:20 2003
+++ linux-2.4.24-p/drivers/net/3c59x.c	Tue Jan  6 19:59:48 2004
@@ -313,6 +313,9 @@
    code size of a per-interface flag is not worthwhile. */
 static char mii_preamble_required;
 
+/* The Ethernet Type used for 802.1q tagged frames */
+#define VLAN_ETHER_TYPE 0x8100
+
 #define PFX DRV_NAME ": "
 
 
@@ -681,7 +684,7 @@
 	Wn2_ResetOptions=12,
 };
 enum Window3 {			/* Window 3: MAC/config bits. */
-	Wn3_Config=0, Wn3_MAC_Ctrl=6, Wn3_Options=8,
+	Wn3_Config=0, Wn3_MaxPktSize=4, Wn3_MAC_Ctrl=6, Wn3_Options=8,
 };
 
 #define BFEXT(value, offset, bitcount)  \
@@ -709,7 +712,8 @@
 	Media_LnkBeat = 0x0800,
 };
 enum Window7 {					/* Window 7: Bus Master control. */
-	Wn7_MasterAddr = 0, Wn7_MasterLen = 6, Wn7_MasterStatus = 12,
+	Wn7_MasterAddr = 0, Wn7_VlanEtherType=4, Wn7_MasterLen = 6,
+	Wn7_MasterStatus = 12,
 };
 /* Boomerang bus master control registers. */
 enum MasterCtrl {
@@ -806,7 +810,8 @@
 		pm_state_valid:1,				/* power_state[] has sane contents */
 		open:1,
 		medialock:1,
-		must_free_region:1;				/* Flag: if zero, Cardbus owns the I/O region */
+		must_free_region:1,				/* Flag: if zero, Cardbus owns the I/O region */
+		large_frames:1;			/* accept large frames */
 	int drv_flags;
 	u16 status_enable;
 	u16 intr_enable;
@@ -875,6 +880,9 @@
 static void vortex_tx_timeout(struct net_device *dev);
 static void acpi_set_WOL(struct net_device *dev);
 static struct ethtool_ops vortex_ethtool_ops;
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+static void set_8021q_mode(struct net_device *dev, int enable);
+#endif
 
 /* This driver uses 'options' to pass the media type, full-duplex flag, etc. */
 /* Option count limit only -- unlimited interfaces are supported. */
@@ -1058,6 +1066,7 @@
 	dev->base_addr = ioaddr;
 	dev->irq = irq;
 	dev->mtu = mtu;
+	vp->large_frames = mtu > 1500;
 	vp->drv_flags = vci->drv_flags;
 	vp->has_nway = (vci->drv_flags & HAS_NWAY) ? 1 : 0;
 	vp->io_size = vci->io_size;
@@ -1482,7 +1491,7 @@
 
 	/* Set the full-duplex bit. */
 	outw(	((vp->info1 & 0x8000) || vp->full_duplex ? 0x20 : 0) |
-		 	(dev->mtu > 1500 ? 0x40 : 0) |
+		 	(vp->large_frames ? 0x40 : 0) |
 			((vp->full_duplex && vp->flow_ctrl && vp->partner_flow_ctrl) ? 0x100 : 0),
 			ioaddr + Wn3_MAC_Ctrl);
 
@@ -1566,6 +1575,10 @@
 	}
 	/* Set receiver mode: presumably accept b-case and phys addr only. */
 	set_rx_mode(dev);
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	/* enable 802.1q tagged frames */
+	set_8021q_mode(dev, 1);
+#endif
 	outw(StatsEnable, ioaddr + EL3_CMD); /* Turn on statistics. */
 
 //	issue_and_wait(dev, SetTxStart|0x07ff);
@@ -1706,7 +1719,7 @@
 						/* Set the full-duplex bit. */
 						EL3WINDOW(3);
 						outw(	(vp->full_duplex ? 0x20 : 0) |
-								(dev->mtu > 1500 ? 0x40 : 0) |
+								(vp->large_frames ? 0x40 : 0) |
 								((vp->full_duplex && vp->flow_ctrl && vp->partner_flow_ctrl) ? 0x100 : 0),
 								ioaddr + Wn3_MAC_Ctrl);
 						if (vortex_debug > 1)
@@ -1929,6 +1942,10 @@
 			issue_and_wait(dev, RxReset|0x07);
 			/* Set the Rx filter to the current state. */
 			set_rx_mode(dev);
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+			/* enable 802.1q VLAN tagged frames */
+			set_8021q_mode(dev, 1);
+#endif
 			outw(RxEnable, ioaddr + EL3_CMD); /* Re-enable the receiver. */
 			outw(AckIntr | HostError, ioaddr + EL3_CMD);
 		}
@@ -2526,6 +2543,11 @@
 	outw(RxDisable, ioaddr + EL3_CMD);
 	outw(TxDisable, ioaddr + EL3_CMD);
 
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	/* Disable receiving 802.1q tagged frames */
+	set_8021q_mode(dev, 0);
+#endif
+
 	if (dev->if_port == XCVR_10base2)
 		/* Turn off thinnet power.  Green! */
 		outw(StopCoax, ioaddr + EL3_CMD);
@@ -2775,6 +2797,50 @@
 
 	outw(new_mode, ioaddr + EL3_CMD);
 }
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+/* Setup the card so that it can receive frames with an 802.1q VLAN tag.
+   Note that this must be done after each RxReset due to some backwards
+   compatibility logic in the Cyclone and Tornado ASICs */
+static void set_8021q_mode(struct net_device *dev, int enable)
+{
+	struct vortex_private *vp = (struct vortex_private *)dev->priv;
+	long ioaddr = dev->base_addr;
+	int old_window = inw(ioaddr + EL3_CMD);
+	int mac_ctrl;
+	
+	if (vp->drv_flags&IS_CYCLONE || vp->drv_flags&IS_TORNADO) {
+		/* cyclone and tornado chipsets can recognize 802.1q
+		 * tagged frames and treat them correctly */
+
+		int max_pkt_size = dev->mtu+14;	/* MTU+Ethernet header */
+		if (enable)
+			max_pkt_size += 4;	/* 802.1Q VLAN tag */
+
+		EL3WINDOW(3);
+		outw(max_pkt_size, ioaddr+Wn3_MaxPktSize);
+
+		/* set VlanEtherType to let the hardware checksumming
+		   treat tagged frames correctly */
+		EL3WINDOW(7);
+		outw(VLAN_ETHER_TYPE, ioaddr+Wn7_VlanEtherType);
+	} else {
+		/* on older cards we have to enable large frames */
+
+		vp->large_frames = dev->mtu > 1500 || enable;
+
+		EL3WINDOW(3);
+		mac_ctrl = inw(ioaddr+Wn3_MAC_Ctrl);
+		if (vp->large_frames)
+			mac_ctrl |= 0x40;
+		else
+			mac_ctrl &= ~0x40;
+		outw(mac_ctrl, ioaddr+Wn3_MAC_Ctrl);
+	}
+
+	EL3WINDOW(old_window);
+}
+#endif
 
 /* MII transceiver control section.
    Read and write the MII registers using software-generated serial
diff -ruNP linux-2.4.24/drivers/net/eepro100.c linux-2.4.24-p/drivers/net/eepro100.c
--- linux-2.4.24/drivers/net/eepro100.c	Mon Aug 25 13:44:42 2003
+++ linux-2.4.24-p/drivers/net/eepro100.c	Tue Jan  6 19:59:48 2004
@@ -507,12 +507,12 @@
 static const char i82557_config_cmd[CONFIG_DATA_SIZE] = {
 	22, 0x08, 0, 0,  0, 0, 0x32, 0x03,  1, /* 1=Use MII  0=Use AUI */
 	0, 0x2E, 0,  0x60, 0,
-	0xf2, 0x48,   0, 0x40, 0xf2, 0x80, 		/* 0x40=Force full-duplex */
+	0xf2, 0x48,   0, 0x40, 0xfa, 0x80, 		/* 0x40=Force full-duplex */
 	0x3f, 0x05, };
 static const char i82558_config_cmd[CONFIG_DATA_SIZE] = {
 	22, 0x08, 0, 1,  0, 0, 0x22, 0x03,  1, /* 1=Use MII  0=Use AUI */
 	0, 0x2E, 0,  0x60, 0x08, 0x88,
-	0x68, 0, 0x40, 0xf2, 0x84,		/* Disable FC */
+	0x68, 0, 0x40, 0xfa, 0x84,		/* Disable FC */
 	0x31, 0x05, };
 
 /* PHY media interface chips. */
diff -ruNP linux-2.4.24/drivers/net/tulip/interrupt.c linux-2.4.24-p/drivers/net/tulip/interrupt.c
--- linux-2.4.24/drivers/net/tulip/interrupt.c	Fri Jun 13 16:51:35 2003
+++ linux-2.4.24-p/drivers/net/tulip/interrupt.c	Tue Jan  6 19:59:48 2004
@@ -128,8 +128,8 @@
 				   dev->name, entry, status);
 		if (--rx_work_limit < 0)
 			break;
-		if ((status & 0x38008300) != 0x0300) {
-			if ((status & 0x38000300) != 0x0300) {
+		if ((status & (0x38000000 | RxDescFatalErr | RxWholePkt)) != RxWholePkt) {
+                if ((status & (0x38000000 | RxWholePkt)) != RxWholePkt) {
 				/* Ingore earlier buffers. */
 				if ((status & 0xffff) != 0x7fff) {
 					if (tulip_debug > 1)
@@ -155,10 +155,10 @@
 			struct sk_buff *skb;
 
 #ifndef final_version
-			if (pkt_len > 1518) {
+			if (pkt_len > 1522) {
 				printk(KERN_WARNING "%s: Bogus packet size of %d (%#x).\n",
 					   dev->name, pkt_len, pkt_len);
-				pkt_len = 1518;
+				pkt_len = 1522;
 				tp->stats.rx_length_errors++;
 			}
 #endif
diff -ruNP linux-2.4.24/drivers/net/tulip/tulip.h linux-2.4.24-p/drivers/net/tulip/tulip.h
--- linux-2.4.24/drivers/net/tulip/tulip.h	Fri Nov 29 00:53:14 2002
+++ linux-2.4.24-p/drivers/net/tulip/tulip.h	Tue Jan  6 19:59:48 2004
@@ -188,7 +188,7 @@
 
 enum desc_status_bits {
 	DescOwned = 0x80000000,
-	RxDescFatalErr = 0x8000,
+	RxDescFatalErr = 0x4842,
 	RxWholePkt = 0x0300,
 };
 
@@ -266,7 +266,7 @@
 
 #define MEDIA_MASK     31
 
-#define PKT_BUF_SZ		1536	/* Size of each temporary Rx buffer. */
+#define PKT_BUF_SZ		1540	/* Size of each temporary Rx buffer. */
 
 #define TULIP_MIN_CACHE_LINE	8	/* in units of 32-bit words */
 
diff -ruNP linux-2.4.24/drivers/net/tulip/tulip_core.c linux-2.4.24-p/drivers/net/tulip/tulip_core.c
--- linux-2.4.24/drivers/net/tulip/tulip_core.c	Fri Nov 28 19:26:20 2003
+++ linux-2.4.24-p/drivers/net/tulip/tulip_core.c	Tue Jan  6 19:59:48 2004
@@ -64,7 +64,7 @@
 #if defined(__alpha__) || defined(__arm__) || defined(__hppa__) \
 	|| defined(__sparc_) || defined(__ia64__) \
 	|| defined(__sh__) || defined(__mips__) || defined(__SH5__)
-static int rx_copybreak = 1518;
+static int rx_copybreak = 1522;
 #else
 static int rx_copybreak = 100;
 #endif
diff -ruNP linux-2.4.24/drivers/net/wan/comx-hw-comx.c linux-2.4.24-p/drivers/net/wan/comx-hw-comx.c
--- linux-2.4.24/drivers/net/wan/comx-hw-comx.c	Fri Nov 29 00:53:14 2002
+++ linux-2.4.24-p/drivers/net/wan/comx-hw-comx.c	Tue Jan  6 19:59:48 2004
@@ -1,11 +1,12 @@
 /*
  * Hardware-level driver for the COMX and HICOMX cards
- * for Linux kernel 2.2.X
+ * for Linux kernel 2.4.X
  *
  * Original authors:  Arpad Bakay <bakay.arpad@synergon.hu>,
  *                    Peter Bajan <bajan.peter@synergon.hu>,
  * Rewritten by: Tivadar Szemethy <tiv@itc.hu>
- * Currently maintained by: Gergely Madarasz <gorgo@itc.hu>
+ * Previous maintainer: Gergely Madarasz <gorgo@itc.hu>
+ * Currently maintained by: Szilard Pasztor <don@itc.hu>
  *
  * Copyright (C) 1995-2000 ITConsult-Pro Co. <info@itc.hu>
  *
@@ -61,28 +62,31 @@
 #include "comx.h"
 #include "comxhw.h"
 
-MODULE_AUTHOR("Gergely Madarasz <gorgo@itc.hu>, Tivadar Szemethy <tiv@itc.hu>, Arpad Bakay");
+MODULE_AUTHOR
+    ("Gergely Madarasz <gorgo@itc.hu>, Tivadar Szemethy <tiv@itc.hu>, Arpad Bakay");
 MODULE_DESCRIPTION("Hardware-level driver for the COMX and HICOMX adapters\n");
 MODULE_LICENSE("GPL");
 
-#define	COMX_readw(dev, offset)	(readw(dev->mem_start + offset + \
+#define	COMX_readw(dev, offset)	(readw(phys_to_virt(dev->mem_start + offset + \
 	(unsigned int)(((struct comx_privdata *)\
 	((struct comx_channel *)dev->priv)->HW_privdata)->channel) \
-	* COMX_CHANNEL_OFFSET))
+	* COMX_CHANNEL_OFFSET)))
 
-#define COMX_WRITE(dev, offset, value)	(writew(value, dev->mem_start + offset \
+#define COMX_WRITE(dev, offset, value)	(writew(value, phys_to_virt(dev->mem_start + offset \
 	+ (unsigned int)(((struct comx_privdata *) \
 	((struct comx_channel *)dev->priv)->HW_privdata)->channel) \
-	* COMX_CHANNEL_OFFSET))
+	* COMX_CHANNEL_OFFSET)))
 
 #define COMX_CMD(dev, cmd)	(COMX_WRITE(dev, OFF_A_L2_CMD, cmd))
 
-struct comx_firmware {
+struct comx_firmware
+{
 	int	len;
 	unsigned char *data;
 };
 
-struct comx_privdata {
+struct comx_privdata
+{
 	struct comx_firmware *firmware;
 	u16	clock;
 	char	channel;		// channel no.
@@ -100,26 +104,30 @@
 
 static void COMX_board_on(struct net_device *dev)
 {
-	outb_p( (byte) (((dev->mem_start & 0xf0000) >> 16) | 
-	    COMX_ENABLE_BOARD_IT | COMX_ENABLE_BOARD_MEM), dev->base_addr);
+    outb_p((byte)
+	   (((dev->
+	      mem_start & 0xf0000) >> 16) | COMX_ENABLE_BOARD_IT |
+	    COMX_ENABLE_BOARD_MEM), dev->base_addr);
 }
 
 static void COMX_board_off(struct net_device *dev)
 {
-	outb_p( (byte) (((dev->mem_start & 0xf0000) >> 16) | 
-	   COMX_ENABLE_BOARD_IT), dev->base_addr);
+    outb_p((byte) (((dev->mem_start & 0xf0000) >> 16) | COMX_ENABLE_BOARD_IT),
+	   dev->base_addr);
 }
 
 static void HICOMX_board_on(struct net_device *dev)
 {
-	outb_p( (byte) (((dev->mem_start & 0xf0000) >> 12) | 
-	   HICOMX_ENABLE_BOARD_MEM), dev->base_addr);
+    outb_p((byte)
+	   (((dev->mem_start & 0xf0000) >> 12) | HICOMX_ENABLE_BOARD_MEM),
+	   dev->base_addr);
 }
 
 static void HICOMX_board_off(struct net_device *dev)
 {
-	outb_p( (byte) (((dev->mem_start & 0xf0000) >> 12) | 
-	   HICOMX_DISABLE_BOARD_MEM), dev->base_addr);
+    outb_p((byte)
+	   (((dev->mem_start & 0xf0000) >> 12) | HICOMX_DISABLE_BOARD_MEM),
+	   dev->base_addr);
 }
 
 static void COMX_set_clock(struct net_device *dev)
@@ -134,48 +142,56 @@
 {
 	struct comx_channel *ch = dev->priv;
 	struct net_device *ret;
-	int mempos = (dev->mem_start - COMX_MEM_MIN) >> 16;
+    unsigned long mempos =
+	(unsigned long)phys_to_virt((dev->mem_start - COMX_MEM_MIN) >> 16);
 	unsigned long flags;
+    spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 
-
-	save_flags(flags); cli();
-	
+    spin_lock_irqsave(&mister_lock, flags);
 	ret = memory_used[mempos];
 
-	if(ret == dev) {
+    if (ret == dev)
+    {
 		goto out;
 	}
 
 	memory_used[mempos] = dev;
 
-	if (!ch->twin || ret != ch->twin) {
-		if (ret) ((struct comx_channel *)ret->priv)->HW_board_off(ret);
+    if (!ch->twin || ret != ch->twin)
+    {
+	if (ret)
+	    ((struct comx_channel *)ret->priv)->HW_board_off(ret);
 		ch->HW_board_on(dev);
 	}
-out:
-	restore_flags(flags);
+  out:
+    spin_unlock_irqrestore(&mister_lock, flags);
 	return ret;
 }
 
 static void COMX_release_board(struct net_device *dev, struct net_device *savep)
 {
 	unsigned long flags;
-	int mempos = (dev->mem_start - COMX_MEM_MIN) >> 16;
+    unsigned long mempos =
+	(unsigned long)phys_to_virt((dev->mem_start - COMX_MEM_MIN) >> 16);
 	struct comx_channel *ch = dev->priv;
+    spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 
-	save_flags(flags); cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
-	if (memory_used[mempos] == savep) {
+    if (memory_used[mempos] == savep)
+    {
 		goto out;
 	}
 
 	memory_used[mempos] = savep;
-	if (!ch->twin || ch->twin != savep) {
+    if (!ch->twin || ch->twin != savep)
+    {
 		ch->HW_board_off(dev);
-		if (savep) ((struct comx_channel*)savep->priv)->HW_board_on(savep);
+	if (savep)
+	    ((struct comx_channel *)savep->priv)->HW_board_on(savep);
 	}
-out:
-	restore_flags(flags);
+  out:
+    spin_unlock_irqrestore(&mister_lock, flags);
 }
 
 static int COMX_txe(struct net_device *dev) 
@@ -185,13 +201,13 @@
 	int rc = 0;
 
 	savep = ch->HW_access_board(dev);
-	if (COMX_readw(dev,OFF_A_L2_LINKUP) == LINKUP_READY) {
-		rc = COMX_readw(dev,OFF_A_L2_TxEMPTY);
-	} 
-	ch->HW_release_board(dev,savep);
-	if(rc==0xffff) {
-		printk(KERN_ERR "%s, OFF_A_L2_TxEMPTY is %d\n",dev->name, rc);
-	}
+    if (COMX_readw(dev, OFF_A_L2_LINKUP) == LINKUP_READY)
+    {
+	rc = COMX_readw(dev, OFF_A_L2_TxEMPTY);
+	}
+    ch->HW_release_board(dev, savep);
+    if (rc == 0xffff)
+	printk(KERN_ERR "%s, OFF_A_L2_TxEMPTY is %d\n", dev->name, rc);
 	return rc;
 }
 
@@ -205,50 +221,58 @@
 
 	savep = ch->HW_access_board(dev);	
 
-	if (ch->debug_flags & DEBUG_HW_TX) {
-		comx_debug_bytes(dev, skb->data, skb->len,"COMX_send packet");
-	}
+    if (ch->debug_flags & DEBUG_HW_TX)
+	comx_debug_bytes(dev, skb->data, skb->len, "COMX_send packet");
 
-	if (skb->len > COMX_MAX_TX_SIZE) {
-		ret=FRAME_DROPPED;
+    if (skb->len > COMX_MAX_TX_SIZE)
+    {
+	ret = FRAME_DROPPED;
 		goto out;
 	}
 
-	tmp=COMX_readw(dev, OFF_A_L2_TxEMPTY);
-	if ((ch->line_status & LINE_UP) && tmp==1) {
+    tmp = COMX_readw(dev, OFF_A_L2_TxEMPTY);
+    if ((ch->line_status & LINE_UP) && tmp == 1)
+    {
 		int lensave = skb->len;
 		int dest = COMX_readw(dev, OFF_A_L2_TxBUFP);
-		word *data = (word *)skb->data;
+	word *data = (word *) skb->data;
 
-		if(dest==0xffff) {
+	if (dest == 0xffff)
+	{
 			printk(KERN_ERR "%s: OFF_A_L2_TxBUFP is %d\n", dev->name, dest);
-			ret=FRAME_DROPPED;
+	    ret = FRAME_DROPPED;
 			goto out;
 		}
 					
-		writew((unsigned short)skb->len, dev->mem_start + dest);
+	writew((unsigned short)skb->len, phys_to_virt(dev->mem_start + dest));
+	dest += 2;
+	while (skb->len > 1)
+	{
+	    writew(*data++, phys_to_virt(dev->mem_start + dest));
 		dest += 2;
-		while (skb->len > 1) {
-			writew(*data++, dev->mem_start + dest);
-			dest += 2; skb->len -= 2;
+	    skb->len -= 2;
 		}
-		if (skb->len == 1) {
-			writew(*((byte *)data), dev->mem_start + dest);
-		}
-		writew(0, dev->mem_start + (int)hw->channel * 
-		   COMX_CHANNEL_OFFSET + OFF_A_L2_TxEMPTY);
+	if (skb->len == 1)
+	{
+	    writew(*((byte *) data), phys_to_virt(dev->mem_start + dest));
+		}
+	writew(0,
+	       dev->mem_start +
+	       phys_to_virt((int)hw->channel * COMX_CHANNEL_OFFSET +
+			    OFF_A_L2_TxEMPTY));
 		ch->stats.tx_packets++;	
 		ch->stats.tx_bytes += lensave; 
 		ret = FRAME_ACCEPTED;
-	} else {
-		ch->stats.tx_dropped++;
-		printk(KERN_INFO "%s: frame dropped\n",dev->name);
-		if(tmp) {
-			printk(KERN_ERR "%s: OFF_A_L2_TxEMPTY is %d\n",dev->name,tmp);
 		}
+    else
+    {
+	ch->stats.tx_dropped++;
+	printk(KERN_INFO "%s: frame dropped\n", dev->name);
+	if (tmp)
+	    printk(KERN_ERR "%s: OFF_A_L2_TxEMPTY is %d\n", dev->name, tmp);
 	}
 	
-out:
+  out:
 	ch->HW_release_board(dev, savep);
 	dev_kfree_skb(skb);
 	return ret;
@@ -260,21 +284,24 @@
 	word rbuf_offs;
 	struct sk_buff *skb;
 	word len;
-	int i=0;
+    int i = 0;
 	word *writeptr;
 
 	i = 0;
 	rbuf_offs = COMX_readw(dev, OFF_A_L2_RxBUFP);
-	if(rbuf_offs == 0xffff) {
-		printk(KERN_ERR "%s: OFF_A_L2_RxBUFP is %d\n",dev->name,rbuf_offs);
+    if (rbuf_offs == 0xffff)
+    {
+	printk(KERN_ERR "%s: OFF_A_L2_RxBUFP is %d\n", dev->name, rbuf_offs);
 		return 0;
 	}
-	len = readw(dev->mem_start + rbuf_offs);
-	if(len > COMX_MAX_RX_SIZE) {
-		printk(KERN_ERR "%s: packet length is %d\n",dev->name,len);
+    len = readw(phys_to_virt(dev->mem_start + rbuf_offs));
+    if (len > COMX_MAX_RX_SIZE)
+    {
+	printk(KERN_ERR "%s: packet length is %d\n", dev->name, len);
 		return 0;
 	}
-	if ((skb = dev_alloc_skb(len + 16)) == NULL) {
+    if ((skb = dev_alloc_skb(len + 16)) == NULL)
+    {
 		ch->stats.rx_dropped++;
 		COMX_WRITE(dev, OFF_A_L2_DAV, 0);
 		return 0;
@@ -283,49 +310,58 @@
 	skb_reserve(skb, 16);
 	skb_put(skb, len);
 	skb->dev = dev;
-	writeptr = (word *)skb->data;
-	while (i < len) {
-		*writeptr++ = readw(dev->mem_start + rbuf_offs);
+    writeptr = (word *) skb->data;
+    while (i < len)
+    {
+	*writeptr++ = readw(phys_to_virt(dev->mem_start + rbuf_offs));
 		rbuf_offs += 2; 
 		i += 2;
 	}
 	COMX_WRITE(dev, OFF_A_L2_DAV, 0);
 	ch->stats.rx_packets++;
 	ch->stats.rx_bytes += len;
-	if (ch->debug_flags & DEBUG_HW_RX) {
+    if (ch->debug_flags & DEBUG_HW_RX)
 		comx_debug_skb(dev, skb, "COMX_interrupt receiving");
-	}
 	ch->LINE_rx(dev, skb);
 	return 1;
 }
 
 static inline char comx_line_change(struct net_device *dev, char linestat)
 {
-	struct comx_channel *ch=dev->priv;
-	char idle=1;
+    struct comx_channel *ch = dev->priv;
+    char idle = 1;
 	
-	
-	if (linestat & LINE_UP) { /* Vonal fol */
-		if (ch->lineup_delay) {
-			if (!test_and_set_bit(0, &ch->lineup_pending)) {
+    if (linestat & LINE_UP)
+    {				/* Vonal fol */
+	if (ch->lineup_delay)
+	{
+	    if (!test_and_set_bit(0, &ch->lineup_pending))
+	    {
 				ch->lineup_timer.function = comx_lineup_func;
 				ch->lineup_timer.data = (unsigned long)dev;
-				ch->lineup_timer.expires = jiffies +
-					HZ*ch->lineup_delay;
+		ch->lineup_timer.expires = jiffies + HZ * ch->lineup_delay;
 				add_timer(&ch->lineup_timer);
-				idle=0;
+		idle = 0;
+			}
 			}
-		} else {
-			idle=0;
+	else
+	{
+	    idle = 0;
 			ch->LINE_status(dev, ch->line_status |= LINE_UP);
 		}
-	} else { /* Vonal le */
-		idle=0;
-		if (test_and_clear_bit(0, &ch->lineup_pending)) {
+    }
+    else
+    {				/* Vonal le */
+	idle = 0;
+	if (test_and_clear_bit(0, &ch->lineup_pending))
+	{
 			del_timer(&ch->lineup_timer);
-		} else {
+	}
+	else
+	{
 			ch->line_status &= ~LINE_UP;
-			if (ch->LINE_status) {
+	    if (ch->LINE_status)
+	    {
 				ch->LINE_status(dev, ch->line_status);
 			}
 		}
@@ -346,7 +382,8 @@
 	int count = 0;
 	word tmp;
 
-	if (dev == NULL) {
+    if (dev == NULL)
+    {
 		printk(KERN_ERR "COMX_interrupt: irq %d for unknown device\n", irq);
 		return;
 	}
@@ -355,84 +392,109 @@
 
 	interrupted = ch->HW_access_board(dev);
 
-	while (!idle && count < 5000) {
+    while (!idle && count < 5000)
+    {
 		char channel = 0;
+
 		idle = 1;
 
-		while (channel < 2) {
+	while (channel < 2)
+	{
 			char linestat = 0;
 			char buffers_emptied = 0;
 
-			if (channel == 1) {
-				if (ch->twin) {
+	    if (channel == 1)
+	    {
+		if (ch->twin)
+		{
 					dev = ch->twin;
 					ch = dev->priv;
 					hw = ch->HW_privdata;
-				} else {
+		}
+		else
+		{
 					break;
 				}
-			} else {
+	    }
+	    else
+	    {
 				COMX_WRITE(dev, OFF_A_L1_REPENA, 
 				    COMX_readw(dev, OFF_A_L1_REPENA) & 0xFF00);
 			}
 			channel++;
 
 			if ((ch->init_status & (HW_OPEN | LINE_OPEN)) != 
-			   (HW_OPEN | LINE_OPEN)) {
+		(HW_OPEN | LINE_OPEN))
+	    {
 				continue;
 			}
 	
 			/* Collect stats */
 			tmp = COMX_readw(dev, OFF_A_L1_ABOREC);
 			COMX_WRITE(dev, OFF_A_L1_ABOREC, 0);
-			if(tmp==0xffff) {
-				printk(KERN_ERR "%s: OFF_A_L1_ABOREC is %d\n",dev->name,tmp);
+	    if (tmp == 0xffff)
+	    {
+		printk(KERN_ERR "%s: OFF_A_L1_ABOREC is %d\n", dev->name, tmp);
 				break;
-			} else {
+	    }
+	    else
+	    {
 				ch->stats.rx_missed_errors += (tmp >> 8) & 0xff;
 				ch->stats.rx_over_errors += tmp & 0xff;
 			}
 			tmp = COMX_readw(dev, OFF_A_L1_CRCREC);
 			COMX_WRITE(dev, OFF_A_L1_CRCREC, 0);
-			if(tmp==0xffff) {
-				printk(KERN_ERR "%s: OFF_A_L1_CRCREC is %d\n",dev->name,tmp);
+	    if (tmp == 0xffff)
+	    {
+		printk(KERN_ERR "%s: OFF_A_L1_CRCREC is %d\n", dev->name, tmp);
 				break;
-			} else {
+	    }
+	    else
+	    {
 				ch->stats.rx_crc_errors += (tmp >> 8) & 0xff;
 				ch->stats.rx_missed_errors += tmp & 0xff;
 			}
 			
-			if ((ch->line_status & LINE_UP) && ch->LINE_rx) {
-				tmp=COMX_readw(dev, OFF_A_L2_DAV); 
-				while (tmp==1) {
-					idle=0;
-					buffers_emptied+=comx_read_buffer(dev);
-					tmp=COMX_readw(dev, OFF_A_L2_DAV); 
+	    if ((ch->line_status & LINE_UP) && ch->LINE_rx)
+	    {
+		tmp = COMX_readw(dev, OFF_A_L2_DAV);
+		while (tmp == 1)
+		{
+		    idle = 0;
+		    buffers_emptied += comx_read_buffer(dev);
+		    tmp = COMX_readw(dev, OFF_A_L2_DAV);
 				}
-				if(tmp) {
+		if (tmp)
+		{
 					printk(KERN_ERR "%s: OFF_A_L2_DAV is %d\n", dev->name, tmp);
 					break;
 				}
 			}
 
-			tmp=COMX_readw(dev, OFF_A_L2_TxEMPTY);
-			if (tmp==1 && ch->LINE_tx) {
+	    tmp = COMX_readw(dev, OFF_A_L2_TxEMPTY);
+	    if (tmp == 1 && ch->LINE_tx)
+	    {
 				ch->LINE_tx(dev);
 			} 
-			if(tmp==0xffff) {
+	    if (tmp == 0xffff)
+	    {
 				printk(KERN_ERR "%s: OFF_A_L2_TxEMPTY is %d\n", dev->name, tmp);
 				break;
 			}
 
-			if (COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8) {
+	    if (COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8)
+	    {
 				linestat &= ~LINE_UP;
-			} else {
+	    }
+	    else
+	    {
 				linestat |= LINE_UP;
 			}
 
-			if ((linestat & LINE_UP) != (ch->line_status & LINE_UP)) {
+	    if ((linestat & LINE_UP) != (ch->line_status & LINE_UP))
+	    {
 				ch->stats.tx_carrier_errors++;
-				idle &= comx_line_change(dev,linestat);
+		idle &= comx_line_change(dev, linestat);
 			}
 				
 			hw->histogram[(int)buffers_emptied]++;
@@ -440,8 +502,9 @@
 		count++;
 	}
 
-	if(count==5000) {
-		printk(KERN_WARNING "%s: interrupt stuck\n",dev->name);
+    if (count == 5000)
+    {
+	printk(KERN_WARNING "%s: interrupt stuck\n", dev->name);
 	}
 
 	ch->HW_release_board(dev, interrupted);
@@ -453,32 +516,35 @@
 	struct comx_privdata *hw = ch->HW_privdata;
 	struct proc_dir_entry *procfile = ch->procdir->subdir;
 	unsigned long jiffs;
-	int twin_open=0;
+    int twin_open = 0;
 	int retval;
 	struct net_device *savep;
 
-	if (!dev->base_addr || !dev->irq || !dev->mem_start) {
+    if (!dev->base_addr || !dev->irq || !dev->mem_start)
 		return -ENODEV;
-	}
-
-	if (ch->twin && (((struct comx_channel *)(ch->twin->priv))->init_status & HW_OPEN)) {
-		twin_open=1;
-	}
 
-	if (!twin_open) {
-		if (!request_region(dev->base_addr, hw->io_extent, dev->name)) {
+    if (ch->twin &&
+	(((struct comx_channel *)(ch->twin->priv))->init_status & HW_OPEN))
+	twin_open = 1;
+
+    if (!twin_open)
+    {
+	if (check_region(dev->base_addr, hw->io_extent))
+	{
 			return -EAGAIN;
 		}
-		if (request_irq(dev->irq, COMX_interrupt, 0, dev->name, 
-		   (void *)dev)) {
-			printk(KERN_ERR "comx-hw-comx: unable to obtain irq %d\n", dev->irq);
-			release_region(dev->base_addr, hw->io_extent);
+	if (request_irq(dev->irq, COMX_interrupt, 0, dev->name, (void *)dev))
+	{
+	    printk(KERN_ERR "comx-hw-comx: unable to obtain irq %d\n",
+		   dev->irq);
 			return -EAGAIN;
 		}
 		ch->init_status |= IRQ_ALLOCATED;
-		if (!ch->HW_load_board || ch->HW_load_board(dev)) {
+		request_region(dev->base_addr, hw->io_extent, dev->name);
+	if (!ch->HW_load_board || ch->HW_load_board(dev))
+	{
 			ch->init_status &= ~IRQ_ALLOCATED;
-			retval=-ENODEV;
+	    retval = -ENODEV;
 			goto error;
 		}
 	}
@@ -486,69 +552,72 @@
 	savep = ch->HW_access_board(dev);
 	COMX_WRITE(dev, OFF_A_L2_LINKUP, 0);
 
-	if (ch->HW_set_clock) {
+    if (ch->HW_set_clock)
 		ch->HW_set_clock(dev);
-	}
 
 	COMX_CMD(dev, COMX_CMD_INIT); 
 	jiffs = jiffies;
-	while (COMX_readw(dev, OFF_A_L2_LINKUP) != 1 && jiffies < jiffs + HZ) {
+    while (COMX_readw(dev, OFF_A_L2_LINKUP) != 1 && jiffies < jiffs + HZ)
 		schedule_timeout(1);
-	}
 	
-	if (jiffies >= jiffs + HZ) {
+    if (jiffies >= jiffs + HZ)
+    {
 		printk(KERN_ERR "%s: board timeout on INIT command\n", dev->name);
 		ch->HW_release_board(dev, savep);
-		retval=-EIO;
+	retval = -EIO;
 		goto error;
 	}
-	udelay(1000);
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout(1);
 
 	COMX_CMD(dev, COMX_CMD_OPEN);
 
 	jiffs = jiffies;
-	while (COMX_readw(dev, OFF_A_L2_LINKUP) != 3 && jiffies < jiffs + HZ) {
+    while (COMX_readw(dev, OFF_A_L2_LINKUP) != 3 && jiffies < jiffs + HZ)
 		schedule_timeout(1);
-	}
 	
-	if (jiffies >= jiffs + HZ) {
+    if (jiffies >= jiffs + HZ)
+    {
 		printk(KERN_ERR "%s: board timeout on OPEN command\n", dev->name);
 		ch->HW_release_board(dev, savep);
-		retval=-EIO;
+	retval = -EIO;
 		goto error;
 	}
 	
 	ch->init_status |= HW_OPEN;
 	
 	/* Ez eleg ciki, de ilyen a rendszer */
-	if (COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8) {
+    if (COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8)
+    {
 		ch->line_status &= ~LINE_UP;
-	} else {
+    }
+    else
+    {
 		ch->line_status |= LINE_UP;
 	}
 	
-	if (ch->LINE_status) {
+    if (ch->LINE_status)
+    {
 		ch->LINE_status(dev, ch->line_status);
 	}
 
 	ch->HW_release_board(dev, savep);
 
-	for ( ; procfile ; procfile = procfile->next) {
-		if (strcmp(procfile->name, FILENAME_IRQ) == 0 
-		    || strcmp(procfile->name, FILENAME_IO) == 0
-		    || strcmp(procfile->name, FILENAME_MEMADDR) == 0
-		    || strcmp(procfile->name, FILENAME_CHANNEL) == 0
-		    || strcmp(procfile->name, FILENAME_FIRMWARE) == 0
-		    || strcmp(procfile->name, FILENAME_CLOCK) == 0) {
+    for (; procfile; procfile = procfile->next)
+    {
+	if (strcmp(procfile->name, FILENAME_IRQ) == 0 ||
+	    strcmp(procfile->name, FILENAME_IO) == 0 ||
+	    strcmp(procfile->name, FILENAME_MEMADDR) == 0 ||
+	    strcmp(procfile->name, FILENAME_CHANNEL) == 0 ||
+	    strcmp(procfile->name, FILENAME_FIRMWARE) == 0 ||
+	    strcmp(procfile->name, FILENAME_CLOCK) == 0)
 			procfile->mode = S_IFREG | 0444;
-		
 		}
-	}	
-	
 	return 0;	
 
-error:
-	if(!twin_open) {
+  error:
+    if (!twin_open)
+    {
 		release_region(dev->base_addr, hw->io_extent);
 		free_irq(dev->irq, (void *)dev);
 	}
@@ -567,33 +636,37 @@
 	savep = ch->HW_access_board(dev);
 
 	COMX_CMD(dev, COMX_CMD_CLOSE);
-	udelay(1000);
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout(1);
 	COMX_CMD(dev, COMX_CMD_EXIT);
 
 	ch->HW_release_board(dev, savep);
 
-	if (ch->init_status & IRQ_ALLOCATED) {
+    if (ch->init_status & IRQ_ALLOCATED)
+    {
 		free_irq(dev->irq, (void *)dev);
 		ch->init_status &= ~IRQ_ALLOCATED;
 	}
 	release_region(dev->base_addr, hw->io_extent);
 
 	if (ch->twin && (twin_ch = ch->twin->priv) && 
-	    (twin_ch->init_status & HW_OPEN)) {
+	(twin_ch->init_status & HW_OPEN))
+    {
 		/* Pass the irq to the twin */
 		if (request_irq(dev->irq, COMX_interrupt, 0, ch->twin->name, 
-		   (void *)ch->twin) == 0) {
+	     (void *)ch->twin) == 0)
 			twin_ch->init_status |= IRQ_ALLOCATED;
 		}
-	}
 
-	for ( ; procfile ; procfile = procfile->next) {
-		if (strcmp(procfile->name, FILENAME_IRQ) == 0 
-		    || strcmp(procfile->name, FILENAME_IO) == 0
-		    || strcmp(procfile->name, FILENAME_MEMADDR) == 0
-		    || strcmp(procfile->name, FILENAME_CHANNEL) == 0
-		    || strcmp(procfile->name, FILENAME_FIRMWARE) == 0
-		    || strcmp(procfile->name, FILENAME_CLOCK) == 0) {
+    for (; procfile; procfile = procfile->next)
+    {
+	if (strcmp(procfile->name, FILENAME_IRQ) == 0 ||
+	    strcmp(procfile->name, FILENAME_IO) == 0 ||
+	    strcmp(procfile->name, FILENAME_MEMADDR) == 0 ||
+	    strcmp(procfile->name, FILENAME_CHANNEL) == 0 ||
+	    strcmp(procfile->name, FILENAME_FIRMWARE) == 0 ||
+	    strcmp(procfile->name, FILENAME_CLOCK) == 0)
+	{
 			procfile->mode = S_IFREG | 0644;
 		}
 	}
@@ -611,7 +684,8 @@
 
 	savep = ch->HW_access_board(dev);
 
-	len += sprintf(page + len, "Board data: %s %s %s %s\nPBUFOVR: %02x, "
+    len += sprintf(page + len,
+		"Board data: %s %s %s %s\nPBUFOVR: %02x, "
 		"MODSTAT: %02x, LINKUP: %02x, DAV: %02x\nRxBUFP: %02x, "
 		"TxEMPTY: %02x, TxBUFP: %02x\n",
 		(ch->init_status & HW_OPEN) ? "HW_OPEN" : "",
@@ -619,16 +693,18 @@
 		(ch->init_status & FW_LOADED) ? "FW_LOADED" : "",
 		(ch->init_status & IRQ_ALLOCATED) ? "IRQ_ALLOCATED" : "",
 		COMX_readw(dev, OFF_A_L1_PBUFOVR) & 0xff,
-		(COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8) & 0xff,
-		COMX_readw(dev, OFF_A_L2_LINKUP) & 0xff,
-		COMX_readw(dev, OFF_A_L2_DAV) & 0xff,
-		COMX_readw(dev, OFF_A_L2_RxBUFP) & 0xff,
-		COMX_readw(dev, OFF_A_L2_TxEMPTY) & 0xff,
+		(COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8) & 0xff, COMX_readw(dev,
+									    OFF_A_L2_LINKUP)
+		& 0xff, COMX_readw(dev, OFF_A_L2_DAV) & 0xff, COMX_readw(dev,
+									 OFF_A_L2_RxBUFP)
+		& 0xff, COMX_readw(dev, OFF_A_L2_TxEMPTY) & 0xff,
 		COMX_readw(dev, OFF_A_L2_TxBUFP) & 0xff);
 
-	len += sprintf(page + len, "hist[0]: %8lu hist[1]: %8lu hist[2]: %8lu\n"
-		"hist[3]: %8lu hist[4]: %8lu\n",hw->histogram[0],hw->histogram[1],
-		hw->histogram[2],hw->histogram[3],hw->histogram[4]);
+    len += sprintf(page + len,
+		"hist[0]: %8lu hist[1]: %8lu hist[2]: %8lu\n"
+		"hist[3]: %8lu hist[4]: %8lu\n", hw->histogram[0],
+		hw->histogram[1], hw->histogram[2], hw->histogram[3],
+		hw->histogram[4]);
 
 	ch->HW_release_board(dev, savep);
 
@@ -641,7 +717,9 @@
 	struct comx_privdata *hw = ch->HW_privdata;
 	struct comx_firmware *fw = hw->firmware;
 	word board_segment = dev->mem_start >> 16;
-	int mempos = (dev->mem_start - COMX_MEM_MIN) >> 16;
+    unsigned long mempos =
+	(unsigned long)phys_to_virt((dev->mem_start - COMX_MEM_MIN) >> 16);
+    spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 	unsigned long flags;
 	unsigned char id1, id2;
 	struct net_device *saved;
@@ -650,25 +728,24 @@
 	int len;
 	byte *COMX_address;
 
-	if (!fw || !fw->len) {
+    if (!fw || !fw->len)
+    {
 		struct comx_channel *twin_ch = ch->twin ? ch->twin->priv : NULL;
 		struct comx_privdata *twin_hw;
 
-		if (!twin_ch || !(twin_hw = twin_ch->HW_privdata)) {
+	if (!twin_ch || !(twin_hw = twin_ch->HW_privdata))
 			return -EAGAIN;
-		}
 
-		if (!(fw = twin_hw->firmware) || !fw->len) {
+	if (!(fw = twin_hw->firmware) || !fw->len)
 			return -EAGAIN;
 		}
-	}
 
 	id1 = fw->data[OFF_FW_L1_ID]; 
 	id2 = fw->data[OFF_FW_L1_ID + 1];
 
-	if (id1 != FW_L1_ID_1 || id2 != FW_L1_ID_2_COMX) {
-		printk(KERN_ERR "%s: incorrect firmware, load aborted\n", 
-			dev->name);
+    if (id1 != FW_L1_ID_1 || id2 != FW_L1_ID_2_COMX)
+    {
+	printk(KERN_ERR "%s: incorrect firmware, load aborted\n", dev->name);
 		return -EAGAIN;
 	}
 
@@ -677,98 +754,109 @@
 
 	id1 = fw->data[OFF_FW_L2_ID]; 
 	id2 = fw->data[OFF_FW_L2_ID + 1];
-	if (id1 == FW_L2_ID_1 && (id2 == 0xc0 || id2 == 0xc1 || id2 == 0xc2)) {
+    if (id1 == FW_L2_ID_1 && (id2 == 0xc0 || id2 == 0xc1 || id2 == 0xc2))
 		printk(KERN_INFO "with Layer 2 code %s\n", 
 			(char *)(fw->data + OFF_FW_L2_ID + 2));
-	}
 
 	outb_p(board_segment | COMX_BOARD_RESET, dev->base_addr);
 	/* 10 usec should be enough here */
-	udelay(100);
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout(1);
 
-	save_flags(flags); cli();
-	saved=memory_used[mempos];
-	if(saved) {
+    spin_lock_irqsave(&mister_lock, flags);
+    saved = memory_used[mempos];
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_off(saved);
-	}
-	memory_used[mempos]=dev;
+    memory_used[mempos] = dev;
 
 	outb_p(board_segment | COMX_ENABLE_BOARD_MEM, dev->base_addr);
 
-	writeb(0, dev->mem_start + COMX_JAIL_OFFSET);	
+    writeb(0, phys_to_virt(dev->mem_start + COMX_JAIL_OFFSET));
 
-	loopcount=0;
-	while(loopcount++ < 10000 && 
-	    readb(dev->mem_start + COMX_JAIL_OFFSET) != COMX_JAIL_VALUE) {
-		udelay(100);
+    loopcount = 0;
+    while (loopcount++ < 100 &&
+	   readb(phys_to_virt(dev->mem_start + COMX_JAIL_OFFSET)) !=
+	   COMX_JAIL_VALUE)
+    {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
 	}	
 	
-	if (readb(dev->mem_start + COMX_JAIL_OFFSET) != COMX_JAIL_VALUE) {
+    if (readb(phys_to_virt(dev->mem_start + COMX_JAIL_OFFSET)) !=
+	COMX_JAIL_VALUE)
+    {
 		printk(KERN_ERR "%s: Can't reset board, JAIL value is %02x\n",
-			dev->name, readb(dev->mem_start + COMX_JAIL_OFFSET));
-		retval=-ENODEV;
+	       dev->name,
+	       readb(phys_to_virt(dev->mem_start + COMX_JAIL_OFFSET)));
+	retval = -ENODEV;
 		goto out;
 	}
 
-	writeb(0x55, dev->mem_start + 0x18ff);
+    writeb(0x55, phys_to_virt(dev->mem_start + 0x18ff));
 	
-	loopcount=0;
-	while(loopcount++ < 10000 && readb(dev->mem_start + 0x18ff) != 0) {
-		udelay(100);
+    loopcount = 0;
+    while (loopcount++ < 100 &&
+	   readb(phys_to_virt(dev->mem_start + 0x18ff)) != 0)
+    {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
 	}
 
-	if(readb(dev->mem_start + 0x18ff) != 0) {
-		printk(KERN_ERR "%s: Can't reset board, reset timeout\n",
-			dev->name);
-		retval=-ENODEV;
+    if (readb(phys_to_virt(dev->mem_start + 0x18ff)) != 0)
+    {
+	printk(KERN_ERR "%s: Can't reset board, reset timeout\n", dev->name);
+	retval = -ENODEV;
 		goto out;
 	}		
 
 	len = 0;
-	COMX_address = (byte *)dev->mem_start;
-	while (fw->len > len) {
-		writeb(fw->data[len++], COMX_address++);
-	}
+    COMX_address = (byte *) dev->mem_start;
+    while (fw->len > len)
+	writeb(fw->data[len++], phys_to_virt((unsigned long)(COMX_address++)));
 
 	len = 0;
-	COMX_address = (byte *)dev->mem_start;
-	while (len != fw->len && readb(COMX_address++) == fw->data[len]) {
+    COMX_address = (byte *) dev->mem_start;
+    while (len != fw->len &&
+	   readb(phys_to_virt((unsigned long)(COMX_address++))) ==
+	   fw->data[len])
 		len++;
-	}
 
-	if (len != fw->len) {
+    if (len != fw->len)
+    {
 		printk(KERN_ERR "%s: error loading firmware: [%d] is 0x%02x "
 			"instead of 0x%02x\n", dev->name, len, 
-			readb(COMX_address - 1), fw->data[len]);
-		retval=-EAGAIN;
+	       readb(phys_to_virt((unsigned long)(COMX_address - 1))),
+	       fw->data[len]);
+	retval = -EAGAIN;
 		goto out;
 	}
 
-	writeb(0, dev->mem_start + COMX_JAIL_OFFSET);
+    writeb(0, phys_to_virt(dev->mem_start + COMX_JAIL_OFFSET));
 
 	loopcount = 0;
-	while ( loopcount++ < 10000 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1 ) {
-		udelay(100);
+    while (loopcount++ < 1000 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
 	}
 
-	if (COMX_readw(dev, OFF_A_L2_LINKUP) != 1) {
+    if (COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
 		printk(KERN_ERR "%s: error starting firmware, linkup word is %04x\n",
 			dev->name, COMX_readw(dev, OFF_A_L2_LINKUP));
-		retval=-EAGAIN;
+	retval = -EAGAIN;
 		goto out;
 	}
 
-
 	ch->init_status |= FW_LOADED;
-	retval=0;
+    retval = 0;
 
-out: 
+  out:
 	outb_p(board_segment | COMX_DISABLE_ALL, dev->base_addr);
-	if(saved) {
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_on(saved);
-	}
-	memory_used[mempos]=saved;
-	restore_flags(flags);
+    memory_used[mempos] = saved;
+    spin_unlock_irqrestore(&mister_lock, flags);
 	return retval;
 }
 
@@ -778,33 +866,35 @@
 	struct comx_privdata *hw = ch->HW_privdata;
 	struct comx_firmware *fw = hw->firmware;
 	word board_segment = dev->mem_start >> 16;
-	int mempos = (dev->mem_start - COMX_MEM_MIN) >> 16;
-	#if 0
+    unsigned long mempos =
+	(unsigned long)phys_to_virt((dev->mem_start - COMX_MEM_MIN) >> 16);
+#if 0
 	unsigned char id1, id2;
-	#endif
+#endif
 	struct net_device *saved;
 	unsigned long flags;
 	int retval;
 	int loopcount;
 	int len;
 	byte *COMX_address;
+    spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 
-	if (!fw || !fw->len) {
+    if (!fw || !fw->len)
+    {
 		struct comx_channel *twin_ch = ch->twin ? ch->twin->priv : NULL;
 		struct comx_privdata *twin_hw;
 
-		if (!twin_ch || !(twin_hw = twin_ch->HW_privdata)) {
+	if (!twin_ch || !(twin_hw = twin_ch->HW_privdata))
 			return -EAGAIN;
-		}
 
-		if (!(fw = twin_hw->firmware) || !fw->len) {
+	if (!(fw = twin_hw->firmware) || !fw->len)
 			return -EAGAIN;
 		}
-	}
 
 	/* Ide kell olyat tenni, hogy ellenorizze az ID-t */
 
-	if (inb_p(dev->base_addr) != CMX_ID_BYTE) {
+    if (inb_p(dev->base_addr) != CMX_ID_BYTE)
+    {
 		printk(KERN_ERR "%s: CMX id byte is invalid(%02x)\n", dev->name,
 			inb_p(dev->base_addr));
 		return -ENODEV;
@@ -813,60 +903,63 @@
 	printk(KERN_INFO "%s: Loading CMX Layer 1 firmware %s\n", dev->name, 
 		(char *)(fw->data + OFF_FW_L1_ID + 2));
 
-	save_flags(flags); cli();
-	saved=memory_used[mempos];
-	if(saved) {
+    spin_lock_irqsave(&mister_lock, flags);
+    saved = memory_used[mempos];
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_off(saved);
-	}
-	memory_used[mempos]=dev;
+    memory_used[mempos] = dev;
 	
 	outb_p(board_segment | COMX_ENABLE_BOARD_MEM | COMX_BOARD_RESET, 
 		dev->base_addr);
 
 	len = 0;
-	COMX_address = (byte *)dev->mem_start;
-	while (fw->len > len) {
-		writeb(fw->data[len++], COMX_address++);
-	}
+    COMX_address = (byte *) dev->mem_start;
+    while (fw->len > len)
+	writeb(fw->data[len++], phys_to_virt((unsigned long)(COMX_address++)));
 
 	len = 0;
-	COMX_address = (byte *)dev->mem_start;
-	while (len != fw->len && readb(COMX_address++) == fw->data[len]) {
+    COMX_address = (byte *) dev->mem_start;
+    while (len != fw->len &&
+	   readb(phys_to_virt((unsigned long)(COMX_address++))) ==
+	   fw->data[len])
 		len++;
-	}
 
 	outb_p(board_segment | COMX_ENABLE_BOARD_MEM, dev->base_addr);
 
-	if (len != fw->len) {
+    if (len != fw->len)
+    {
 		printk(KERN_ERR "%s: error loading firmware: [%d] is 0x%02x "
 			"instead of 0x%02x\n", dev->name, len, 
-			readb(COMX_address - 1), fw->data[len]);
-		retval=-EAGAIN;
+	       readb(phys_to_virt((unsigned long)(COMX_address - 1))),
+	       fw->data[len]);
+	retval = -EAGAIN;
 		goto out;
 	}
 
-	loopcount=0;
-	while( loopcount++ < 10000 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1 ) {
-		udelay(100);
+    loopcount = 0;
+    while (loopcount++ < 100 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
 	}
 
-	if (COMX_readw(dev, OFF_A_L2_LINKUP) != 1) {
+    if (COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
 		printk(KERN_ERR "%s: error starting firmware, linkup word is %04x\n",
 			dev->name, COMX_readw(dev, OFF_A_L2_LINKUP));
-		retval=-EAGAIN;
+	retval = -EAGAIN;
 		goto out;
 	}
 
 	ch->init_status |= FW_LOADED;
-	retval=0;
+    retval = 0;
 
-out: 
+  out:
 	outb_p(board_segment | COMX_DISABLE_ALL, dev->base_addr);
-	if(saved) {
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_on(saved);
-	}
-	memory_used[mempos]=saved;
-	restore_flags(flags);
+    memory_used[mempos] = saved;
+    spin_lock_irqsave(&mister_lock, flags);
 	return retval;
 }
 
@@ -876,36 +969,35 @@
 	struct comx_privdata *hw = ch->HW_privdata;
 	struct comx_firmware *fw = hw->firmware;
 	word board_segment = dev->mem_start >> 12;
-	int mempos = (dev->mem_start - COMX_MEM_MIN) >> 16;
+    unsigned long mempos =
+	(unsigned long)phys_to_virt((dev->mem_start - COMX_MEM_MIN) >> 16);
 	struct net_device *saved;
 	unsigned char id1, id2;
 	unsigned long flags;
+    spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 	int retval;
 	int loopcount;
 	int len;
 	word *HICOMX_address;
 	char id = 1;
 
-	if (!fw || !fw->len) {
+    if (!fw || !fw->len)
+    {
 		struct comx_channel *twin_ch = ch->twin ? ch->twin->priv : NULL;
 		struct comx_privdata *twin_hw;
 
-		if (!twin_ch || !(twin_hw = twin_ch->HW_privdata)) {
+	if (!twin_ch || !(twin_hw = twin_ch->HW_privdata))
 			return -EAGAIN;
-		}
 
-		if (!(fw = twin_hw->firmware) || !fw->len) {
+	if (!(fw = twin_hw->firmware) || !fw->len)
 			return -EAGAIN;
 		}
-	}
 
-	while (id != 4) {
-		if (inb_p(dev->base_addr + id++) != HICOMX_ID_BYTE) {
-			break;
-		}
-	}
+    while (id != 4)
+	if (inb_p(dev->base_addr + id++) != HICOMX_ID_BYTE) break;
 
-	if (id != 4) {
+    if (id != 4)
+    {
 		printk(KERN_ERR "%s: can't find HICOMX at 0x%04x, id[%d] = %02x\n",
 			dev->name, (unsigned int)dev->base_addr, id - 1,
 			inb_p(dev->base_addr + id - 1));
@@ -914,7 +1006,8 @@
 
 	id1 = fw->data[OFF_FW_L1_ID]; 
 	id2 = fw->data[OFF_FW_L1_ID + 1];
-	if (id1 != FW_L1_ID_1 || id2 != FW_L1_ID_2_HICOMX) {
+    if (id1 != FW_L1_ID_1 || id2 != FW_L1_ID_2_HICOMX)
+    {
 		printk(KERN_ERR "%s: incorrect firmware, load aborted\n", dev->name);
 		return -EAGAIN;
 	}
@@ -924,7 +1017,8 @@
 
 	id1 = fw->data[OFF_FW_L2_ID]; 
 	id2 = fw->data[OFF_FW_L2_ID + 1];
-	if (id1 == FW_L2_ID_1 && (id2 == 0xc0 || id2 == 0xc1 || id2 == 0xc2)) {
+    if (id1 == FW_L2_ID_1 && (id2 == 0xc0 || id2 == 0xc1 || id2 == 0xc2))
+    {
 		printk(KERN_INFO "with Layer 2 code %s\n", 
 			(char *)(fw->data + OFF_FW_L2_ID + 2));
 	}
@@ -932,33 +1026,37 @@
 	outb_p(board_segment | HICOMX_BOARD_RESET, dev->base_addr);
 	udelay(10);	
 
-	save_flags(flags); cli();
-	saved=memory_used[mempos];
-	if(saved) {
+    spin_lock_irqsave(&mister_lock, flags);
+    saved = memory_used[mempos];
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_off(saved);
-	}
-	memory_used[mempos]=dev;
+    memory_used[mempos] = dev;
 
 	outb_p(board_segment | HICOMX_ENABLE_BOARD_MEM, dev->base_addr);
 	outb_p(HICOMX_PRG_MEM, dev->base_addr + 1);
 
 	len = 0;
-	HICOMX_address = (word *)dev->mem_start;
-	while (fw->len > len) {
-		writeb(fw->data[len++], HICOMX_address++);
+    HICOMX_address = (word *) dev->mem_start;
+    while (fw->len > len)
+    {
+	writeb(fw->data[len++],
+	       phys_to_virt((unsigned long)(HICOMX_address++)));
 	}
 
 	len = 0;
-	HICOMX_address = (word *)dev->mem_start;
-	while (len != fw->len && (readw(HICOMX_address++) & 0xff) == fw->data[len]) {
+    HICOMX_address = (word *) dev->mem_start;
+    while (len != fw->len &&
+	   (readw(phys_to_virt((unsigned long)(HICOMX_address++))) & 0xff) ==
+	   fw->data[len])
 		len++;
-	}
 
-	if (len != fw->len) {
+    if (len != fw->len)
+    {
 		printk(KERN_ERR "%s: error loading firmware: [%d] is 0x%02x "
 			"instead of 0x%02x\n", dev->name, len, 
-			readw(HICOMX_address - 1) & 0xff, fw->data[len]);
-		retval=-EAGAIN;
+	       readw(phys_to_virt((unsigned long)(HICOMX_address - 1))) & 0xff,
+	       fw->data[len]);
+	retval = -EAGAIN;
 		goto out;
 	}
 
@@ -967,30 +1065,32 @@
 
 	outb_p(board_segment | HICOMX_ENABLE_BOARD_MEM, dev->base_addr);
 
-	loopcount=0;
-	while(loopcount++ < 10000 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1) {
-		udelay(100);
+    loopcount = 0;
+    while (loopcount++ < 100 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
 	}
 
-	if ( COMX_readw(dev, OFF_A_L2_LINKUP) != 1 ) {
+    if (COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
 		printk(KERN_ERR "%s: error starting firmware, linkup word is %04x\n",
 			dev->name, COMX_readw(dev, OFF_A_L2_LINKUP));
-		retval=-EAGAIN;
+	retval = -EAGAIN;
 		goto out;
 	}
 
 	ch->init_status |= FW_LOADED;
-	retval=0;
+    retval = 0;
 
-out:
+  out:
 	outb_p(board_segment | HICOMX_DISABLE_ALL, dev->base_addr);
 	outb_p(HICOMX_DATA_MEM, dev->base_addr + 1);
 
-	if(saved) {
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_on(saved);
-	}
-	memory_used[mempos]=saved;
-	restore_flags(flags);
+    memory_used[mempos] = saved;
+    spin_unlock_irqrestore(&mister_lock, flags);
 	return retval;
 }
 
@@ -1004,26 +1104,23 @@
 	struct comx_channel *ch_twin;
 	struct comx_privdata *hw_twin;
 
+    for (; procfile; procfile = procfile->next)
+    {
 
-	for ( ; procfile ; procfile = procfile->next) {
-	
-		if(!S_ISDIR(procfile->mode)) {
+	if (!S_ISDIR(procfile->mode))
 			continue;
-		}
-	
-		twin=procfile->data;
-		ch_twin=twin->priv;
-		hw_twin=ch_twin->HW_privdata;
 
+	twin = procfile->data;
+	ch_twin = twin->priv;
+	hw_twin = ch_twin->HW_privdata;
 
 		if (twin != dev && dev->irq && dev->base_addr && dev->mem_start &&
 		   dev->irq == twin->irq && dev->base_addr == twin->base_addr &&
 	  	   dev->mem_start == twin->mem_start &&
 		   hw->channel == (1 - hw_twin->channel) &&
-		   ch->hardware == ch_twin->hardware) {
+	    ch->hardware == ch_twin->hardware)
 		   	return twin;
 		}
-	}
 	return NULL;
 }
 
@@ -1036,51 +1133,62 @@
 	struct comx_privdata *hw = ch->HW_privdata;
 	char *page;
 
-
-	if(ch->init_status & HW_OPEN) {
+    if (ch->init_status & HW_OPEN)
+    {
 		return -EAGAIN;	
 	}
 	
-	if (strcmp(FILENAME_FIRMWARE, entry->name) != 0) {
-		if (!(page = (char *)__get_free_page(GFP_KERNEL))) {
+    if (strcmp(FILENAME_FIRMWARE, entry->name) != 0)
+    {
+	if (!(page = (char *)__get_free_page(GFP_KERNEL)))
+	{
 			return -ENOMEM;
 		}
-		if(copy_from_user(page, buffer, count = (min_t(int, count, PAGE_SIZE))))
+	if (copy_from_user
+	    (page, buffer, count = (min_t(int, count, PAGE_SIZE))))
 		{
 			count = -EFAULT;
 			goto out;
 		}
-		if (page[count-1] == '\n')
-			page[count-1] = '\0';
+	if (page[count - 1] == '\n')
+	    page[count - 1] = '\0';
 		else if (count < PAGE_SIZE)
 			page[count] = '\0';
-		else if (page[count]) {
+	else if (page[count])
+	{
  			count = -EINVAL;
 			goto out;
 		}
-		page[count]=0;	/* Null terminate */
-	} else {
+	page[count] = 0;	/* Null terminate */
+    }
+    else
+    {
 		byte *tmp;
 
-		if (!hw->firmware) {
-			if ((hw->firmware = kmalloc(sizeof(struct comx_firmware), 
-			    GFP_KERNEL)) == NULL) {
+	if (!hw->firmware)
+	{
+	    if ((hw->firmware =
+		 kmalloc(sizeof(struct comx_firmware), GFP_KERNEL)) == NULL)
+	    {
 			    	return -ENOMEM;
 			}
 			hw->firmware->len = 0;
 			hw->firmware->data = NULL;
 		}
 		
-		if ((tmp = kmalloc(count + file->f_pos, GFP_KERNEL)) == NULL) {
+	if ((tmp = kmalloc(count + file->f_pos, GFP_KERNEL)) == NULL)
+	{
 			return -ENOMEM;
 		}
 		
 		/* Ha nem 0 a fpos, akkor meglevo file-t irunk. Gyenge trukk. */
-		if (hw->firmware && hw->firmware->len && file->f_pos 
-		    && hw->firmware->len < count + file->f_pos) {
+	if (hw->firmware && hw->firmware->len && file->f_pos &&
+	    hw->firmware->len < count + file->f_pos)
+	{
 			memcpy(tmp, hw->firmware->data, hw->firmware->len);
 		}
-		if (hw->firmware->data) {
+	if (hw->firmware->data)
+	{
 			kfree(hw->firmware->data);
 		}
 		copy_from_user(tmp + file->f_pos, buffer, count);
@@ -1090,68 +1198,92 @@
 		return count;
 	}
 
-	if (strcmp(entry->name, FILENAME_CHANNEL) == 0) {
+    if (strcmp(entry->name, FILENAME_CHANNEL) == 0)
+    {
 		hw->channel = simple_strtoul(page, NULL, 0);
-		if (hw->channel >= MAX_CHANNELNO) {
+	if (hw->channel >= MAX_CHANNELNO)
+	{
 			printk(KERN_ERR "Invalid channel number\n");
 			hw->channel = 0;
 		}
-		if ((ch->twin = comx_twin_check(dev)) != NULL) {
+	if ((ch->twin = comx_twin_check(dev)) != NULL)
+	{
 			struct comx_channel *twin_ch = ch->twin->priv;
+
 			twin_ch->twin = dev;
 		}
-	} else if (strcmp(entry->name, FILENAME_IRQ) == 0) {
+    }
+    else if (strcmp(entry->name, FILENAME_IRQ) == 0)
+    {
 		dev->irq = simple_strtoul(page, NULL, 0);
-		if (dev->irq == 2) {
+	if (dev->irq == 2)
+	{
 			dev->irq = 9;
 		}
-		if (dev->irq < 3 || dev->irq > 15) {
+	if (dev->irq < 3 || dev->irq > 15)
+	{
 			printk(KERN_ERR "comxhw: Invalid irq number\n");
 			dev->irq = 0;
 		}
-		if ((ch->twin = comx_twin_check(dev)) != NULL) {
+	if ((ch->twin = comx_twin_check(dev)) != NULL)
+	{
 			struct comx_channel *twin_ch = ch->twin->priv;
+
 			twin_ch->twin = dev;
 		}
-	} else if (strcmp(entry->name, FILENAME_IO) == 0) {
+    }
+    else if (strcmp(entry->name, FILENAME_IO) == 0)
+    {
 		dev->base_addr = simple_strtoul(page, NULL, 0);
-		if ((dev->base_addr & 3) != 0 || dev->base_addr < 0x300 
-		   || dev->base_addr > 0x3fc) {
+	if ((dev->base_addr & 3) != 0 || dev->base_addr < 0x300 ||
+	    dev->base_addr > 0x3fc)
+	{
 			printk(KERN_ERR "Invalid io value\n");
 			dev->base_addr = 0;
 		}
-		if ((ch->twin = comx_twin_check(dev)) != NULL) {
+	if ((ch->twin = comx_twin_check(dev)) != NULL)
+	{
 			struct comx_channel *twin_ch = ch->twin->priv;
 
 			twin_ch->twin = dev;
 		}
-	} else if (strcmp(entry->name, FILENAME_MEMADDR) == 0) {
+    }
+    else if (strcmp(entry->name, FILENAME_MEMADDR) == 0)
+    {
 		dev->mem_start = simple_strtoul(page, NULL, 0);
-		if (dev->mem_start <= 0xf000 && dev->mem_start >= 0xa000) {
+	if (dev->mem_start <= 0xf000 && dev->mem_start >= 0xa000)
+	{
 			dev->mem_start *= 16;
 		}
-		if ((dev->mem_start & 0xfff) != 0 || dev->mem_start < COMX_MEM_MIN
-		    || dev->mem_start + hw->memory_size > COMX_MEM_MAX) {
+	if ((dev->mem_start & 0xfff) != 0 || dev->mem_start < COMX_MEM_MIN ||
+	    dev->mem_start + hw->memory_size > COMX_MEM_MAX)
+	{
 			printk(KERN_ERR "Invalid memory page\n");
 			dev->mem_start = 0;
 		}
 		dev->mem_end = dev->mem_start + hw->memory_size;
-		if ((ch->twin = comx_twin_check(dev)) != NULL) {
+	if ((ch->twin = comx_twin_check(dev)) != NULL)
+	{
 			struct comx_channel *twin_ch = ch->twin->priv;
 
 			twin_ch->twin = dev;
 		}
-	} else if (strcmp(entry->name, FILENAME_CLOCK) == 0) {
-		if (strncmp("ext", page, 3) == 0) {
+    }
+    else if (strcmp(entry->name, FILENAME_CLOCK) == 0)
+    {
+	if (strncmp("ext", page, 3) == 0)
+	{
 			hw->clock = 0;
-		} else {
+	}
+	else
+	{
 			int kbps;
 
 			kbps = simple_strtoul(page, NULL, 0);
-			hw->clock = kbps ? COMX_CLOCK_CONST/kbps : 0;
+	    hw->clock = kbps ? COMX_CLOCK_CONST / kbps : 0;
 		}
 	}
-out:
+  out:
 	free_page((unsigned long)page);
 	return count;
 }
@@ -1165,45 +1297,64 @@
 	struct comx_privdata *hw = ch->HW_privdata;
 	int len = 0;
 
-
-	if (strcmp(file->name, FILENAME_IO) == 0) {
+    if (strcmp(file->name, FILENAME_IO) == 0)
+    {
 		len = sprintf(page, "0x%03x\n", (unsigned int)dev->base_addr);
-	} else if (strcmp(file->name, FILENAME_IRQ) == 0) {
+    }
+    else if (strcmp(file->name, FILENAME_IRQ) == 0)
+    {
 		len = sprintf(page, "0x%02x\n", dev->irq == 9 ? 2 : dev->irq);
-	} else if (strcmp(file->name, FILENAME_CHANNEL) == 0) {
+    }
+    else if (strcmp(file->name, FILENAME_CHANNEL) == 0)
+    {
 		len = sprintf(page, "%01d\n", hw->channel);
-	} else if (strcmp(file->name, FILENAME_MEMADDR) == 0) {
+    }
+    else if (strcmp(file->name, FILENAME_MEMADDR) == 0)
+    {
 		len = sprintf(page, "0x%05x\n", (unsigned int)dev->mem_start);
-	} else if (strcmp(file->name, FILENAME_TWIN) == 0) {
+    }
+    else if (strcmp(file->name, FILENAME_TWIN) == 0)
+    {
 		len = sprintf(page, "%s\n", ch->twin ? ch->twin->name : "none");
-	} else if (strcmp(file->name, FILENAME_CLOCK) == 0) {
-		if (hw->clock) {
-			len = sprintf(page, "%-8d\n", COMX_CLOCK_CONST/hw->clock);
-		} else {
+    }
+    else if (strcmp(file->name, FILENAME_CLOCK) == 0)
+    {
+	if (hw->clock)
+	{
+	    len = sprintf(page, "%-8d\n", COMX_CLOCK_CONST / hw->clock);
+	}
+	else
+	{
 			len = sprintf(page, "external\n");
 		}
-	} else if (strcmp(file->name, FILENAME_FIRMWARE) == 0) {
-		len = min_t(int, FILE_PAGESIZE,
+    }
+    else if (strcmp(file->name, FILENAME_FIRMWARE) == 0)
+    {
+	len =
+	    min_t(int, FILE_PAGESIZE,
 			  min_t(int, count, 
-			      hw->firmware ?
-			      (hw->firmware->len - off) : 0));
-		if (len < 0) {
+			hw->firmware ? (hw->firmware->len - off) : 0));
+	if (len < 0)
+	{
 			len = 0;
 		}
 		*start = hw->firmware ? (hw->firmware->data + off) : NULL;
-		if (off + len >= (hw->firmware ? hw->firmware->len : 0) || len == 0) {
+	if (off + len >= (hw->firmware ? hw->firmware->len : 0) || len == 0)
+	{
 			*eof = 1;
 		}
 		return len;
 	}	
 
-	if (off >= len) {
+    if (off >= len)
+    {
 		*eof = 1;
 		return 0;
 	}
 
 	*start = page + off;
-	if (count >= len - off) {
+    if (count >= len - off)
+    {
 		*eof = 1;
 	}
 	return min_t(int, count, len - off);
@@ -1216,32 +1367,40 @@
 	struct comx_privdata *hw;
 	struct proc_dir_entry *new_file;
 
-	if ((ch->HW_privdata = kmalloc(sizeof(struct comx_privdata), 
-	    GFP_KERNEL)) == NULL) {
+    if ((ch->HW_privdata =
+	 kmalloc(sizeof(struct comx_privdata), GFP_KERNEL)) == NULL)
+    {
 	    	return -ENOMEM;
 	}
 	memset(hw = ch->HW_privdata, 0, sizeof(struct comx_privdata));
 
-	if (ch->hardware == &comx_hw || ch->hardware == &cmx_hw) {
+    if (ch->hardware == &comx_hw || ch->hardware == &cmx_hw)
+    {
 		hw->memory_size = COMX_MEMORY_SIZE;
 		hw->io_extent = COMX_IO_EXTENT;
 		dev->base_addr = COMX_DEFAULT_IO;
 		dev->irq = COMX_DEFAULT_IRQ;
 		dev->mem_start = COMX_DEFAULT_MEMADDR;
 		dev->mem_end = COMX_DEFAULT_MEMADDR + COMX_MEMORY_SIZE;
-	} else if (ch->hardware == &hicomx_hw) {
+    }
+    else if (ch->hardware == &hicomx_hw)
+    {
 		hw->memory_size = HICOMX_MEMORY_SIZE;
 		hw->io_extent = HICOMX_IO_EXTENT;
 		dev->base_addr = HICOMX_DEFAULT_IO;
 		dev->irq = HICOMX_DEFAULT_IRQ;
 		dev->mem_start = HICOMX_DEFAULT_MEMADDR;
 		dev->mem_end = HICOMX_DEFAULT_MEMADDR + HICOMX_MEMORY_SIZE;
-	} else {
-		printk(KERN_ERR "SERIOUS INTERNAL ERROR in %s, line %d\n", __FILE__, __LINE__);
+    }
+    else
+    {
+	printk(KERN_ERR "SERIOUS INTERNAL ERROR in %s, line %d\n", __FILE__,
+	       __LINE__);
 	}
 
-	if ((new_file = create_proc_entry(FILENAME_IO, S_IFREG | 0644, ch->procdir))
-	    == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_IO, S_IFREG | 0644, ch->procdir)) == NULL)
+    {
 	    goto cleanup_HW_privdata;
 	}
 	new_file->data = (void *)new_file;
@@ -1250,8 +1409,9 @@
 	new_file->size = 6;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_IRQ, S_IFREG | 0644, ch->procdir))
-	    == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_IRQ, S_IFREG | 0644, ch->procdir)) == NULL)
+    {
 	    goto cleanup_filename_io;
 	}
 	new_file->data = (void *)new_file;
@@ -1260,8 +1420,10 @@
 	new_file->size = 5;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_CHANNEL, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_CHANNEL, S_IFREG | 0644,
+			   ch->procdir)) == NULL)
+    {
 	    goto cleanup_filename_irq;
 	}
 	new_file->data = (void *)new_file;
@@ -1270,9 +1432,12 @@
 	new_file->size = 2;		// Ezt tudjuk
 	new_file->nlink = 1;
 
-	if (ch->hardware == &hicomx_hw || ch->hardware == &cmx_hw) {
-		if ((new_file = create_proc_entry(FILENAME_CLOCK, S_IFREG | 0644, 
-		   ch->procdir)) == NULL) {
+    if (ch->hardware == &hicomx_hw || ch->hardware == &cmx_hw)
+    {
+	if ((new_file =
+	     create_proc_entry(FILENAME_CLOCK, S_IFREG | 0644,
+			       ch->procdir)) == NULL)
+	{
 		    goto cleanup_filename_channel;
 		}
 		new_file->data = (void *)new_file;
@@ -1282,8 +1447,10 @@
 		new_file->nlink = 1;
 	}
 
-	if ((new_file = create_proc_entry(FILENAME_MEMADDR, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_MEMADDR, S_IFREG | 0644,
+			   ch->procdir)) == NULL)
+    {
 		    goto cleanup_filename_clock;
 	}
 	new_file->data = (void *)new_file;
@@ -1292,8 +1459,9 @@
 	new_file->size = 8;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_TWIN, S_IFREG | 0444, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_TWIN, S_IFREG | 0444, ch->procdir)) == NULL)
+    {
 		    goto cleanup_filename_memaddr;
 	}
 	new_file->data = (void *)new_file;
@@ -1301,8 +1469,10 @@
 	new_file->write_proc = NULL;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_FIRMWARE, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_FIRMWARE, S_IFREG | 0644,
+			   ch->procdir)) == NULL)
+    {
 		    goto cleanup_filename_twin;
 	}
 	new_file->data = (void *)new_file;
@@ -1310,22 +1480,30 @@
 	new_file->write_proc = &comxhw_write_proc;
 	new_file->nlink = 1;
 
-	if (ch->hardware == &comx_hw) {
+    if (ch->hardware == &comx_hw)
+    {
 		ch->HW_board_on = COMX_board_on;
 		ch->HW_board_off = COMX_board_off;
 		ch->HW_load_board = COMX_load_board;
-	} else if (ch->hardware == &cmx_hw) {
+    }
+    else if (ch->hardware == &cmx_hw)
+    {
 		ch->HW_board_on = COMX_board_on;
 		ch->HW_board_off = COMX_board_off;
 		ch->HW_load_board = CMX_load_board;
 		ch->HW_set_clock = COMX_set_clock;
-	} else if (ch->hardware == &hicomx_hw) {
+    }
+    else if (ch->hardware == &hicomx_hw)
+    {
 		ch->HW_board_on = HICOMX_board_on;
 		ch->HW_board_off = HICOMX_board_off;
 		ch->HW_load_board = HICOMX_load_board;
 		ch->HW_set_clock = COMX_set_clock;
-	} else {
-		printk(KERN_ERR "SERIOUS INTERNAL ERROR in %s, line %d\n", __FILE__, __LINE__);
+    }
+    else
+    {
+	printk(KERN_ERR "SERIOUS INTERNAL ERROR in %s, line %d\n", __FILE__,
+	       __LINE__);
 	}
 
 	ch->HW_access_board = COMX_access_board;
@@ -1336,7 +1514,8 @@
 	ch->HW_send_packet = COMX_send_packet;
 	ch->HW_statistics = COMX_statistics;
 
-	if ((ch->twin = comx_twin_check(dev)) != NULL) {
+    if ((ch->twin = comx_twin_check(dev)) != NULL)
+    {
 		struct comx_channel *twin_ch = ch->twin->priv;
 
 		twin_ch->twin = dev;
@@ -1345,20 +1524,20 @@
 	MOD_INC_USE_COUNT;
 	return 0;
 
-cleanup_filename_twin:
+  cleanup_filename_twin:
 	remove_proc_entry(FILENAME_TWIN, ch->procdir);
-cleanup_filename_memaddr:
+  cleanup_filename_memaddr:
 	remove_proc_entry(FILENAME_MEMADDR, ch->procdir);
-cleanup_filename_clock:
+  cleanup_filename_clock:
 	if (ch->hardware == &hicomx_hw || ch->hardware == &cmx_hw)
 		remove_proc_entry(FILENAME_CLOCK, ch->procdir);
-cleanup_filename_channel:
+  cleanup_filename_channel:
 	remove_proc_entry(FILENAME_CHANNEL, ch->procdir);
-cleanup_filename_irq:
+  cleanup_filename_irq:
 	remove_proc_entry(FILENAME_IRQ, ch->procdir);
-cleanup_filename_io:
+  cleanup_filename_io:
 	remove_proc_entry(FILENAME_IO, ch->procdir);
-cleanup_HW_privdata:
+  cleanup_HW_privdata:
 	kfree(ch->HW_privdata);
 	return -EIO;
 }
@@ -1369,10 +1548,14 @@
 	struct comx_channel *ch = dev->priv;
 	struct comx_privdata *hw = ch->HW_privdata;
 
-	if (hw->firmware) {
-		if (hw->firmware->data) kfree(hw->firmware->data);
+    if (hw->firmware)
+    {
+	if (hw->firmware->data)
+	    kfree(hw->firmware->data);
 		kfree(hw->firmware);
-	} if (ch->twin) {
+    }
+    if (ch->twin)
+    {
 		struct comx_channel *twin_ch = ch->twin->priv;
 
 		twin_ch->twin = NULL;
@@ -1385,7 +1568,8 @@
 	remove_proc_entry(FILENAME_MEMADDR, ch->procdir);
 	remove_proc_entry(FILENAME_FIRMWARE, ch->procdir);
 	remove_proc_entry(FILENAME_TWIN, ch->procdir);
-	if (ch->hardware == &hicomx_hw || ch->hardware == &cmx_hw) {
+    if (ch->hardware == &hicomx_hw || ch->hardware == &cmx_hw)
+    {
 		remove_proc_entry(FILENAME_CLOCK, ch->procdir);
 	}
 
@@ -1399,7 +1583,8 @@
 	return 0;
 }
 
-static struct comx_hardware comx_hw = {
+static struct comx_hardware comx_hw =
+{
 	"comx",
 	VERSION,
 	COMX_init,
@@ -1408,7 +1593,8 @@
 	NULL
 };
 
-static struct comx_hardware cmx_hw = {
+static struct comx_hardware cmx_hw =
+{
 	"cmx",
 	VERSION,
 	COMX_init,
@@ -1417,7 +1603,8 @@
 	NULL
 };
 
-static struct comx_hardware hicomx_hw = {
+static struct comx_hardware hicomx_hw =
+{
 	"hicomx",
 	VERSION,
 	COMX_init,
diff -ruNP linux-2.4.24/drivers/net/wan/comx-hw-locomx.c linux-2.4.24-p/drivers/net/wan/comx-hw-locomx.c
--- linux-2.4.24/drivers/net/wan/comx-hw-locomx.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.24-p/drivers/net/wan/comx-hw-locomx.c	Tue Jan  6 19:59:48 2004
@@ -63,13 +63,17 @@
 #define LOCOMX_DEFAULT_IO 0x368
 #define LOCOMX_DEFAULT_IRQ 7
 
-u8 z8530_locomx[] = {
+u8 z8530_locomx[] =
+{
 	11,     TCRTxCP,
 	14,     DTRREQ,
 	255
 };
 
-struct locomx_data {
+static spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
+
+struct locomx_data
+{
 	int	io_extent;
 	struct	z8530_dev board;
 	struct timer_list status_timer;
@@ -83,16 +87,15 @@
 	return (!hw->board.chanA.tx_next_skb);
 }
 
-
 static void locomx_rx(struct z8530_channel *c, struct sk_buff *skb)
 {
-	struct net_device *dev=c->netdevice;
-	struct comx_channel *ch=dev->priv;
+    struct net_device *dev = c->netdevice;
+    struct comx_channel *ch = dev->priv;
 	
-	if (ch->debug_flags & DEBUG_HW_RX) {
+    if (ch->debug_flags & DEBUG_HW_RX)
 		comx_debug_skb(dev, skb, "locomx_rx receiving");
-	}
-	ch->LINE_rx(dev,skb);
+
+    ch->LINE_rx(dev, skb);
 }
 
 static int LOCOMX_send_packet(struct net_device *dev, struct sk_buff *skb) 
@@ -100,48 +103,37 @@
 	struct comx_channel *ch = (struct comx_channel *)dev->priv;
 	struct locomx_data *hw = ch->HW_privdata;
 
-	if (ch->debug_flags & DEBUG_HW_TX) {
+    if (ch->debug_flags & DEBUG_HW_TX)
 		comx_debug_bytes(dev, skb->data, skb->len, "LOCOMX_send_packet");
-	}
 
-	if (!(ch->line_status & LINE_UP)) {
+    if (!(ch->line_status & LINE_UP))
 		return FRAME_DROPPED;
-	}
 
-	if(z8530_queue_xmit(&hw->board.chanA,skb)) {
-		printk(KERN_WARNING "%s: FRAME_DROPPED\n",dev->name);
+    if (z8530_queue_xmit(&hw->board.chanA, skb))
+    {
+	printk(KERN_WARNING "%s: FRAME_DROPPED\n", dev->name);
 		return FRAME_DROPPED;
 	}
 
-	if (ch->debug_flags & DEBUG_HW_TX) {
+    if (ch->debug_flags & DEBUG_HW_TX)
 		comx_debug(dev, "%s: LOCOMX_send_packet was successful\n\n", dev->name);
-	}
 
-	if(!hw->board.chanA.tx_next_skb) {
-		return FRAME_QUEUED;
-	} else {
-		return FRAME_ACCEPTED;
-	}
+    return hw->board.chanA.tx_next_skb ? FRAME_ACCEPTED : FRAME_QUEUED;
 }
 
 static void locomx_status_timerfun(unsigned long d)
 {
-	struct net_device *dev=(struct net_device *)d;
-	struct comx_channel *ch=dev->priv;
-	struct locomx_data *hw=ch->HW_privdata;
+    struct net_device *dev = (struct net_device *)d;
+    struct comx_channel *ch = dev->priv;
+    struct locomx_data *hw = ch->HW_privdata;
 
-	if(!(ch->line_status & LINE_UP) &&
-	    (hw->board.chanA.status & CTS)) {
+    if (!(ch->line_status & LINE_UP) && (hw->board.chanA.status & CTS))
 		ch->LINE_status(dev, ch->line_status | LINE_UP);
-	}
-	if((ch->line_status & LINE_UP) &&
-	    !(hw->board.chanA.status & CTS)) {
+    if ((ch->line_status & LINE_UP) && !(hw->board.chanA.status & CTS))
 		ch->LINE_status(dev, ch->line_status & ~LINE_UP);
-	}
-	mod_timer(&hw->status_timer,jiffies + ch->lineup_delay * HZ);
+    mod_timer(&hw->status_timer, jiffies + ch->lineup_delay * HZ);
 }
 
-
 static int LOCOMX_open(struct net_device *dev)
 {
 	struct comx_channel *ch = dev->priv;
@@ -150,58 +142,57 @@
 	unsigned long flags;
 	int ret;
 
-	if (!dev->base_addr || !dev->irq) {
+    if (!dev->base_addr || !dev->irq)
 		return -ENODEV;
-	}
 
-	if (!request_region(dev->base_addr, hw->io_extent, dev->name)) {
+    if (!request_region(dev->base_addr, hw->io_extent, dev->name))
 		return -EAGAIN;
-	}
 
-	hw->board.chanA.ctrlio=dev->base_addr + 5;
-	hw->board.chanA.dataio=dev->base_addr + 7;
+    hw->board.chanA.ctrlio = dev->base_addr + 5;
+    hw->board.chanA.dataio = dev->base_addr + 7;
 	
-	hw->board.irq=dev->irq;
-	hw->board.chanA.netdevice=dev;
-	hw->board.chanA.dev=&hw->board;
-	hw->board.name=dev->name;
-	hw->board.chanA.txdma=TX_DMA;
-	hw->board.chanA.rxdma=RX_DMA;
-	hw->board.chanA.irqs=&z8530_nop;
-	hw->board.chanB.irqs=&z8530_nop;
-
-	if(request_irq(dev->irq, z8530_interrupt, SA_INTERRUPT, 
-	    dev->name, &hw->board)) {
-		printk(KERN_ERR "%s: unable to obtain irq %d\n", dev->name, 
-			dev->irq);
-		ret=-EAGAIN;
+    hw->board.irq = dev->irq;
+    hw->board.chanA.netdevice = dev;
+    hw->board.chanA.dev = &hw->board;
+    hw->board.name = dev->name;
+    hw->board.chanA.txdma = TX_DMA;
+    hw->board.chanA.rxdma = RX_DMA;
+    hw->board.chanA.irqs = &z8530_nop;
+    hw->board.chanB.irqs = &z8530_nop;
+
+    if (request_irq
+	(dev->irq, z8530_interrupt, SA_INTERRUPT, dev->name, &hw->board))
+    {
+	printk(KERN_ERR "%s: unable to obtain irq %d\n", dev->name, dev->irq);
+	ret = -EAGAIN;
 		goto irq_fail;
 	}
-	if(request_dma(TX_DMA,"LoCOMX (TX)")) {
+    if (request_dma(TX_DMA, "LoCOMX (TX)"))
+    {
 		printk(KERN_ERR "%s: unable to obtain TX DMA (DMA channel %d)\n", 
 			dev->name, TX_DMA);
-		ret=-EAGAIN;
+	ret = -EAGAIN;
 		goto dma1_fail;
 	}
 
-	if(request_dma(RX_DMA,"LoCOMX (RX)")) {
+    if (request_dma(RX_DMA, "LoCOMX (RX)"))
+    {
 		printk(KERN_ERR "%s: unable to obtain RX DMA (DMA channel %d)\n", 
 			dev->name, RX_DMA);
-		ret=-EAGAIN;
+	ret = -EAGAIN;
 		goto dma2_fail;
 	}
 	
-	save_flags(flags); 
-	cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
-	if(z8530_init(&hw->board)!=0)
+    if (z8530_init(&hw->board))
 	{
-		printk(KERN_ERR "%s: Z8530 device not found.\n",dev->name);
-		ret=-ENODEV;
+	printk(KERN_ERR "%s: Z8530 device not found.\n", dev->name);
+	ret = -ENODEV;
 		goto z8530_fail;
 	}
 
-	hw->board.chanA.dcdcheck=CTS;
+    hw->board.chanA.dcdcheck = CTS;
 
 	z8530_channel_load(&hw->board.chanA, z8530_hdlc_kilostream_85230);
 	z8530_channel_load(&hw->board.chanA, z8530_locomx);
@@ -209,47 +200,43 @@
 
 	z8530_describe(&hw->board, "I/O", dev->base_addr);
 
-	if((ret=z8530_sync_dma_open(dev, &hw->board.chanA))!=0) {
+    if ((ret = z8530_sync_dma_open(dev, &hw->board.chanA)))
 		goto z8530_fail;
-	}
 
-	restore_flags(flags);
+    spin_unlock_irqrestore(&mister_lock, flags);
 
-
-	hw->board.active=1;
-	hw->board.chanA.rx_function=locomx_rx;
+    hw->board.active = 1;
+    hw->board.chanA.rx_function = locomx_rx;
 
 	ch->init_status |= HW_OPEN;
-	if (hw->board.chanA.status & DCD) {
+    if (hw->board.chanA.status & DCD)
 		ch->line_status |= LINE_UP;
-	} else {
+    else
 		ch->line_status &= ~LINE_UP;
-	}
 
 	comx_status(dev, ch->line_status);
 
 	init_timer(&hw->status_timer);
-	hw->status_timer.function=locomx_status_timerfun;
-	hw->status_timer.data=(unsigned long)dev;
-	hw->status_timer.expires=jiffies + ch->lineup_delay * HZ;
+    hw->status_timer.function = locomx_status_timerfun;
+    hw->status_timer.data = (unsigned long)dev;
+    hw->status_timer.expires = jiffies + ch->lineup_delay * HZ;
 	add_timer(&hw->status_timer);
 
-	for (; procfile ; procfile = procfile->next) {
-		if (strcmp(procfile->name, FILENAME_IO) == 0 ||
-		     strcmp(procfile->name, FILENAME_IRQ) == 0) {
+    for (; procfile; procfile = procfile->next)
+	if (!strcmp(procfile->name, FILENAME_IO) ||
+	    !strcmp(procfile->name, FILENAME_IRQ))
 			procfile->mode = S_IFREG |  0444;
-		}
-	}
+
 	return 0;
 
-z8530_fail:
-	restore_flags(flags);
+  z8530_fail:
+    spin_unlock_irqrestore(&mister_lock, flags);
 	free_dma(RX_DMA);
-dma2_fail:
+  dma2_fail:
 	free_dma(TX_DMA);
-dma1_fail:
+  dma1_fail:
 	free_irq(dev->irq, &hw->board);
-irq_fail:
+  irq_fail:
 	release_region(dev->base_addr, hw->io_extent);
 	return ret;
 }
@@ -260,7 +247,7 @@
 	struct locomx_data *hw = ch->HW_privdata;
 	struct proc_dir_entry *procfile = ch->procdir->subdir;
 
-	hw->board.chanA.rx_function=z8530_null_rx;
+    hw->board.chanA.rx_function = z8530_null_rx;
 	netif_stop_queue(dev);
 	z8530_sync_dma_close(dev, &hw->board.chanA);
 
@@ -269,21 +256,22 @@
 	del_timer(&hw->status_timer);
 	free_dma(RX_DMA);
 	free_dma(TX_DMA);
-	free_irq(dev->irq,&hw->board);
-	release_region(dev->base_addr,8);
+    free_irq(dev->irq, &hw->board);
+    release_region(dev->base_addr, 8);
 
-	for (; procfile ; procfile = procfile->next) {
-		if (strcmp(procfile->name, FILENAME_IO) == 0 ||
-		    strcmp(procfile->name, FILENAME_IRQ) == 0) {
+    while (procfile)
+    {
+	if (!strcmp(procfile->name, FILENAME_IO) ||
+	    !strcmp(procfile->name, FILENAME_IRQ))
 			procfile->mode = S_IFREG |  0644;
-		}
+	procfile = procfile->next;
 	}
 
 	ch->init_status &= ~HW_OPEN;
 	return 0;
 }
 
-static int LOCOMX_statistics(struct net_device *dev,char *page)
+static int LOCOMX_statistics(struct net_device *dev, char *page)
 {
 	int len = 0;
 
@@ -292,9 +280,10 @@
 	return len;
 }
 
-static int LOCOMX_dump(struct net_device *dev) {
+static int LOCOMX_dump(struct net_device *dev)
+{
 	printk(KERN_INFO "LOCOMX_dump called\n");
-	return(-1);
+    return -1;
 }
 
 static int locomx_read_proc(char *page, char **start, off_t off, int count,
@@ -304,25 +293,26 @@
 	struct net_device *dev = file->parent->data;
 	int len = 0;
 
-	if (strcmp(file->name, FILENAME_IO) == 0) {
+    if (!strcmp(file->name, FILENAME_IO))
 		len = sprintf(page, "0x%x\n", (unsigned int)dev->base_addr);
-	} else if (strcmp(file->name, FILENAME_IRQ) == 0) {
+    else if (!strcmp(file->name, FILENAME_IRQ))
 		len = sprintf(page, "%d\n", (unsigned int)dev->irq);
-	} else {
+    else
+    {
 		printk(KERN_ERR "hw_read_proc: internal error, filename %s\n", 
 			file->name);
 		return -EBADF;
 	}
 
-	if (off >= len) {
+    if (off >= len)
+    {
 		*eof = 1;
 		return 0;
 	}
 
 	*start = page + off;
-	if (count >= len - off) {
-		*eof = 1;
-	}
+    if (count >= len - off) *eof = 1;
+
 	return min_t(int, count, len - off);
 }
 
@@ -334,31 +324,34 @@
 	int val;
 	char *page;
 
-	if (!(page = (char *)__get_free_page(GFP_KERNEL))) {
+    if (!(page = (char *)__get_free_page(GFP_KERNEL)))
 		return -ENOMEM;
-	}
 
-	copy_from_user(page, buffer, count = min_t(unsigned long, count, PAGE_SIZE));
-	if (*(page + count - 1) == '\n') {
+    copy_from_user(page, buffer, count =
+		   min_t(unsigned long, count, PAGE_SIZE));
+
+    if (*(page + count - 1) == '\n')
 		*(page + count - 1) = 0;
-	}
 
-	if (strcmp(entry->name, FILENAME_IO) == 0) {
+    if (!strcmp(entry->name, FILENAME_IO))
+    {
 		val = simple_strtoul(page, NULL, 0);
-		if (val != 0x360 && val != 0x368 && val != 0x370 && 
-		   val != 0x378) {
+	if (val != 0x360 && val != 0x368 && val != 0x370 && val != 0x378)
 			printk(KERN_ERR "LoCOMX: incorrect io address!\n");	
-		} else {
+	else
 			dev->base_addr = val;
 		}
-	} else if (strcmp(entry->name, FILENAME_IRQ) == 0) {
+    else if (!strcmp(entry->name, FILENAME_IRQ))
+    {
 		val = simple_strtoul(page, NULL, 0);
-		if (val != 3 && val != 4 && val != 5 && val != 6 && val != 7) {
+//      if (val != 3 && val != 4 && val != 5 && val != 6 && val != 7)
+	if (val < 3 || val > 7)
 			printk(KERN_ERR "LoCOMX: incorrect irq value!\n");
-		} else {
+	else
 			dev->irq = val;
 		}	
-	} else {
+    else
+    {
 		printk(KERN_ERR "locomx_write_proc: internal error, filename %s\n", 
 			entry->name);
 		free_page((unsigned long)page);
@@ -377,45 +370,45 @@
 	struct locomx_data *hw;
 	struct proc_dir_entry *new_file;
 
-	/* Alloc data for private structure */
-	if ((ch->HW_privdata = kmalloc(sizeof(struct locomx_data), 
-	   GFP_KERNEL)) == NULL) {
+    /*
+     * Alloc data for private structure 
+     */
+    if (!(ch->HW_privdata = kmalloc(sizeof(struct locomx_data), GFP_KERNEL)))
 	   	return -ENOMEM;
-	}
 
 	memset(hw = ch->HW_privdata, 0, sizeof(struct locomx_data));
 	hw->io_extent = LOCOMX_IO_EXTENT;
 
-	/* Register /proc files */
-	if ((new_file = create_proc_entry(FILENAME_IO, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    /*
+     * Register /proc files 
+     */
+    if (!(new_file =
+	 create_proc_entry(FILENAME_IO, S_IFREG | 0644, ch->procdir)))
 		goto cleanup_HW_privdata;
-	}
+
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &locomx_read_proc;
 	new_file->write_proc = &locomx_write_proc;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_IRQ, S_IFREG | 0644, 
-	    ch->procdir)) == NULL)  {
+    if (!(new_file =
+	 create_proc_entry(FILENAME_IRQ, S_IFREG | 0644, ch->procdir)))
 		goto cleanup_filename_io;
-	}
-	new_file->data = (void *)new_file;
-	new_file->read_proc = &locomx_read_proc;
-	new_file->write_proc = &locomx_write_proc;
-	new_file->nlink = 1;
 
-/* 	No clock yet */
-/*
-	if ((new_file = create_proc_entry(FILENAME_CLOCK, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
-		return -EIO;
-	}
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &locomx_read_proc;
 	new_file->write_proc = &locomx_write_proc;
 	new_file->nlink = 1;
-*/
+
+    /*
+     * No clock yet 
+     */
+    /*
+     * if ((new_file = create_proc_entry(FILENAME_CLOCK, S_IFREG | 0644,
+     * ch->procdir)) == NULL) { return -EIO; } new_file->data = (void
+     * *)new_file; new_file->read_proc = &locomx_read_proc;
+     * new_file->write_proc = &locomx_write_proc; new_file->nlink = 1; 
+     */
 
 	ch->HW_access_board = NULL;
 	ch->HW_release_board = NULL;
@@ -432,13 +425,14 @@
 	dev->base_addr = LOCOMX_DEFAULT_IO;
 	dev->irq = LOCOMX_DEFAULT_IRQ;
 	
-	
-	/* O.K. Count one more user on this module */
+    /*
+     * O.K. Count one more user on this module 
+     */
 	MOD_INC_USE_COUNT;
 	return 0;
-cleanup_filename_io:
+  cleanup_filename_io:
 	remove_proc_entry(FILENAME_IO, ch->procdir);
-cleanup_HW_privdata:
+  cleanup_HW_privdata:
 	kfree(ch->HW_privdata);
 	return -EIO;
 }
@@ -463,13 +457,14 @@
 
 	remove_proc_entry(FILENAME_IO, ch->procdir);
 	remove_proc_entry(FILENAME_IRQ, ch->procdir);
-//	remove_proc_entry(FILENAME_CLOCK, ch->procdir);
+    // remove_proc_entry(FILENAME_CLOCK, ch->procdir);
 
 	MOD_DEC_USE_COUNT;
 	return 0;
 }
 
-static struct comx_hardware locomx_hw = {
+static struct comx_hardware locomx_hw =
+{
 	"locomx",
 	VERSION,
 	LOCOMX_init, 
diff -ruNP linux-2.4.24/drivers/net/wan/comx-hw-mixcom.c linux-2.4.24-p/drivers/net/wan/comx-hw-mixcom.c
--- linux-2.4.24/drivers/net/wan/comx-hw-mixcom.c	Fri Jun 13 16:51:35 2003
+++ linux-2.4.24-p/drivers/net/wan/comx-hw-mixcom.c	Tue Jan  6 19:59:48 2004
@@ -57,7 +57,8 @@
 #include "hscx.h"
 
 MODULE_AUTHOR("Gergely Madarasz <gorgo@itc.hu>");
-MODULE_DESCRIPTION("Hardware-level driver for the serial port of the MixCom board");
+MODULE_DESCRIPTION
+    ("Hardware-level driver for the serial port of the MixCom board");
 MODULE_LICENSE("GPL");
 
 #define MIXCOM_DATA(d) ((struct mixcom_privdata *)(COMX_CHANNEL(d)-> \
@@ -69,12 +70,20 @@
 #define MIXCOM_DEV_BASE(port,channel) (port + MIXCOM_SERIAL_OFFSET + \
 	(1 - channel) * MIXCOM_CHANNEL_OFFSET)
 
+#define mixcom_kfree_skb(ptr) (in_irq()?dev_kfree_skb_irq(ptr):dev_kfree_skb(ptr))
+
 /* Values used to set the IRQ line */
-static unsigned char mixcom_set_irq[]={0xFF, 0xFF, 0xFF, 0x0, 0xFF, 0x2, 0x4, 0x6, 0xFF, 0xFF, 0x8, 0xA, 0xC, 0xFF, 0xE, 0xFF};
+static unsigned char mixcom_set_irq[] = {
+    0xFF, 0xFF, 0xFF, 0x0, 0xFF, 0x2, 0x4, 0x6,
+    0xFF, 0xFF, 0x8, 0xA, 0xC, 0xFF, 0xE, 0xFF
+};
 
-static unsigned char* hscx_versions[]={"A1", NULL, "A2", NULL, "A3", "2.1"};
+static unsigned char *hscx_versions[] = {
+    "A1", NULL, "A2", NULL, "A3", "2.1"
+};
 
-struct mixcom_privdata {
+struct mixcom_privdata
+{
 	u16	clock;
 	char	channel;
 	long	txbusy;
@@ -86,6 +95,8 @@
 	char	card_has_status;
 };
 
+static spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
+
 static inline void wr_hscx(struct net_device *dev, int reg, unsigned char val) 
 {
 	outb(val, dev->base_addr + reg);
@@ -102,16 +113,17 @@
 	unsigned char cec;
 	unsigned delay = 0;
 
-	while ((cec = (rd_hscx(dev, HSCX_STAR) & HSCX_CEC)) != 0 && 
-	    (jiffs + HZ > jiffies)) {
+    while ((cec = (rd_hscx(dev, HSCX_STAR) & HSCX_CEC)) != 0
+	   && (jiffs + HZ > jiffies))
+    {
 		udelay(1);
-		if (++delay > (100000 / HZ)) break;
+	if (++delay > (100000 / HZ))
+	    break;
 	}
-	if (cec) {
-		printk(KERN_WARNING "%s: CEC stuck, probably no clock!\n",dev->name);
-	} else {
+    if (cec)
+	printk(KERN_WARNING "%s: CEC stuck, probably no clock!\n", dev->name);
+    else
 		wr_hscx(dev, HSCX_CMDR, cmd);
-	}
 }
 
 static inline void hscx_fill_fifo(struct net_device *dev)
@@ -120,15 +132,17 @@
 	struct mixcom_privdata *hw = ch->HW_privdata;
 	register word to_send = hw->sending->len - hw->tx_ptr;
 
-
-	outsb(dev->base_addr + HSCX_FIFO,
-        	&(hw->sending->data[hw->tx_ptr]), min_t(unsigned int, to_send, 32));
-	if (to_send <= 32) {
+    outsb(dev->base_addr + HSCX_FIFO, &(hw->sending->data[hw->tx_ptr]),
+	  min_t(unsigned int, to_send, 32));
+    if (to_send <= 32)
+    {
         	hscx_cmd(dev, HSCX_XTF | HSCX_XME);
-	        kfree_skb(hw->sending);
+	mixcom_kfree_skb(hw->sending);
         	hw->sending = NULL; 
         	hw->tx_ptr = 0;
-        } else {
+    }
+    else
+    {
 	        hscx_cmd(dev, HSCX_XTF);
         	hw->tx_ptr += 32;
         }
@@ -139,23 +153,28 @@
 	struct comx_channel *ch = dev->priv;
 	struct mixcom_privdata *hw = ch->HW_privdata;
 
-	if (hw->recving == NULL) {
-        	if (!(hw->recving = dev_alloc_skb(HSCX_MTU + 16))) {
+    if (hw->recving == NULL)
+    {
+	if (!(hw->recving = dev_alloc_skb(HSCX_MTU + 16)))
+	{
 	                ch->stats.rx_dropped++;
         	        hscx_cmd(dev, HSCX_RHR);
-                } else {
+	}
+	else
+	{
 	                skb_reserve(hw->recving, 16);
         	        skb_put(hw->recving, HSCX_MTU);
                 }
 	        hw->rx_ptr = 0;
         }
-	if (cnt > 32 || !cnt || hw->recving == NULL) {
-        	printk(KERN_ERR "hscx_empty_fifo: cnt is %d, hw->recving %p\n",
-		        cnt, (void *)hw->recving);
+    if (cnt > 32 || !cnt || hw->recving == NULL)
+    {
+	printk(KERN_ERR "hscx_empty_fifo: cnt is %d, hw->recving %p\n", cnt,
+	       (void *)hw->recving);
 	        return;
         }
         
-	insb(dev->base_addr + HSCX_FIFO, &(hw->recving->data[hw->rx_ptr]),cnt);
+    insb(dev->base_addr + HSCX_FIFO, &(hw->recving->data[hw->rx_ptr]), cnt);
 	hw->rx_ptr += cnt;
 	hscx_cmd(dev, HSCX_RMC);
 }
@@ -172,51 +191,44 @@
 static int mixcom_probe(struct net_device *dev)
 {
 	unsigned long flags;
-	int id, vstr, ret=0;
+    int id, vstr, ret = 0;
 
-	save_flags(flags); cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
-	id=inb_p(MIXCOM_BOARD_BASE(dev) + MIXCOM_ID_OFFSET) & 0x7f;
+    id = inb_p(MIXCOM_BOARD_BASE(dev) + MIXCOM_ID_OFFSET) & 0x7f;
 
- 	if (id != MIXCOM_ID ) {
-		ret=-ENODEV;
-		printk(KERN_WARNING "%s: no MixCOM board found at 0x%04lx\n",dev->name, dev->base_addr);
+    if (id != MIXCOM_ID)
+    {
+	ret = -ENODEV;
+	printk(KERN_WARNING "%s: no MixCOM board found at 0x%04lx\n",
+	       dev->name, dev->base_addr);
 		goto out;
 	}
 
-	vstr=inb_p(dev->base_addr + HSCX_VSTR) & 0x0f;
-	if(vstr>=sizeof(hscx_versions)/sizeof(char*) || 
-	    hscx_versions[vstr]==NULL) {
-		printk(KERN_WARNING "%s: board found but no HSCX chip detected at 0x%4lx (vstr = 0x%1x)\n",dev->name,dev->base_addr,vstr);
+    vstr = inb_p(dev->base_addr + HSCX_VSTR) & 0x0f;
+    if (vstr >= sizeof(hscx_versions) / sizeof(char *)
+	|| hscx_versions[vstr] == NULL)
+    {
+	printk(KERN_WARNING
+	       "%s: board found but no HSCX chip detected at 0x%4lx (vstr = 0x%1x)\n",
+	       dev->name, dev->base_addr, vstr);
 		ret = -ENODEV;
-	} else {
-		printk(KERN_INFO "%s: HSCX chip version %s\n",dev->name,hscx_versions[vstr]);
+    }
+    else
+    {
+	printk(KERN_INFO "%s: HSCX chip version %s\n", dev->name,
+	       hscx_versions[vstr]);
 		ret = 0;
 	}
 
-out:
-
-	restore_flags(flags);
+  out:
+    spin_unlock_irqrestore(&mister_lock, flags);
 	return ret;
 }
 
-#if 0
-static void MIXCOM_set_clock(struct net_device *dev)
-{
-	struct comx_channel *ch = dev->priv;
-	struct mixcom_privdata *hw = ch->HW_privdata;
-
-	if (hw->clock) {
-		;
-	} else {
-		;
-	}
-}
-#endif
-
 static void mixcom_board_on(struct net_device *dev)
 {
-	outb_p(MIXCOM_OFF , MIXCOM_BOARD_BASE(dev) + MIXCOM_IT_OFFSET);
+    outb_p(MIXCOM_OFF, MIXCOM_BOARD_BASE(dev) + MIXCOM_IT_OFFSET);
 	udelay(1000);
 	outb_p(mixcom_set_irq[dev->irq] | MIXCOM_ON, 
 		MIXCOM_BOARD_BASE(dev) + MIXCOM_IT_OFFSET);
@@ -225,7 +237,7 @@
 
 static void mixcom_board_off(struct net_device *dev)
 {
-	outb_p(MIXCOM_OFF , MIXCOM_BOARD_BASE(dev) + MIXCOM_IT_OFFSET);
+    outb_p(MIXCOM_OFF, MIXCOM_BOARD_BASE(dev) + MIXCOM_IT_OFFSET);
 	udelay(1000);
 }
 
@@ -240,12 +252,13 @@
 
 	wr_hscx(dev, HSCX_CCR1, HSCX_PU | HSCX_ODS | HSCX_ITF); // power up, push-pull
 	wr_hscx(dev, HSCX_CCR2, HSCX_CIE /* | HSCX_RIE */ );
-	wr_hscx(dev, HSCX_MODE, HSCX_TRANS | HSCX_ADM8 | HSCX_RAC | HSCX_RTS );
+    wr_hscx(dev, HSCX_MODE, HSCX_TRANS | HSCX_ADM8 | HSCX_RAC | HSCX_RTS);
 	wr_hscx(dev, HSCX_RLCR, HSCX_RC | 47); // 1504 bytes
-	wr_hscx(dev, HSCX_MASK, HSCX_RSC | HSCX_TIN );
+    wr_hscx(dev, HSCX_MASK, HSCX_RSC | HSCX_TIN);
 	hscx_cmd(dev, HSCX_XRES | HSCX_RHR);
 
-	if (ch->HW_set_clock) ch->HW_set_clock(dev);
+    if (ch->HW_set_clock)
+	ch->HW_set_clock(dev);
 
 }
 
@@ -255,24 +268,26 @@
 	struct mixcom_privdata *hw = ch->HW_privdata;
 	unsigned long flags;
 
-	if (ch->debug_flags & DEBUG_HW_TX) {
+    if (ch->debug_flags & DEBUG_HW_TX)
 		comx_debug_bytes(dev, skb->data, skb->len, "MIXCOM_send_packet");
-	}
 
-	if (!(ch->line_status & LINE_UP)) {
+    if (!(ch->line_status & LINE_UP))
 		return FRAME_DROPPED;
-	}
 
-	if (skb->len > HSCX_MTU) {
+    if (skb->len > HSCX_MTU)
+    {
 		ch->stats.tx_errors++;	
 		return FRAME_ERROR;
 	}
 
-	save_flags(flags); cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
-	if (test_and_set_bit(0, &hw->txbusy)) {
-		printk(KERN_ERR "%s: transmitter called while busy... dropping frame (length %d)\n", dev->name, skb->len);
-		restore_flags(flags);
+    if (test_and_set_bit(0, &hw->txbusy))
+    {
+	printk(KERN_ERR
+	       "%s: transmitter called while busy... dropping frame (length %d)\n",
+	       dev->name, skb->len);
+	spin_unlock_irqrestore(&mister_lock, flags);
 		return FRAME_DROPPED;
 	}
 
@@ -282,128 +297,124 @@
 	hw->txbusy = 1;
 //	atomic_inc(&skb->users);	// save it
 	hscx_fill_fifo(dev);
-	restore_flags(flags);
+    spin_unlock_irqrestore(&mister_lock, flags);
 
 	ch->stats.tx_packets++;
 	ch->stats.tx_bytes += skb->len; 
 
-	if (ch->debug_flags & DEBUG_HW_TX) {
+    if (ch->debug_flags & DEBUG_HW_TX)
 		comx_debug(dev, "MIXCOM_send_packet was successful\n\n");
-	}
 
 	return FRAME_ACCEPTED;
 }
 
 static inline void mixcom_receive_frame(struct net_device *dev) 
 {
-	struct comx_channel *ch=dev->priv;
-	struct mixcom_privdata *hw=ch->HW_privdata;
+    struct comx_channel *ch = dev->priv;
+    struct mixcom_privdata *hw = ch->HW_privdata;
 	register byte rsta;
 	register word length;
 
-	rsta = rd_hscx(dev, HSCX_RSTA) & (HSCX_VFR | HSCX_RDO | 
-		HSCX_CRC | HSCX_RAB);
-	length = ((rd_hscx(dev, HSCX_RBCH) & 0x0f) << 8) | 
-		rd_hscx(dev, HSCX_RBCL);
+    rsta =
+	rd_hscx(dev, HSCX_RSTA) & (HSCX_VFR | HSCX_RDO | HSCX_CRC | HSCX_RAB);
+    length =
+	((rd_hscx(dev, HSCX_RBCH) & 0x0f) << 8) | rd_hscx(dev, HSCX_RBCL);
 
-	if ( length > hw->rx_ptr ) {
+    if (length > hw->rx_ptr)
 		hscx_empty_fifo(dev, length - hw->rx_ptr);
-	}
 	
-	if (!(rsta & HSCX_VFR)) {
+    if (!(rsta & HSCX_VFR))
 		ch->stats.rx_length_errors++;
-	}
-	if (rsta & HSCX_RDO) {
+    if (rsta & HSCX_RDO)
 		ch->stats.rx_over_errors++;
-	}
-	if (!(rsta & HSCX_CRC)) {
+    if (!(rsta & HSCX_CRC))
 		ch->stats.rx_crc_errors++;
-	}
-	if (rsta & HSCX_RAB) {
+    if (rsta & HSCX_RAB)
 		ch->stats.rx_frame_errors++;
-	}
 	ch->stats.rx_packets++; 
 	ch->stats.rx_bytes += length;
 
-	if (rsta == (HSCX_VFR | HSCX_CRC) && hw->recving) {
+    if (rsta == (HSCX_VFR | HSCX_CRC) && hw->recving)
+    {
 		skb_trim(hw->recving, hw->rx_ptr - 1);
-		if (ch->debug_flags & DEBUG_HW_RX) {
-			comx_debug_skb(dev, hw->recving,
-				"MIXCOM_interrupt receiving");
-		}
+	if (ch->debug_flags & DEBUG_HW_RX)
+	    comx_debug_skb(dev, hw->recving, "MIXCOM_interrupt receiving");
 		hw->recving->dev = dev;
-		if (ch->LINE_rx) {
+	if (ch->LINE_rx)
 			ch->LINE_rx(dev, hw->recving);
 		}
-	}
-	else if(hw->recving) {
-		kfree_skb(hw->recving);
-	}
+    else if (hw->recving)
+	mixcom_kfree_skb(hw->recving);
 	hw->recving = NULL; 
 	hw->rx_ptr = 0;
 }
 
-
 static inline void mixcom_extended_interrupt(struct net_device *dev) 
 {
-	struct comx_channel *ch=dev->priv;
-	struct mixcom_privdata *hw=ch->HW_privdata;
+    struct comx_channel *ch = dev->priv;
+    struct mixcom_privdata *hw = ch->HW_privdata;
 	register byte exir;
 
-	exir = rd_hscx(dev, HSCX_EXIR) & (HSCX_XDU | HSCX_RFO | HSCX_CSC );
+    exir = rd_hscx(dev, HSCX_EXIR) & (HSCX_XDU | HSCX_RFO | HSCX_CSC);
 
-	if (exir & HSCX_RFO) {
+    if (exir & HSCX_RFO)
+    {
 		ch->stats.rx_over_errors++;
-		if (hw->rx_ptr) {
-			kfree_skb(hw->recving);
-			hw->recving = NULL; hw->rx_ptr = 0;
+	if (hw->rx_ptr)
+	{
+	    mixcom_kfree_skb(hw->recving);
+	    hw->recving = NULL;
+	    hw->rx_ptr = 0;
 		}
 		printk(KERN_ERR "MIXCOM: rx overrun\n");
 		hscx_cmd(dev, HSCX_RHR);
 	}
 
-	if (exir & HSCX_XDU) { // xmit underrun
+    if (exir & HSCX_XDU)
+    {				// xmit underrun
 		ch->stats.tx_errors++;
 		ch->stats.tx_aborted_errors++;
-		if (hw->tx_ptr) {
-			kfree_skb(hw->sending);
+	if (hw->tx_ptr)
+	{
+	    mixcom_kfree_skb(hw->sending);
 			hw->sending = NULL; 
 			hw->tx_ptr = 0;
 		}
 		hscx_cmd(dev, HSCX_XRES);
 		clear_bit(0, &hw->txbusy);
-		if (ch->LINE_tx) {
+	if (ch->LINE_tx)
 			ch->LINE_tx(dev);
-		}
 		printk(KERN_ERR "MIXCOM: tx underrun\n");
 	}
 
-	if (exir & HSCX_CSC) {        
+    if (exir & HSCX_CSC)
+    {
 		ch->stats.tx_carrier_errors++;
-		if ((rd_hscx(dev, HSCX_STAR) & HSCX_CTS) == 0) { // Vonal le
-			if (test_and_clear_bit(0, &ch->lineup_pending)) {
+	if ((rd_hscx(dev, HSCX_STAR) & HSCX_CTS) == 0)
+	{			// Vonal le
+	    if (test_and_clear_bit(0, &ch->lineup_pending))
                			del_timer(&ch->lineup_timer);
-			} else if (ch->line_status & LINE_UP) {
+	    else if (ch->line_status & LINE_UP)
+	    {
         		       	ch->line_status &= ~LINE_UP;
-                		if (ch->LINE_status) {
-                      			ch->LINE_status(dev,ch->line_status);
-                      		}
+		if (ch->LINE_status)
+		    ch->LINE_status(dev, ch->line_status);
 		      	}
 		}
-		if (!(ch->line_status & LINE_UP) && (rd_hscx(dev, HSCX_STAR) & 
-		    HSCX_CTS)) { // Vonal fol
-			if (!test_and_set_bit(0,&ch->lineup_pending)) {
+	if (!(ch->line_status & LINE_UP)
+	    && (rd_hscx(dev, HSCX_STAR) & HSCX_CTS))
+	{			// Vonal fol
+	    if (!test_and_set_bit(0, &ch->lineup_pending))
+	    {
 				ch->lineup_timer.function = comx_lineup_func;
 	        	        ch->lineup_timer.data = (unsigned long)dev;
-        	        	ch->lineup_timer.expires = jiffies + HZ * 
-        	        		ch->lineup_delay;
+		ch->lineup_timer.expires = jiffies + HZ * ch->lineup_delay;
 	                	add_timer(&ch->lineup_timer);
 		                hscx_cmd(dev, HSCX_XRES);
         		        clear_bit(0, &hw->txbusy);
-                		if (hw->sending) {
-					kfree_skb(hw->sending);
-				}
-				hw->sending=NULL;
+		if (hw->sending)
+		    mixcom_kfree_skb(hw->sending);
+		hw->sending = NULL;
 				hw->tx_ptr = 0;
 			}
 		}
@@ -419,58 +430,62 @@
 	struct mixcom_privdata *hw, *twin_hw;
 	register unsigned char ista;
 
-	if (dev==NULL) {
-		printk(KERN_ERR "comx_interrupt: irq %d for unknown device\n",irq);
+    if (dev == NULL)
+    {
+	printk(KERN_ERR "comx_interrupt: irq %d for unknown device\n", irq);
 		return;
 	}
 
 	ch = dev->priv; 
 	hw = ch->HW_privdata;
 
-	save_flags(flags); cli(); 
+    spin_lock_irqsave(&mister_lock, flags);
 
-	while((ista = (rd_hscx(dev, HSCX_ISTA) & (HSCX_RME | HSCX_RPF | 
-	    HSCX_XPR | HSCX_EXB | HSCX_EXA | HSCX_ICA)))) {
+    while ((ista =
+	    (rd_hscx(dev, HSCX_ISTA) &
+	     (HSCX_RME | HSCX_RPF | HSCX_XPR | HSCX_EXB | HSCX_EXA |
+	      HSCX_ICA))))
+    {
 		register byte ista2 = 0;
 
-		if (ista & HSCX_RME) {
+	if (ista & HSCX_RME)
 			mixcom_receive_frame(dev);
-		}
-		if (ista & HSCX_RPF) {
+	if (ista & HSCX_RPF)
 			hscx_empty_fifo(dev, 32);
-		}
-		if (ista & HSCX_XPR) {
-			if (hw->tx_ptr) {
+	if (ista & HSCX_XPR)
+	{
+	    if (hw->tx_ptr)
 				hscx_fill_fifo(dev);
-			} else {
+	    else
+	    {
 				clear_bit(0, &hw->txbusy);
                			ch->LINE_tx(dev);
 			}
 		}
 		
-		if (ista & HSCX_EXB) {
+	if (ista & HSCX_EXB)
 			mixcom_extended_interrupt(dev);
-		}
 		
-		if ((ista & HSCX_EXA) && ch->twin)  {
+	if ((ista & HSCX_EXA) && ch->twin)
 			mixcom_extended_interrupt(ch->twin);
-		}
 	
-		if ((ista & HSCX_ICA) && ch->twin &&
-		    (ista2 = rd_hscx(ch->twin, HSCX_ISTA) &
-		    (HSCX_RME | HSCX_RPF | HSCX_XPR ))) {
-			if (ista2 & HSCX_RME) {
+	if ((ista & HSCX_ICA) && ch->twin
+	    && (ista2 =
+		rd_hscx(ch->twin,
+			HSCX_ISTA) & (HSCX_RME | HSCX_RPF | HSCX_XPR)))
+	{
+	    if (ista2 & HSCX_RME)
 				mixcom_receive_frame(ch->twin);
-			}
-			if (ista2 & HSCX_RPF) {
+	    if (ista2 & HSCX_RPF)
 				hscx_empty_fifo(ch->twin, 32);
-			}
-			if (ista2 & HSCX_XPR) {
-				twin_ch=ch->twin->priv;
-				twin_hw=twin_ch->HW_privdata;
-				if (twin_hw->tx_ptr) {
+	    if (ista2 & HSCX_XPR)
+	    {
+		twin_ch = ch->twin->priv;
+		twin_hw = twin_ch->HW_privdata;
+		if (twin_hw->tx_ptr)
 					hscx_fill_fifo(ch->twin);
-				} else {
+		else
+		{
 					clear_bit(0, &twin_hw->txbusy);
 					ch->LINE_tx(ch->twin);
 				}
@@ -478,7 +493,7 @@
 		}
 	}
 
-	restore_flags(flags);
+    spin_unlock_irqrestore(&mister_lock, flags);
 	return;
 }
 
@@ -493,82 +508,87 @@
 	if (!dev->base_addr || !dev->irq)
 		goto err_ret;
 
-
-	if(hw->channel==1) {
-		if(!TWIN(dev) || !(COMX_CHANNEL(TWIN(dev))->init_status & 
-		    IRQ_ALLOCATED)) {
-			printk(KERN_ERR "%s: channel 0 not yet initialized\n",dev->name);
+    if (hw->channel == 1)
+    {
+	if (!TWIN(dev)
+	    || !(COMX_CHANNEL(TWIN(dev))->init_status & IRQ_ALLOCATED))
+	{
+	    printk(KERN_ERR "%s: channel 0 not yet initialized\n", dev->name);
 			ret = -EAGAIN;
 			goto err_ret;
 		}
 	}
 
-
 	/* Is our hw present at all ? Not checking for channel 0 if it is already 
 	   open */
-	if(hw->channel!=0 || !(ch->init_status & IRQ_ALLOCATED)) {
-		if (!request_region(dev->base_addr, MIXCOM_IO_EXTENT, dev->name)) {
+    if (hw->channel != 0 || !(ch->init_status & IRQ_ALLOCATED))
+    {
+	if (!request_region(dev->base_addr, MIXCOM_IO_EXTENT, dev->name))
+	{
 			ret = -EAGAIN;
 			goto err_ret;
 		}
-		if (mixcom_probe(dev)) {
+	if (mixcom_probe(dev))
+	{
 			ret = -ENODEV;
 			goto err_release_region;
 		}
 	}
 
-	if(hw->channel==0 && !(ch->init_status & IRQ_ALLOCATED)) {
-		if (request_irq(dev->irq, MIXCOM_interrupt, 0, 
-		    dev->name, (void *)dev)) {
+    if (hw->channel == 0 && !(ch->init_status & IRQ_ALLOCATED))
+    {
+	if (request_irq
+	    (dev->irq, MIXCOM_interrupt, 0, dev->name, (void *)dev))
+	{
 			printk(KERN_ERR "MIXCOM: unable to obtain irq %d\n", dev->irq);
 			ret = -EAGAIN;
 			goto err_release_region;
 		}
 	}
 
-	save_flags(flags); cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
-	if(hw->channel==0 && !(ch->init_status & IRQ_ALLOCATED)) {
-		ch->init_status|=IRQ_ALLOCATED;
+    if (hw->channel == 0 && !(ch->init_status & IRQ_ALLOCATED))
+    {
+	ch->init_status |= IRQ_ALLOCATED;
 		mixcom_board_on(dev);
 	}
 
 	mixcom_on(dev);
 
-
-	hw->status=inb(MIXCOM_BOARD_BASE(dev) + MIXCOM_STATUS_OFFSET);
-	if(hw->status != 0xff) {
+    hw->status = inb(MIXCOM_BOARD_BASE(dev) + MIXCOM_STATUS_OFFSET);
+    if (hw->status != 0xff)
+    {
 		printk(KERN_DEBUG "%s: board has status register, good\n", dev->name);
-		hw->card_has_status=1;
+	hw->card_has_status = 1;
 	}
 
 	hw->txbusy = 0;
 	ch->init_status |= HW_OPEN;
 	
-	if (rd_hscx(dev, HSCX_STAR) & HSCX_CTS) {
+    if (rd_hscx(dev, HSCX_STAR) & HSCX_CTS)
 		ch->line_status |= LINE_UP;
-	} else {
+    else
 		ch->line_status &= ~LINE_UP;
-	}
 
-	restore_flags(flags);
+    spin_unlock_irqrestore(&mister_lock, flags);
 
 	ch->LINE_status(dev, ch->line_status);
 
-	for (; procfile ; procfile = procfile->next) {
-		if (strcmp(procfile->name, FILENAME_IO) == 0 ||
-		    strcmp(procfile->name, FILENAME_CHANNEL) == 0 ||
-		    strcmp(procfile->name, FILENAME_CLOCK) == 0 ||
-		    strcmp(procfile->name, FILENAME_IRQ) == 0) {
+    for (; procfile; procfile = procfile->next)
+    {
+	if (strcmp(procfile->name, FILENAME_IO) == 0
+	    || strcmp(procfile->name, FILENAME_CHANNEL) == 0
+	    || strcmp(procfile->name, FILENAME_CLOCK) == 0
+	    || strcmp(procfile->name, FILENAME_IRQ) == 0)
 			procfile->mode = S_IFREG |  0444;
 		}
-	}
 
 	return 0;
 	
-err_release_region:
+  err_release_region:
 	release_region(dev->base_addr, MIXCOM_IO_EXTENT);
-err_ret:
+  err_ret:
 	return ret;
 }
 
@@ -579,14 +599,15 @@
 	struct proc_dir_entry *procfile = ch->procdir->subdir;
 	unsigned long flags;
 
-
-	save_flags(flags); cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
 	mixcom_off(dev);
 
 	/* This is channel 0, twin is not open, we can safely turn off everything */
-	if(hw->channel==0 && (!(TWIN(dev)) || 
-	    !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN))) {
+    if (hw->channel == 0
+	&& (!(TWIN(dev))
+	    || !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN)))
+    {
 		mixcom_board_off(dev);
 		free_irq(dev->irq, dev);
 		release_region(dev->base_addr, MIXCOM_IO_EXTENT);
@@ -595,8 +616,10 @@
 
 	/* This is channel 1, channel 0 has already been shutdown, we can release
 	   this one too */
-	if(hw->channel==1 && !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN)) {
-		if(COMX_CHANNEL(TWIN(dev))->init_status & IRQ_ALLOCATED) {
+    if (hw->channel == 1 && !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN))
+    {
+	if (COMX_CHANNEL(TWIN(dev))->init_status & IRQ_ALLOCATED)
+	{
 			mixcom_board_off(TWIN(dev));
 			free_irq(TWIN(dev)->irq, TWIN(dev));
 			release_region(TWIN(dev)->base_addr, MIXCOM_IO_EXTENT);
@@ -605,57 +628,59 @@
 	}
 
 	/* the ioports for channel 1 can be safely released */
-	if(hw->channel==1) {
+    if (hw->channel == 1)
 		release_region(dev->base_addr, MIXCOM_IO_EXTENT);
-	}
 
-	restore_flags(flags);
+    spin_unlock_irqrestore(&mister_lock, flags);
 
 	/* If we don't hold any hardware open */
-	if(!(ch->init_status & IRQ_ALLOCATED)) {
-		for (; procfile ; procfile = procfile->next) {
-			if (strcmp(procfile->name, FILENAME_IO) == 0 ||
-			    strcmp(procfile->name, FILENAME_CHANNEL) == 0 ||
-			    strcmp(procfile->name, FILENAME_CLOCK) == 0 ||
-			    strcmp(procfile->name, FILENAME_IRQ) == 0) {
+    if (!(ch->init_status & IRQ_ALLOCATED))
+    {
+	for (; procfile; procfile = procfile->next)
+	{
+	    if (strcmp(procfile->name, FILENAME_IO) == 0
+		|| strcmp(procfile->name, FILENAME_CHANNEL) == 0
+		|| strcmp(procfile->name, FILENAME_CLOCK) == 0
+		|| strcmp(procfile->name, FILENAME_IRQ) == 0)
 				procfile->mode = S_IFREG |  0644;
 			}
 		}
-	}
 
 	/* channel 0 was only waiting for us to close channel 1 
 	   close it completely */
    
-	if(hw->channel==1 && !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN)) {
-		for (procfile=COMX_CHANNEL(TWIN(dev))->procdir->subdir; 
-		    procfile ; procfile = procfile->next) {
-			if (strcmp(procfile->name, FILENAME_IO) == 0 ||
-			    strcmp(procfile->name, FILENAME_CHANNEL) == 0 ||
-			    strcmp(procfile->name, FILENAME_CLOCK) == 0 ||
-			    strcmp(procfile->name, FILENAME_IRQ) == 0) {
+    if (hw->channel == 1 && !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN))
+    {
+	for (procfile = COMX_CHANNEL(TWIN(dev))->procdir->subdir; procfile;
+	     procfile = procfile->next)
+	{
+	    if (strcmp(procfile->name, FILENAME_IO) == 0
+		|| strcmp(procfile->name, FILENAME_CHANNEL) == 0
+		|| strcmp(procfile->name, FILENAME_CLOCK) == 0
+		|| strcmp(procfile->name, FILENAME_IRQ) == 0)
 				procfile->mode = S_IFREG |  0644;
 			}
 		}
-	}
 	
 	ch->init_status &= ~HW_OPEN;
 	return 0;
 }
 
-static int MIXCOM_statistics(struct net_device *dev,char *page)
+static int MIXCOM_statistics(struct net_device *dev, char *page)
 {
 	struct comx_channel *ch = dev->priv;
+
 	// struct mixcom_privdata *hw = ch->HW_privdata;
 	int len = 0;
 
-	if(ch->init_status && IRQ_ALLOCATED) {
+    if (ch->init_status && IRQ_ALLOCATED)
 		len += sprintf(page + len, "Mixcom board: hardware open\n");
-	}
 
 	return len;
 }
 
-static int MIXCOM_dump(struct net_device *dev) {
+static int MIXCOM_dump(struct net_device *dev)
+{
 	return 0;
 }
 
@@ -668,33 +693,41 @@
 	struct mixcom_privdata *hw = ch->HW_privdata;
 	int len = 0;
 
-	if (strcmp(file->name, FILENAME_IO) == 0) {
-		len = sprintf(page, "0x%x\n", 
-			(unsigned int)MIXCOM_BOARD_BASE(dev));
-	} else if (strcmp(file->name, FILENAME_IRQ) == 0) {
+    if (strcmp(file->name, FILENAME_IO) == 0)
+	len = sprintf(page, "0x%x\n", (unsigned int)MIXCOM_BOARD_BASE(dev));
+    else if (strcmp(file->name, FILENAME_IRQ) == 0)
 		len = sprintf(page, "%d\n", (unsigned int)dev->irq);
-	} else if (strcmp(file->name, FILENAME_CLOCK) == 0) {
-		if (hw->clock) len = sprintf(page, "%d\n", hw->clock);
-			else len = sprintf(page, "external\n");
-	} else if (strcmp(file->name, FILENAME_CHANNEL) == 0) {
+    else if (strcmp(file->name, FILENAME_CLOCK) == 0)
+    {
+	if (hw->clock)
+	    len = sprintf(page, "%d\n", hw->clock);
+	else
+	    len = sprintf(page, "external\n");
+    }
+    else if (strcmp(file->name, FILENAME_CHANNEL) == 0)
 		len = sprintf(page, "%01d\n", hw->channel);
-	} else if (strcmp(file->name, FILENAME_TWIN) == 0) {
-		if (ch->twin) {
-			len = sprintf(page, "%s\n",ch->twin->name);
-		} else {
+    else if (strcmp(file->name, FILENAME_TWIN) == 0)
+    {
+	if (ch->twin)
+	    len = sprintf(page, "%s\n", ch->twin->name);
+	else
 			len = sprintf(page, "none\n");
 		}
-	} else {
-		printk(KERN_ERR "mixcom_read_proc: internal error, filename %s\n", file->name);
+    else
+    {
+	printk(KERN_ERR "mixcom_read_proc: internal error, filename %s\n",
+	       file->name);
 		return -EBADF;
 	}
 
-	if (off >= len) {
+    if (off >= len)
+    {
 		*eof = 1;
 		return 0;
 	}
 	*start = page + off;
-	if (count >= len - off) *eof = 1;
+    if (count >= len - off)
+	*eof = 1;
 	return min_t(int, count, len - off);
 }
 
@@ -709,42 +742,37 @@
 	struct comx_channel *ch_twin;
 	struct mixcom_privdata *hw_twin;
 
-
-	for ( ; procfile ; procfile = procfile->next) {
-		if(!S_ISDIR(procfile->mode)) continue;
+    for (; procfile; procfile = procfile->next)
+    {
+	if (!S_ISDIR(procfile->mode))
+	    continue;
                 
         	twin = procfile->data;
 	        ch_twin = twin->priv;
         	hw_twin = ch_twin->HW_privdata;
 
-
-	        if (twin != dev && dev->irq && dev->base_addr && 
-        	    dev->irq == twin->irq && 
-        	    ch->hardware == ch_twin->hardware &&
-		    dev->base_addr == twin->base_addr + 
-		    (1-2*hw->channel)*MIXCOM_CHANNEL_OFFSET &&
-		    hw->channel == (1 - hw_twin->channel)) {
-	        	if  (!TWIN(twin) || TWIN(twin)==dev) {
+	if (twin != dev && dev->irq && dev->base_addr && dev->irq == twin->irq
+	    && ch->hardware == ch_twin->hardware
+	    && dev->base_addr ==
+	    twin->base_addr + (1 - 2 * hw->channel) * MIXCOM_CHANNEL_OFFSET
+	    && hw->channel == (1 - hw_twin->channel))
+	    if (!TWIN(twin) || TWIN(twin) == dev)
 	        		return twin;
 	        	}
-		}
-        }
 	return NULL;
 }
 
-
-static void setup_twin(struct net_device* dev) 
+static void setup_twin(struct net_device *dev)
 {
 
-	if(TWIN(dev) && TWIN(TWIN(dev))) {
-		TWIN(TWIN(dev))=NULL;
-	}
-	if ((TWIN(dev) = mixcom_twin_check(dev)) != NULL) {
-		if (TWIN(TWIN(dev)) && TWIN(TWIN(dev)) != dev) {
-			TWIN(dev)=NULL;
-		} else {
-			TWIN(TWIN(dev))=dev;
-		}
+    if (TWIN(dev) && TWIN(TWIN(dev)))
+	TWIN(TWIN(dev)) = NULL;
+    if ((TWIN(dev) = mixcom_twin_check(dev)) != NULL)
+    {
+	if (TWIN(TWIN(dev)) && TWIN(TWIN(dev)) != dev)
+	    TWIN(dev) = NULL;
+	else
+	    TWIN(TWIN(dev)) = dev;
 	}	
 }
 
@@ -758,58 +786,65 @@
 	char *page;
 	int value;
 
-	if (!(page = (char *)__get_free_page(GFP_KERNEL))) {
+    if (!(page = (char *)__get_free_page(GFP_KERNEL)))
 		return -ENOMEM;
-	}
 
-	copy_from_user(page, buffer, count = min_t(unsigned long, count, PAGE_SIZE));
-	if (*(page + count - 1) == '\n') {
+    copy_from_user(page, buffer, count =
+		   min_t(unsigned long, count, PAGE_SIZE));
+    if (*(page + count - 1) == '\n')
 		*(page + count - 1) = 0;
-	}
 
-	if (strcmp(entry->name, FILENAME_IO) == 0) {
+    if (strcmp(entry->name, FILENAME_IO) == 0)
+    {
 		value = simple_strtoul(page, NULL, 0);
-		if (value != 0x180 && value != 0x280 && value != 0x380) {
+	if (value != 0x180 && value != 0x280 && value != 0x380)
 			printk(KERN_ERR "MIXCOM: incorrect io address!\n");
-		} else {
-			dev->base_addr = MIXCOM_DEV_BASE(value,hw->channel);
+	else
+	    dev->base_addr = MIXCOM_DEV_BASE(value, hw->channel);
 		}
-	} else if (strcmp(entry->name, FILENAME_IRQ) == 0) {
+    else if (strcmp(entry->name, FILENAME_IRQ) == 0)
+    {
 		value = simple_strtoul(page, NULL, 0); 
-		if (value < 0 || value > 15 || mixcom_set_irq[value]==0xFF) {
+	if (value < 0 || value > 15 || mixcom_set_irq[value] == 0xFF)
 			printk(KERN_ERR "MIXCOM: incorrect irq value!\n");
-		} else {
+	else
 			dev->irq = value;	
 		}
-	} else if (strcmp(entry->name, FILENAME_CLOCK) == 0) {
-		if (strncmp("ext", page, 3) == 0) {
+    else if (strcmp(entry->name, FILENAME_CLOCK) == 0)
+    {
+	if (strncmp("ext", page, 3) == 0)
 			hw->clock = 0;
-		} else {
+	else
+	{
 			int kbps;
 
 			kbps = simple_strtoul(page, NULL, 0);
-			if (!kbps) {
+	    if (!kbps)
 				hw->clock = 0;
-			} else {
+	    else
 				hw->clock = kbps;
-			}
-			if (hw->clock < 32 || hw->clock > 2000) {
+	    if (hw->clock < 32 || hw->clock > 2000)
+	    {
 				hw->clock = 0;
 				printk(KERN_ERR "MIXCOM: invalid clock rate!\n");
 			}
 		}
-		if (ch->init_status & HW_OPEN && ch->HW_set_clock) {
+	if (ch->init_status & HW_OPEN && ch->HW_set_clock)
 			ch->HW_set_clock(dev);
 		}
-	} else if (strcmp(entry->name, FILENAME_CHANNEL) == 0) {
+    else if (strcmp(entry->name, FILENAME_CHANNEL) == 0)
+    {
 		value = simple_strtoul(page, NULL, 0);
-        	if (value > 2) {
+	if (value > 2)
                 	printk(KERN_ERR "Invalid channel number\n");
-	        } else {
-        		dev->base_addr+=(hw->channel - value) * MIXCOM_CHANNEL_OFFSET;
+	else
+	{
+	    dev->base_addr += (hw->channel - value) * MIXCOM_CHANNEL_OFFSET;
 	        	hw->channel = value;
 		}	        
-	} else {
+    }
+    else
+    {
 		printk(KERN_ERR "hw_read_proc: internal error, filename %s\n", 
 			entry->name);
 		return -EBADF;
@@ -821,60 +856,48 @@
 	return count;
 }
 
-static int MIXCOM_init(struct net_device *dev) {
+static int MIXCOM_init(struct net_device *dev)
+{
 	struct comx_channel *ch = dev->priv;
 	struct mixcom_privdata *hw;
 	struct proc_dir_entry *new_file;
 
-	if ((ch->HW_privdata = kmalloc(sizeof(struct mixcom_privdata), 
-	    GFP_KERNEL)) == NULL) {
+    if ((ch->HW_privdata =
+	 kmalloc(sizeof(struct mixcom_privdata), GFP_KERNEL)) == NULL)
 	    	return -ENOMEM;
-	}
 
 	memset(hw = ch->HW_privdata, 0, sizeof(struct mixcom_privdata));
 
-	if ((new_file = create_proc_entry(FILENAME_IO, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_IO, S_IFREG | 0644, ch->procdir)) == NULL)
 		goto cleanup_HW_privdata;
-	}
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &mixcom_read_proc;
 	new_file->write_proc = &mixcom_write_proc;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_IRQ, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_IRQ, S_IFREG | 0644,
+			   ch->procdir)) == NULL)
 	    	goto cleanup_filename_io;
-	}
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &mixcom_read_proc;
 	new_file->write_proc = &mixcom_write_proc;
 	new_file->nlink = 1;
 
-#if 0
-	if ((new_file = create_proc_entry(FILENAME_CLOCK, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
-	    	return -EIO;
-	}
-	new_file->data = (void *)new_file;
-	new_file->read_proc = &mixcom_read_proc;
-	new_file->write_proc = &mixcom_write_proc;
-	new_file->nlink = 1;
-#endif
-
-	if ((new_file = create_proc_entry(FILENAME_CHANNEL, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_CHANNEL, S_IFREG | 0644,
+			   ch->procdir)) == NULL)
 	    	goto cleanup_filename_irq;
-	}
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &mixcom_read_proc;
 	new_file->write_proc = &mixcom_write_proc;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_TWIN, S_IFREG | 0444, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_TWIN, S_IFREG | 0444,
+			   ch->procdir)) == NULL)
 	    	goto cleanup_filename_channel;
-	}
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &mixcom_read_proc;
 	new_file->write_proc = &mixcom_write_proc;
@@ -892,18 +915,18 @@
 	ch->HW_statistics = MIXCOM_statistics;
 	ch->HW_set_clock = NULL;
 
-	dev->base_addr = MIXCOM_DEV_BASE(MIXCOM_DEFAULT_IO,0);
+    dev->base_addr = MIXCOM_DEV_BASE(MIXCOM_DEFAULT_IO, 0);
 	dev->irq = MIXCOM_DEFAULT_IRQ;
 
 	MOD_INC_USE_COUNT;
 	return 0;
-cleanup_filename_channel:
+  cleanup_filename_channel:
 	remove_proc_entry(FILENAME_CHANNEL, ch->procdir);
-cleanup_filename_irq:
+  cleanup_filename_irq:
 	remove_proc_entry(FILENAME_IRQ, ch->procdir);
-cleanup_filename_io:
+  cleanup_filename_io:
 	remove_proc_entry(FILENAME_IO, ch->procdir);
-cleanup_HW_privdata:
+  cleanup_HW_privdata:
 	kfree(ch->HW_privdata);
 	return -EIO;
 }
@@ -913,13 +936,11 @@
 	struct comx_channel *ch = dev->priv;
 	struct mixcom_privdata *hw = ch->HW_privdata;
 
-	if(hw->channel==0 && TWIN(dev)) {
+    if (hw->channel == 0 && TWIN(dev))
 		return -EBUSY;
-	}
 
-	if(hw->channel==1 && TWIN(dev)) {
-		TWIN(TWIN(dev))=NULL;
-	}
+    if (hw->channel == 1 && TWIN(dev))
+	TWIN(TWIN(dev)) = NULL;
 
 	kfree(ch->HW_privdata);
 	remove_proc_entry(FILENAME_IO, ch->procdir);
@@ -951,12 +972,11 @@
 
 int __init comx_hw_mixcom_init(void)
 {
-	return(comx_register_hardware(&mixcomhw));
+    return (comx_register_hardware(&mixcomhw));
 }
 
 #ifdef MODULE
-void
-cleanup_module(void)
+void cleanup_module(void)
 {
 	comx_unregister_hardware("mixcom");
 }
diff -ruNP linux-2.4.24/drivers/net/wan/comx.c linux-2.4.24-p/drivers/net/wan/comx.c
--- linux-2.4.24/drivers/net/wan/comx.c	Sat Aug  3 02:39:44 2002
+++ linux-2.4.24-p/drivers/net/wan/comx.c	Tue Jan  6 19:59:48 2004
@@ -60,6 +60,7 @@
 #include <linux/types.h>
 #include <linux/sched.h>
 #include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
 #include <linux/proc_fs.h>
 #include <asm/uaccess.h>
 #include <linux/ctype.h>
@@ -113,7 +114,8 @@
 
 static struct proc_dir_entry * comx_root_dir;
 
-struct comx_debugflags_struct	comx_debugflags[] = {
+struct comx_debugflags_struct	comx_debugflags[] =
+{
 	{ "comx_rx",		DEBUG_COMX_RX		},
 	{ "comx_tx", 		DEBUG_COMX_TX		},
 	{ "hw_tx",		DEBUG_HW_TX		},
@@ -614,6 +616,7 @@
 	struct comx_protocol *line = comx_lines;
 	char str[30];
 	int ret=0;
+	spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 
 	if (count > PAGE_SIZE) {
 		printk(KERN_ERR "count is %lu > %d!!!\n", count, (int)PAGE_SIZE);
@@ -644,14 +647,14 @@
 		if ((i = simple_strtoul(page, NULL, 10)) != 0) {
 			unsigned long flags;
 
-			save_flags(flags); cli();
+			spin_lock_irqsave(&mister_lock, flags);
 			if (ch->debug_area) kfree(ch->debug_area);
 			if ((ch->debug_area = kmalloc(ch->debug_size = i, 
 				GFP_KERNEL)) == NULL) {
 				ret = -ENOMEM;
 			}
 			ch->debug_start = ch->debug_end = 0;
-			restore_flags(flags);
+			spin_unlock_irqrestore(&mister_lock, flags);
 			free_page((unsigned long)page);
 			return ret ? ret : count;
 		}
@@ -829,9 +832,15 @@
 	strcpy(dev->name, (char *)new_dir->name);
 	dev->init = comx_init_dev;
 
-	if (register_netdevice(dev)) {
+	{
+	    int ret2;
+	    rtnl_lock();
+	    ret2 = register_netdevice(dev);
+	    rtnl_unlock();
+	    if (ret2)
 		goto cleanup_filename_debug;
 	}
+
 	ch=dev->priv;
 	if((ch->if_ptr = (void *)kmalloc(sizeof(struct ppp_device), 
 				 GFP_KERNEL)) == NULL) {
diff -ruNP linux-2.4.24/drivers/net/wan/farsync.c linux-2.4.24-p/drivers/net/wan/farsync.c
--- linux-2.4.24/drivers/net/wan/farsync.c	Fri Nov 28 19:26:20 2003
+++ linux-2.4.24-p/drivers/net/wan/farsync.c	Tue Jan  6 19:59:48 2004
@@ -1,9 +1,9 @@
 /*
- *      FarSync X21 driver for Linux (generic HDLC version)
+ *      FarSync X21 driver for Linux (2.4.x kernel version)
  *
  *      Actually sync driver for X.21, V.35 and V.24 on FarSync T-series cards
  *
- *      Copyright (C) 2001 FarSite Communications Ltd.
+ *      Copyright (C) 2001-2002 FarSite Communications Ltd.
  *      www.farsite.co.uk
  *
  *      This program is free software; you can redistribute it and/or
@@ -11,17 +11,78 @@
  *      as published by the Free Software Foundation; either version
  *      2 of the License, or (at your option) any later version.
  *
- *      Author: R.J.Dunlop      <bob.dunlop@farsite.co.uk>
+ *      Author:      R.J.Dunlop    <bob.dunlop@farsite.co.uk>
+ *      Maintainer:  Kevin Curtis  <kevin.curtis@farsite.co.uk>
+ */
+/*      Revision History
+ *      $Log$
+ *      Revision 1.1  2004/01/06 20:31:30  krichy
+ *      Now uses the linux kernel 2.4.24.
+ *      Made more easier to upgrade the kernel versions.
+ *
+ *      Revision 1.1.1.1  2004/01/06 18:44:04  krichy
+ *
+ *      The first working release of cflinux. Now imported to CVS.
+ *
+ *      Revision 1.14  2003/01/10 14:21:58  kevinc
+ *      Final changes
+ *
+ *      Revision 1.13  2003/01/02 13:11:46  kevinc
+ *      Changes to support the TxU family of cards.
+ *      Required the introduction of bottom halves.  Thus most of the
+ *      processing is now done out og interrupt mode.
+ *
+ *      Revision 1.12  2002/04/23 09:18:51  kevinc
+ *      Performance enhancement changes
+ *
+ *      Revision 1.11  2002/04/23 08:52:59  kevinc
+ *      Changes from the Kernel team regarding calls to pci device routines
+ *
+ *      Revision 1.10  2001/09/10 11:13:56  rjd
+ *      Correct ioctl parameter checking for security problem highlighted on
+ *      kernel developer list.
+ *
+ *      Revision 1.9  2001/08/21 11:45:08  rjd
+ *      Brought code into line with that used for the official 2.4.9 kernel
+ *
+ *      Revision 1.8  2001/07/03 15:55:54  rjd
+ *      First non-beta version.
+ *      Started preparations for the generic-HDLC version.
+ *
+ *      Revision 1.7  2001/05/29 09:05:27  rjd
+ *      Improved startup carrier processing.
+ *      Removed interrupt loop optimistation as never used.
+ *      Added support of 2.4.5 kernel.
+ *
+ *      Revision 1.6  2001/05/11 12:16:35  rjd
+ *      Fixes for Red Hat 7.1 where 2.4.2 kernel has 2.4.3 version of syncppp.
+ *      Corrected printing macros for later compilers.
+ *
+ *      Revision 1.5  2001/05/10 08:27:43  rjd
+ *      Added configurable MTU support and RH7.1 installation patch
+ *
+ *      Revision 1.4  2001/05/02 09:30:22  rjd
+ *      Reboot with noisy lines causing Opps fixed.
+ *      Tx buffer reordering problem fixed.
+ *      Port configuration code simplified.
+ *
+ *      Revision 1.3  2001/04/19 15:43:53  rjd
+ *      SyncPPP module and header file location changed under 2.4.3
+ *
+ *      Revision 1.2  2001/04/05 16:35:32  rjd
+ *      Upgrade to SMC version 11
+ *
+ *      Revision 1.1.1.1  2001/03/30 13:46:42  rjd
+ *      Import after first Beta shipped.
+ *
  */
 
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/ioport.h>
+#include <linux/netdevice.h>
 #include <linux/init.h>
+#include <linux/if_arp.h>
 #include <asm/uaccess.h>
-#include <linux/if.h>
-#include <linux/hdlc.h>
+#include <net/syncppp.h>
+#include <asm/delay.h>
 
 #include "farsync.h"
 
@@ -31,7 +92,11 @@
  */
 MODULE_AUTHOR("R.J.Dunlop <bob.dunlop@farsite.co.uk>");
 MODULE_DESCRIPTION("FarSync T-Series X21 driver. FarSite Communications Ltd.");
-MODULE_LICENSE("GPL");
+MODULE_PARM (fst_txq_low, "i");
+MODULE_PARM (fst_txq_high, "i");
+MODULE_PARM (fst_max_reads, "i");
+MODULE_PARM (fst_excluded_cards, "i");
+MODULE_PARM (fst_excluded_list, "0-32i");
 
 EXPORT_NO_SYMBOLS;
 
@@ -40,16 +105,19 @@
  *      ==========================================
  */
 
-/*      Number of ports (per card) supported
+/*      Number of ports (per card) and cards supported
  */
 #define FST_MAX_PORTS           4
-
+#define FST_MAX_CARDS           32
 
 /*      PCI vendor and device IDs
  */
 #define FSC_PCI_VENDOR_ID       0x1619  /* FarSite Communications Ltd */
 #define T2P_PCI_DEVICE_ID       0x0400  /* T2P X21 2 port card */
 #define T4P_PCI_DEVICE_ID       0x0440  /* T4P X21 4 port card */
+#define T1U_PCI_DEVICE_ID       0x0610  /* T2U X21 1 port card */
+#define T2U_PCI_DEVICE_ID       0x0620  /* T2U X21 2 port card */
+#define T4U_PCI_DEVICE_ID       0x0640  /* T2U X21 4 port card */
 
 
 /*      Default parameters for the link
@@ -59,6 +127,15 @@
                                          * this down assuming a slower line I
                                          * guess.
                                          */
+#define FST_TXQ_DEPTH           16      /* This one is for the buffering
+                                         * of frames on the way down to the card
+                                         * so that we can keep the card busy
+                                         * and maximise throughput
+					 */
+#define FST_HIGH_WATER_MARK     12      /* Point at which we flow control
+					 * network layer */
+#define FST_LOW_WATER_MARK      8       /* Point at which we remove flow
+					 * control from network layer */
 #define FST_MAX_MTU             8000    /* Huge but possible */
 #define FST_DEF_MTU             1500    /* Common sane value */
 
@@ -72,6 +149,15 @@
 #endif
 
 
+/*
+ * Modules parameters and associated varaibles
+ */
+int   fst_txq_low=FST_LOW_WATER_MARK;
+int   fst_txq_high=FST_HIGH_WATER_MARK;
+int   fst_max_reads=7;
+int   fst_excluded_cards=0;
+int   fst_excluded_list[FST_MAX_CARDS];
+
 /*      Card shared memory layout
  *      =========================
  */
@@ -87,7 +173,7 @@
  *      be used to check that we have not got out of step with the firmware
  *      contained in the .CDE files.
  */
-#define SMC_VERSION 11
+#define SMC_VERSION 13
 
 #define FST_MEMSIZE 0x100000    /* Size of card memory (1Mb) */
 
@@ -161,7 +247,7 @@
 #define RX_ENP          0x01            /* Rx: end of packet */
 
 
-/* Interrupts from the card are caused by various events and these are presented
+/* Interrupts from the card are caused by various events which are presented
  * in a circular buffer as several events may be processed on one physical int
  */
 #define MAX_CIRBUFF     32
@@ -199,6 +285,9 @@
         u16  lineInterface;     /* Physical interface type */
         u8   x25op;             /* Unused at present */
         u8   internalClock;     /* 1 => internal clock, 0 => external */
+        u8   transparentMode;   /* 1 => on, 0 => off */
+        u8   invertClock;       /* 0 => normal, 1 => inverted */
+        u8   padBytes[6];       /* Padding */
         u32  lineSpeed;         /* Speed in bps */
 };
 
@@ -259,14 +348,14 @@
         u16 portMailbox[FST_MAX_PORTS][2];      /* command, modifier */
         u16 cardMailbox[4];                     /* Not used */
 
-                                /* Number of times that card thinks the host has
+                                /* Number of times the card thinks the host has
                                  * missed an interrupt by not acknowledging
                                  * within 2mS (I guess NT has problems)
                                  */
         u32 interruptRetryCount;
 
                                 /* Driver private data used as an ID. We'll not
-                                 * use this on Linux I'd rather keep such things
+                                 * use this as I'd rather keep such things
                                  * in main memory rather than on the PCI bus
                                  */
         u32 portHandle[FST_MAX_PORTS];
@@ -294,8 +383,8 @@
         u16 portScheduleOffset;
 
         u32 endOfSmcSignature;  /* endOfSmcSignature MUST be the last member of
-                                 * the structure and marks the end of the shared
-                                 * memory. Adapter code initializes its value as
+                                 * the structure and marks the end of shared
+                                 * memory. Adapter code initializes it as
                                  * END_SIG.
                                  */
 };
@@ -312,6 +401,42 @@
 #define ABORTTX         5       /* Abort the transmitter for a port */
 #define SETV24O         6       /* Set V24 outputs */
 
+/* PLX Chip Register Offsets */
+#define CNTRL_9052      0x50    /* Control Register */
+#define CNTRL_9054      0x6c    /* Control Register */
+
+#define PCIILR          0x3c    /* Interrupt Line Register */
+#define PCICR           0x04    /* Interrupt Control Register */
+#define INTCSR_9052     0x4c    /* Interrupt control/status register */
+#define INTCSR_9054     0x68    /* Interrupt control/status register */
+
+/* 9054 DMA Registers */
+/*
+ * Note that we will be using DMA Channel 0 for copying rx data
+ * and Channel 1 for copying tx data
+ */
+#define DMAMODE0        0x80
+#define DMAPADR0        0x84
+#define DMALADR0        0x88
+#define DMASIZ0         0x8c
+#define DMADPR0         0x90
+#define DMAMODE1        0x94
+#define DMAPADR1        0x98
+#define DMALADR1        0x9c
+#define DMASIZ1         0xa0
+#define DMADPR1         0xa4
+#define DMACSR0         0xa8
+#define DMACSR1         0xa9
+#define DMAARB          0xac
+#define DMATHR          0xb0
+#define DMADAC0         0xb4
+#define DMADAC1         0xb8
+#define DMAMARBR        0xac
+
+#define FST_MIN_DMA_LEN 64
+#define FST_RX_DMA_INT  0x01
+#define FST_TX_DMA_INT  0x02
+#define FST_CARD_INT    0x04
 
 /* Larger buffers are positioned in memory at offset BFM_BASE */
 struct buf_window {
@@ -331,15 +456,33 @@
 /*      Per port (line or channel) information
  */
 struct fst_port_info {
-        hdlc_device             hdlc;   /* HDLC device struct - must be first */
+        void                   *if_ptr; /* Some drivers describe this as a
+                                         * general purpose pointer. However if
+                                         * using syncPPP it has a very specific
+                                         * purpose: must be the first item in
+                                         * the structure pointed to by dev->priv
+                                         * and must in turn point to the
+                                         * associated ppp_device structure.
+                                         */
         struct fst_card_info   *card;   /* Card we're associated with */
         int                     index;  /* Port index on the card */
+        int                     proto;  /* Protocol we are running */
         int                     hwif;   /* Line hardware (lineInterface copy) */
         int                     run;    /* Port is running */
         int                     rxpos;  /* Next Rx buffer to use */
         int                     txpos;  /* Next Tx buffer to use */
         int                     txipos; /* Next Tx buffer to check for free */
-        int                     txcnt;  /* Count of Tx buffers in use */
+        int                     start;  /* Indication of start/stop to network */
+        struct net_device      *dev;    /* Kernel network device entry */
+        struct net_device_stats stats;  /* Standard statistics */
+        struct ppp_device       pppdev; /* Link to syncPPP */
+  /*
+   * A sixteen entry transmit queue
+   */
+        int                     txqs;  /* index to get next buffer to tx */
+        int                     txqe;  /* index to queue next packet */
+        struct sk_buff         *txq[FST_TXQ_DEPTH]; /* The queue */
+        int                     rxqdepth;
 };
 
 /*      Per card information
@@ -357,13 +500,35 @@
         unsigned short pci_conf;        /* PCI card config in I/O space */
                                         /* Per port info */
         struct fst_port_info ports[ FST_MAX_PORTS ];
+        struct pci_dev *device;          /* Information about the pci device */
+/*
+ *      Device Driver Task Queues
+ *
+ *      So that we don't spend too much time processing events in the 
+ *      Interrupt Service routine, we will declare a task queue per Card 
+ *      and make the ISR schedule a task in the queue for later execution.
+ */
+        int            card_no;        /* Instance of the card on the system */
+        struct tq_struct card_isr_task;
+        struct tq_struct card_tx_task;
+        int            family;          /* TxP or TxU */
+        int            dmarx_in_progress;
+        int            dmatx_in_progress;
+        unsigned long  int_count;
+        unsigned long  int_time_ave;
+	void          *rx_dma_handle_host;
+	dma_addr_t     rx_dma_handle_card;  
+	void          *tx_dma_handle_host;
+	dma_addr_t     tx_dma_handle_card;  
+        struct sk_buff *dma_skb_rx;
+        struct fst_port_info *dma_port_rx;
+        struct fst_port_info *dma_port_tx;
+        int            dma_len_rx;
+        int            dma_len_tx;
+        int            dma_txpos;
+        int            dma_rxpos;
 };
 
-/* Convert an HDLC device pointer into a port info pointer and similar */
-#define hdlc_to_port(H) ((struct fst_port_info *)(H))
-#define dev_to_port(D)  hdlc_to_port(dev_to_hdlc(D))
-#define port_to_dev(P)  hdlc_to_dev(&(P)->hdlc)
-
 
 /*
  *      Shared memory window access macros
@@ -403,7 +568,7 @@
                                 printk ( KERN_DEBUG FST_NAME ": " fmt, ## A )
 
 #else
-# define dbg(X...)      /* NOP */
+#define dbg(X...)      /* NOP */
 #endif
 
 
@@ -422,6 +587,12 @@
                                         FST_TYPE_T2P },
         { FSC_PCI_VENDOR_ID, T4P_PCI_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
                                         FST_TYPE_T4P },
+        { FSC_PCI_VENDOR_ID, T1U_PCI_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+                                        FST_TYPE_T1U },
+        { FSC_PCI_VENDOR_ID, T2U_PCI_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+                                        FST_TYPE_T2U },
+        { FSC_PCI_VENDOR_ID, T4U_PCI_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+                                        FST_TYPE_T4U },
         { 0, }                          /* End */
 };
 
@@ -436,17 +607,55 @@
  * Used to be a simple write to card control space but a glitch in the latest
  * AMD Am186CH processor means that we now have to do it by asserting and de-
  * asserting the PLX chip PCI Adapter Software Reset. Bit 30 in CNTRL register
- * at offset 0x50.
+ * at offset 9052_CNTRL.  Note the updates for the T2U.
  */
 static inline void
 fst_cpureset ( struct fst_card_info *card )
 {
+        unsigned char interrupt_line_register;
+	unsigned long j = jiffies + 1;
         unsigned int regval;
 
-        regval = inl ( card->pci_conf + 0x50 );
-
-        outl ( regval |  0x40000000, card->pci_conf + 0x50 );
-        outl ( regval & ~0x40000000, card->pci_conf + 0x50 );
+ 	if (card->family == FST_FAMILY_TXU)
+	  {
+	    if (pci_read_config_byte(card->device, PCIILR, &interrupt_line_register))
+	      {
+		dbg (DBG_ASS, "Error in reading interrupt line register\n");
+	      }
+	    /*
+	     * Assert PLX software reset and Am186 hardware reset
+	     * and then deassert the PLX software reset but 186 still in reset
+	     */
+	    outw ( 0x440f, card->pci_conf + CNTRL_9054 + 2 );
+	    outw ( 0x040f, card->pci_conf + CNTRL_9054 + 2 );
+	    /*
+	     * We are delaying here to allow the 9054 to reset itself
+	     */
+	    j = jiffies + 1;
+	    while (jiffies < j)
+	      /* Do nothing */;
+	    outw ( 0x240f, card->pci_conf + CNTRL_9054 + 2 );
+	    /*
+	     * We are delaying here to allow the 9054 to reload its eeprom
+	     */
+	    j = jiffies + 1;
+	    while (jiffies < j)
+	      /* Do nothing */;
+	    outw ( 0x040f, card->pci_conf + CNTRL_9054 + 2 );
+	    
+	    if (pci_write_config_byte(card->device, PCIILR, interrupt_line_register))
+	      {
+		dbg (DBG_ASS, "Error in writing interrupt line register\n");
+	      }
+	    
+	  }
+	else
+	  {
+	    regval = inl ( card->pci_conf + CNTRL_9052 );
+
+	    outl ( regval |  0x40000000, card->pci_conf + CNTRL_9052 );
+	    outl ( regval & ~0x40000000, card->pci_conf + CNTRL_9052 );
+	  }
 }
 
 /*      Release the processor from reset
@@ -454,7 +663,24 @@
 static inline void
 fst_cpurelease ( struct fst_card_info *card )
 {
-        (void) readb ( card->ctlmem );
+	if (card->family == FST_FAMILY_TXU)
+	  {
+	    /*
+	     * Force posted writes to complete
+	     */
+	    (void) readb (card->mem);
+
+	    /*
+	     * Release LRESET DO = 1
+	     * Then release Local Hold, DO = 1
+	     */
+	    outw ( 0x040e, card->pci_conf + CNTRL_9054 + 2 );
+	    outw ( 0x040f, card->pci_conf + CNTRL_9054 + 2 );
+	  }
+	else
+	  {
+	    (void) readb ( card->ctlmem );
+	  }
 }
 
 /*      Clear the cards interrupt flag
@@ -462,9 +688,31 @@
 static inline void
 fst_clear_intr ( struct fst_card_info *card )
 {
-        /* Poke the appropriate PLX chip register (same as enabling interrupts)
-         */
-        outw ( 0x0543, card->pci_conf + 0x4C );
+	if (card->family == FST_FAMILY_TXU)
+	  {
+	    (void) readb ( card->ctlmem );
+	  }
+	else
+	  {
+	    /* Poke the appropriate PLX chip register (same as enabling interrupts)
+	     */
+	    outw ( 0x0543, card->pci_conf + INTCSR_9052 );
+	  }
+}
+
+/*      Enable card interrupts
+ */
+static inline void
+fst_enable_intr ( struct fst_card_info *card )
+{
+	if (card->family == FST_FAMILY_TXU)
+	  {
+	    outl ( 0x0f0c0900, card->pci_conf + INTCSR_9054 );
+	  }
+	else
+	  {
+	    outw ( 0x0543, card->pci_conf + INTCSR_9052 );
+	  }
 }
 
 /*      Disable card interrupts
@@ -472,7 +720,151 @@
 static inline void
 fst_disable_intr ( struct fst_card_info *card )
 {
-        outw ( 0x0000, card->pci_conf + 0x4C );
+	if (card->family == FST_FAMILY_TXU)
+	  {
+	    outl ( 0x00000000, card->pci_conf + INTCSR_9054 );
+	  }
+	else
+	  {
+	    outw ( 0x0000, card->pci_conf + INTCSR_9052 );
+	  }
+}
+
+/*      Initilaise DMA for PLX 9054
+ */
+static inline void
+fst_init_dma ( struct fst_card_info *card )
+{
+  unsigned short pci_cr;
+
+  /*
+   * This is only required for the PLX 9054
+   */
+  if (card->family == FST_FAMILY_TXU)
+    {
+      pci_read_config_word (card->device, PCICR, &pci_cr);
+      pci_cr |= 0x0004;
+      pci_write_config_word (card->device, PCICR, pci_cr);  /* Enable DMA Bus mastering */
+      outl ( 0x00020441, card->pci_conf + DMAMODE0 );
+      outl ( 0x00020441, card->pci_conf + DMAMODE1 );
+      outl ( 0x0, card->pci_conf + DMATHR );
+    }
+}
+
+
+/*      Tx dma complete interrupt
+ */
+static void
+fst_tx_dma_complete ( struct fst_card_info *card, struct fst_port_info *port, 
+		      int len, int txpos)
+{
+	/*
+	 * Everything is now set, just tell the card to go
+	 */
+
+	FST_WRB ( card, txDescrRing[port->index][txpos].bits, 
+		  DMA_OWN | TX_STP | TX_ENP );
+	port->stats.tx_packets++;
+	port->stats.tx_bytes += len;
+	port->dev->trans_start = jiffies;
+}
+
+/*      Rx dma complete interrupt
+ */
+static void
+fst_rx_dma_complete ( struct fst_card_info *card, struct fst_port_info *port,
+		      int len, struct sk_buff *skb, int rxp)
+{
+    
+        int pi;
+	int rx_status;
+
+	pi = port->index;
+	memcpy(skb_put(skb, len), card->rx_dma_handle_host, len);
+
+	/* Reset buffer descriptor */
+        FST_WRB ( card, rxDescrRing[pi][rxp].bits, DMA_OWN );
+
+        /* Update stats */
+        port->stats.rx_packets++;
+        port->stats.rx_bytes += len;
+
+        /* Push upstream */
+        if ( port->proto == FST_HDLC || port->proto == FST_PPP )
+        {
+                /* Mark for further processing by sPPP module */
+                skb->protocol = htons ( ETH_P_WAN_PPP );
+        }
+        else
+        {
+                /* DEC customer specific protocol (since nothing defined for
+                 * marking raw data), at least one other driver uses this value
+                 * for this purpose.
+                 */
+                skb->protocol = htons ( ETH_P_CUST );
+                skb->pkt_type = PACKET_HOST;
+        }
+        skb->mac.raw = skb->data;
+        skb->dev = port->dev;
+        rx_status = netif_rx ( skb );
+	if (rx_status != NET_RX_SUCCESS)
+	  dbg(DBG_ASS, "Received packet dropped by network layer on port %d\n",
+                 pi);
+        port->dev->last_rx = jiffies;
+}
+
+/*
+ *      Receive a frame through the DMA
+ */
+static inline void
+fst_rx_dma (struct fst_card_info *card, unsigned char *skb, 
+	    unsigned char *mem, int len)
+{
+  /*
+   * This routine will setup the DMA and start it
+   */
+
+  dbg(DBG_RX, "In fst_rx_dma %p %p %d\n", skb, mem, len);
+  if (card->dmarx_in_progress)
+    dbg(DBG_ASS, "In fst_rx_dma while dma in progress\n");
+
+  outl ( (unsigned long)skb, card->pci_conf + DMAPADR0 );   /* Copy to here */
+  outl ( (unsigned long)mem, card->pci_conf + DMALADR0 );   /* from here */
+  outl ( len, card->pci_conf + DMASIZ0 );       /* for this length */
+  outl ( 0x00000000c, card->pci_conf + DMADPR0); /* In this direction */
+
+  /*
+   * We use the dmarx_in_progress flag to flag the channel as busy
+   */
+  card->dmarx_in_progress = 1;
+  outb ( 0x03, card->pci_conf + DMACSR0 );     /* Start the transfer */
+}
+
+/*
+ *      Send a frame through the DMA
+ */
+static inline void
+fst_tx_dma (struct fst_card_info *card, unsigned char *skb, 
+	    unsigned char *mem, int len)
+{
+  /*
+   * This routine will setup the DMA and start it.
+   */
+
+  dbg(DBG_TX, "In fst_tx_dma %p %p %d\n", skb, mem, len);
+  if (card->dmatx_in_progress)
+    dbg(DBG_ASS, "In fst_tx_dma while dma in progress\n");
+
+  outl ( (unsigned long)skb, card->pci_conf + DMAPADR1 );  /* Copy from here */
+  outl ( (unsigned long)mem, card->pci_conf + DMALADR1 );  /* to here */
+  outl ( len, card->pci_conf + DMASIZ1 );       /* for this length */
+  outl ( 0x000000004, card->pci_conf + DMADPR1); /* In this direction */
+
+  /*
+   * We use the dmatx_in_progress to flag the channel as busy
+   */
+  card->dmatx_in_progress = 1;
+  outb ( 0x03, card->pci_conf + DMACSR1 );     /* Start the transfer */
 }
 
 
@@ -496,11 +888,11 @@
         /* Wait for any previous command to complete */
         while ( mbval > NAK )
         {
-                spin_unlock_irqrestore ( &card->card_lock, flags );
+	        spin_unlock_irqrestore ( &card->card_lock, flags );
                 schedule_timeout ( 1 );
                 spin_lock_irqsave ( &card->card_lock, flags );
 
-                if ( ++safety > 1000 )
+                if ( ++safety > 2000 )
                 {
                         printk_err ("Mailbox safety timeout\n");
                         break;
@@ -523,7 +915,7 @@
         {
                 port->txpos  = 0;
                 port->txipos = 0;
-                port->txcnt  = 0;
+                port->start  = 0;
         }
 
         spin_unlock_irqrestore ( &card->card_lock, flags );
@@ -576,7 +968,7 @@
                 FST_WRB ( card, rxDescrRing[pi][i].hadr, (u8)( offset >> 16 ));
                 FST_WRW ( card, rxDescrRing[pi][i].bcnt,
                                         cnv_bcnt ( LEN_RX_BUFFER ));
-                FST_WRW ( card, rxDescrRing[pi][i].mcnt, 0 );
+                FST_WRW ( card, rxDescrRing[pi][i].mcnt, LEN_RX_BUFFER );
                 FST_WRB ( card, rxDescrRing[pi][i].bits, DMA_OWN );
         }
         port->rxpos  = 0;
@@ -610,7 +1002,7 @@
         }
         port->txpos  = 0;
         port->txipos = 0;
-        port->txcnt  = 0;
+        port->start  = 0;
         spin_unlock_irqrestore ( &card->card_lock, flags );
 }
 
@@ -624,25 +1016,34 @@
 
         signals = FST_RDL ( card, v24DebouncedSts[port->index]);
 
-        if ( signals & (( port->hwif == X21 ) ? IPSTS_INDICATE : IPSTS_DCD ))
+        if ( signals & (((port->hwif == X21) || (port->hwif == X21D)) 
+			? IPSTS_INDICATE : IPSTS_DCD ))
         {
-                if ( ! netif_carrier_ok ( port_to_dev ( port )))
+                if ( ! netif_carrier_ok ( port->dev ))
                 {
                         dbg ( DBG_INTR,"DCD active\n");
-                        netif_carrier_on ( port_to_dev ( port ));
+
+                        /* Poke sPPP to renegotiate */
+                        if ( port->proto == FST_HDLC || port->proto == FST_PPP )
+                        {
+                                sppp_reopen ( port->dev );
+                        }
+
+                        netif_carrier_on ( port->dev );
                 }
         }
         else
         {
-                if ( netif_carrier_ok ( port_to_dev ( port )))
+                if ( netif_carrier_ok ( port->dev ))
                 {
                         dbg ( DBG_INTR,"DCD lost\n");
-                        netif_carrier_off ( port_to_dev ( port ));
+                        netif_carrier_off ( port->dev );
                 }
         }
 }
 
 
+
 /*      Rx complete interrupt
  */
 static void
@@ -651,10 +1052,10 @@
         unsigned char dmabits;
         int pi;
         int rxp;
+	int i;
+	int rx_status;
         unsigned short len;
         struct sk_buff *skb;
-        int i;
-
 
         /* Check we have a buffer to process */
         pi  = port->index;
@@ -666,6 +1067,10 @@
                                         pi, rxp );
                 return;
         }
+	if (card->dmarx_in_progress)
+	{
+	        return;
+	}
 
         /* Get buffer length */
         len = FST_RDW ( card, rxDescrRing[pi][rxp].mcnt );
@@ -680,24 +1085,32 @@
                                         len );
         if ( dmabits != ( RX_STP | RX_ENP ) || len > LEN_RX_BUFFER - 2 )
         {
-                port->hdlc.stats.rx_errors++;
+                port->stats.rx_errors++;
 
                 /* Update error stats and discard buffer */
                 if ( dmabits & RX_OFLO )
                 {
-                        port->hdlc.stats.rx_fifo_errors++;
+                        port->stats.rx_fifo_errors++;
+			dbg(DBG_ASS, "Rx fifo error on card %d port %d buffer %d\n", 
+			       card->card_no, port->index, rxp);
                 }
                 if ( dmabits & RX_CRC )
                 {
-                        port->hdlc.stats.rx_crc_errors++;
+                        port->stats.rx_crc_errors++;
+			dbg(DBG_ASS, "Rx crc error on card %d port %d\n",
+			    card->card_no, port->index);
                 }
                 if ( dmabits & RX_FRAM )
                 {
-                        port->hdlc.stats.rx_frame_errors++;
+                        port->stats.rx_frame_errors++;
+			dbg(DBG_ASS, "Rx frame error on card %d port %d\n",
+			    card->card_no, port->index);
                 }
                 if ( dmabits == ( RX_STP | RX_ENP ))
                 {
-                        port->hdlc.stats.rx_length_errors++;
+                        port->stats.rx_length_errors++;
+			dbg(DBG_ASS, "Rx length error (%d) on card %d port %d\n", 
+			       len,card->card_no, port->index);
                 }
 
                 /* Discard buffer descriptors until we see the end of packet
@@ -734,7 +1147,7 @@
         {
                 dbg ( DBG_RX,"intr_rx: can't allocate buffer\n");
 
-                port->hdlc.stats.rx_dropped++;
+                port->stats.rx_dropped++;
 
                 /* Return descriptor to card */
                 FST_WRB ( card, rxDescrRing[pi][rxp].bits, DMA_OWN );
@@ -746,28 +1159,260 @@
                 return;
         }
 
-        memcpy_fromio ( skb_put ( skb, len ),
-                                card->mem + BUF_OFFSET ( rxBuffer[pi][rxp][0]),
-                                len );
+	/*
+	 * We know the length we need to receive, len.
+	 * It's not worth using the DMA for reads of less than
+	 * FST_MIN_DMA_LEN
+	 */
+
+	if ((len < FST_MIN_DMA_LEN) || (card->family == FST_FAMILY_TXP))
+	  {
+		memcpy_fromio ( skb_put ( skb, len ),
+				card->mem + BUF_OFFSET ( rxBuffer[pi][rxp][0]),
+				len );
+
+		/* Reset buffer descriptor */
+		FST_WRB ( card, rxDescrRing[pi][rxp].bits, DMA_OWN );
+
+		/* Update stats */
+		port->stats.rx_packets++;
+		port->stats.rx_bytes += len;
+		
+		/* Push upstream */
+		if ( port->proto == FST_HDLC || port->proto == FST_PPP )
+		  {
+		    /* Mark for further processing by sPPP module */
+		    skb->protocol = htons ( ETH_P_WAN_PPP );
+		  }
+		else
+		  {
+		    /* DEC customer specific protocol (since nothing defined for
+		     * marking raw data), at least one other driver uses this value
+		     * for this purpose.
+		     */
+		    skb->protocol = htons ( ETH_P_CUST );
+		    skb->pkt_type = PACKET_HOST;
+		  }
+		skb->mac.raw = skb->data;
+		skb->dev = port->dev;
+		rx_status = netif_rx ( skb );
+		if (rx_status == NET_RX_DROP)
+		  dbg(DBG_ASS, "Received packet dropped by network layer on port %d\n",
+			 pi);
+		port->dev->last_rx = jiffies;
+	  }
+	else
+	  {
+	    card->dma_skb_rx = skb;
+	    card->dma_port_rx = port;
+	    card->dma_len_rx = len;
+	    card->dma_rxpos = rxp;
+	    fst_rx_dma(card, (char*)card->rx_dma_handle_card, 
+		       (char*)BUF_OFFSET(rxBuffer[pi][rxp][0]), 
+		       len);
+	  }
+	if (rxp != port->rxpos)
+	  {
+	    dbg(DBG_ASS, "About to increment rxpos by more than 1\n");
+	    dbg(DBG_ASS, "rxp = %d rxpos = %d\n", rxp, port->rxpos);
+	  }
+	if ( ++rxp >= NUM_RX_BUFFER )
+	  port->rxpos = 0;
+	else
+	  port->rxpos = rxp;
+}
 
-        /* Reset buffer descriptor */
-        FST_WRB ( card, rxDescrRing[pi][rxp].bits, DMA_OWN );
-        if ( ++rxp >= NUM_RX_BUFFER )
-                port->rxpos = 0;
-        else
-                port->rxpos = rxp;
 
-        /* Update stats */
-        port->hdlc.stats.rx_packets++;
-        port->hdlc.stats.rx_bytes += len;
+/*
+ *      The bottom halfs to the ISR
+ *
+ */
 
-        /* Push upstream */
-        skb->mac.raw = skb->data;
-        skb->dev = hdlc_to_dev ( &port->hdlc );
-        skb->protocol = hdlc_type_trans(skb, skb->dev);
-        netif_rx ( skb );
+static void do_bottom_half_tx (struct fst_card_info *card)
+{
+  struct fst_port_info *port;
+  int pi;
+  int txq_length;
+  struct sk_buff *skb;
+  unsigned long flags;
+
+  /*
+   *  Find a free buffer for the transmit
+   *  Step through each port on this card
+   */
+
+  for ( pi = 0, port = card->ports ; pi < card->nports ; pi++, port++ )
+    {
+      if ( port->dev == NULL || ! port->run )
+	continue;
+
+      while (!(FST_RDB ( card, txDescrRing[pi][port->txpos].bits ) & DMA_OWN)
+	     && !(card->dmatx_in_progress))
+	{
+	  /*
+	   * There doesn't seem to be a txdone event per-se
+	   * We seem to have to deduce it, by checking the DMA_OWN
+	   * bit on the next buffer we think we can use
+	   */
+	  spin_lock_irqsave ( &card->card_lock, flags );
+	  if ((txq_length = port->txqe - port->txqs) < 0)
+	    {
+	      /*
+	       * This is the case where one has wrapped and the
+	       * maths gives us a negative number
+	       */
+	      txq_length = txq_length + FST_TXQ_DEPTH ;
+	    }
+	  spin_unlock_irqrestore ( &card->card_lock, flags );
+	  if (txq_length > 0)
+	    {
+	      /*
+	       * There is something to send
+	       */
+	      spin_lock_irqsave ( &card->card_lock, flags );
+	      skb = port->txq[port->txqs];
+	      port->txqs++;
+	      if (port->txqs == FST_TXQ_DEPTH)
+		{
+		  port->txqs = 0;
+		}
+	      spin_unlock_irqrestore ( &card->card_lock, flags );
+	      /*
+	       * copy the data and set the required indicators on the
+	       * card.
+	       */
+	      FST_WRW ( card, txDescrRing[pi][port->txpos].bcnt, cnv_bcnt ( skb->len ));
+	      if ((skb->len < FST_MIN_DMA_LEN) || (card->family == FST_FAMILY_TXP))
+		{
+	          /* Enqueue the packet with normal io*/
+	          memcpy_toio ( card->mem + BUF_OFFSET ( txBuffer[pi][port->txpos][0]),
+		                skb->data, skb->len );
+		  FST_WRB ( card, txDescrRing[pi][port->txpos].bits, DMA_OWN | TX_STP | TX_ENP );
+		  port->stats.tx_packets++;
+		  port->stats.tx_bytes += skb->len;
+		  port->dev->trans_start = jiffies;
+		}
+	      else
+		{
+	          /* Or do it through dma */
+	          memcpy(card->tx_dma_handle_host, skb->data, skb->len);
+		  card->dma_port_tx = port;
+		  card->dma_len_tx = skb->len;
+		  card->dma_txpos = port->txpos;
+	          fst_tx_dma(card, (char*)card->tx_dma_handle_card, 
+		             (char*)BUF_OFFSET(txBuffer[pi][port->txpos][0]), 
+		             skb->len);
+	        }
+	      if ( ++port->txpos >= NUM_TX_BUFFER )
+		port->txpos = 0;
+	      /*
+	       * If we have flow control on, can we now release it?
+	       */
+	      if (port->start)
+		{
+		  if (txq_length < fst_txq_low)
+		    {
+		      netif_wake_queue ( port->dev );
+		      port->start = 0;
+		    }
+		}
+	      dev_kfree_skb ( skb );
+	    }
+	  else
+	    {
+	      /*
+	       * Nothing to send so break out of the while loop
+	       */
+	      break;
+	    }
+	}
+    }
+}
+
+static void do_bottom_half_rx (struct fst_card_info *card)
+{
+  struct fst_port_info *port;
+  int pi;
+  int rx_count=0;
+
+  /* Check for rx completions on all ports on this card */
+  for ( pi = 0, port = card->ports ; pi < card->nports ; pi++, port++ )
+    {
+      //rx_count = 0;
+      if ( port->dev == NULL || ! port->run )
+	continue;
+      while (!( FST_RDB ( card, rxDescrRing[pi][port->rxpos].bits )
+		& DMA_OWN ) && !(card->dmarx_in_progress))
+	{
+	  if (rx_count > fst_max_reads)
+	    {
+	      /*
+	       * Don't spend forever in receive processing
+	       * Schedule another event
+	       */
+	      queue_task(&card->card_isr_task, &tq_immediate); 
+	      mark_bh(IMMEDIATE_BH); /* Note that this call must follow queue_task */
+	      //pi = card->nports;
+	      break;  /* Leave the loop */
+	    }
+	  fst_intr_rx ( card, port );
+	  rx_count++;
+	}
+    }
+}
+
+
+static void
+fst_bh_task_1 ( void *card_ptr)
+{
+  do_bottom_half_tx(card_ptr);
+  do_bottom_half_rx(card_ptr);
+}
+
+static void
+fst_bh_task_2 ( void *card_ptr)
+{
+  do_bottom_half_rx(card_ptr);
+  do_bottom_half_tx(card_ptr);
+}
+
+static void
+fst_bh_task_3 ( void *card_ptr)
+{
+  do_bottom_half_rx(card_ptr);
+  do_bottom_half_tx(card_ptr);
+}
+
+static void
+fst_bh_task_4 ( void *card_ptr)
+{
+  do_bottom_half_rx(card_ptr);
+  do_bottom_half_tx(card_ptr);
+}
+
+
+static void
+fst_bh_task_tx_1 ( void *card_ptr)
+{
+  do_bottom_half_tx(card_ptr);
+}
+
+static void
+fst_bh_task_tx_2 ( void *card_ptr)
+{
+  do_bottom_half_tx(card_ptr);
+}
 
-        port_to_dev ( port )->last_rx = jiffies;
+static void
+fst_bh_task_tx_3 ( void *card_ptr)
+{
+  do_bottom_half_tx(card_ptr);
+}
+
+static void
+fst_bh_task_tx_4 ( void *card_ptr)
+{
+  do_bottom_half_tx(card_ptr);
 }
 
 
@@ -783,7 +1428,9 @@
         int rdidx;                      /* Event buffer indices */
         int wridx;
         int event;                      /* Actual event for processing */
-        int pi;
+	unsigned int dma_intcsr=0;
+	unsigned int do_card_interrupt;
+	unsigned int int_retry_count;
 
         if (( card = dev_id ) == NULL )
         {
@@ -791,100 +1438,151 @@
                 return;
         }
 
+	/*
+	 * Check to see if the interrupt was for this card
+	 * return if not
+	 * Note that the call to clear the interrupt is important
+	 */
         dbg ( DBG_INTR,"intr: %d %p\n", irq, card );
-
-        spin_lock ( &card->card_lock );
+	if (card->state != FST_RUNNING)
+	  {
+	    printk_err("FarSync: Interrupt received for card %d in a non running state (%d)\n", card->card_no, card->state);
+
+	    /* 
+	     * It is possible to really be running, i.e. we have re-loaded
+	     * a running card
+	     * Clear and reprime the interrupt source 
+	     */
+	    fst_clear_intr ( card );
+	    return;
+	  }
 
         /* Clear and reprime the interrupt source */
         fst_clear_intr ( card );
 
-        /* Set the software acknowledge */
-        FST_WRB ( card, interruptHandshake, 0xEE );
-
+	/*
+	 * Is the interrupt for this card (handshake == 1)
+	 */
+	do_card_interrupt = 0;
+	if (FST_RDB( card, interruptHandshake) == 1)
+	  {
+	    do_card_interrupt += FST_CARD_INT;
+	    /* Set the software acknowledge */
+	    FST_WRB ( card, interruptHandshake, 0xEE );
+	  }
+	if (card->family == FST_FAMILY_TXU)
+	  {
+	    /*
+	     * Is it a DMA Interrupt
+	     */
+	    dma_intcsr = inl (card->pci_conf + INTCSR_9054);
+	    if (dma_intcsr & 0x00200000)
+	      {
+		/*
+		 * DMA Channel 0 (Rx transfer complete)
+		 */
+		dbg(DBG_RX, "DMA Rx xfer complete\n");
+		outb( 0x8, card->pci_conf + DMACSR0);
+		fst_rx_dma_complete (card, card->dma_port_rx, card->dma_len_rx,
+				     card->dma_skb_rx, card->dma_rxpos);
+		card->dmarx_in_progress = 0;
+		do_card_interrupt += FST_RX_DMA_INT;
+	      }
+	    if (dma_intcsr & 0x00400000)
+	      {
+		/*
+		 * DMA Channel 1 (Tx transfer complete)
+		 */
+		dbg(DBG_TX, "DMA Tx xfer complete\n");
+		outb( 0x8, card->pci_conf + DMACSR1);
+		fst_tx_dma_complete (card, card->dma_port_tx, card->dma_len_tx,
+				     card->dma_txpos);
+                card->dmatx_in_progress = 0;
+		do_card_interrupt += FST_TX_DMA_INT;
+	      }
+	  }
+	
+	/*
+	 * Have we been missing Interrupts
+	 */
+	int_retry_count = FST_RDL( card, interruptRetryCount);
+	if (int_retry_count)
+	  {
+	    dbg(DBG_ASS, "Missed %d interrupts\n", int_retry_count);
+	    FST_WRL( card, interruptRetryCount, 0);
+	  }
+
+	if (!do_card_interrupt)
+	  {
+	    return;
+	  }
+
+	/* Scehdule the bottom half of the ISR */
+	queue_task(&card->card_isr_task, &tq_immediate); 
+	mark_bh(IMMEDIATE_BH); /* Note that this call must follow 
+				  queue_task */
+	
         /* Drain the event queue */
-        rdidx = FST_RDB ( card, interruptEvent.rdindex );
-        wridx = FST_RDB ( card, interruptEvent.wrindex );
+        rdidx = FST_RDB ( card, interruptEvent.rdindex ) & 0x1f;
+        wridx = FST_RDB ( card, interruptEvent.wrindex ) & 0x1f;
         while ( rdidx != wridx )
-        {
-                event = FST_RDB ( card, interruptEvent.evntbuff[rdidx]);
-
-                port = &card->ports[event & 0x03];
-
+	  {
+	    event = FST_RDB ( card, interruptEvent.evntbuff[rdidx]);
+	    port = &card->ports[event & 0x03];
+	    
                 dbg ( DBG_INTR,"intr: %x\n", event );
-
+		
                 switch ( event )
-                {
-                case CTLA_CHG:
-                case CTLB_CHG:
-                case CTLC_CHG:
-                case CTLD_CHG:
-                        if ( port->run )
-                                fst_intr_ctlchg ( card, port );
-                        break;
-
-                case ABTA_SENT:
-                case ABTB_SENT:
-                case ABTC_SENT:
-                case ABTD_SENT:
-                        dbg ( DBG_TX,"Abort complete port %d\n", event & 0x03 );
-                        break;
-
-                case TXA_UNDF:
-                case TXB_UNDF:
-                case TXC_UNDF:
-                case TXD_UNDF:
-                        /* Difficult to see how we'd get this given that we
-                         * always load up the entire packet for DMA.
-                         */
-                        dbg ( DBG_TX,"Tx underflow port %d\n", event & 0x03 );
-                        port->hdlc.stats.tx_errors++;
-                        port->hdlc.stats.tx_fifo_errors++;
-                        break;
-
-                case INIT_CPLT:
-                        dbg ( DBG_INIT,"Card init OK intr\n");
-                        break;
-
-                case INIT_FAIL:
-                        dbg ( DBG_INIT,"Card init FAILED intr\n");
-                        card->state = FST_IFAILED;
-                        break;
-
-                default:
-                        printk_err ("intr: unknown card event code. ignored\n");
-                        break;
+		  {
+		  case CTLA_CHG:
+		  case CTLB_CHG:
+		  case CTLC_CHG:
+		  case CTLD_CHG:
+		    if ( port->run && port->dev != NULL )
+		      fst_intr_ctlchg ( card, port );
+		    break;
+		    
+		  case ABTA_SENT:
+		  case ABTB_SENT:
+		  case ABTC_SENT:
+		  case ABTD_SENT:
+		    dbg (DBG_TX,"Abort complete port %d\n", port->index );
+		    break;
+		    
+		  case TXA_UNDF:
+		  case TXB_UNDF:
+		  case TXC_UNDF:
+		  case TXD_UNDF:
+		    /* Difficult to see how we'd get this given that we
+		     * always load up the entire packet for DMA.
+		     */
+		    dbg (DBG_TX,"Tx underflow port %d\n", port->index );
+		    
+		    port->stats.tx_errors++;
+		    port->stats.tx_fifo_errors++;
+		    dbg(DBG_ASS, "Tx underflow on card %d port %d\n",
+			card->card_no, port->index);
+		    break;
+
+		  case INIT_CPLT:
+		    dbg ( DBG_INIT,"Card init OK intr\n");
+		    break;
+		    
+		  case INIT_FAIL:
+		    dbg ( DBG_INIT,"Card init FAILED intr\n");
+		    card->state = FST_IFAILED;
+		    break;
+		    
+		  default:
+		    printk_err ("intr: unknown card event code. ignored\n");
+		    break;
                 }
-
+		
                 /* Bump and wrap the index */
                 if ( ++rdidx >= MAX_CIRBUFF )
-                        rdidx = 0;
-        }
+		  rdidx = 0;
+	  }
         FST_WRB ( card, interruptEvent.rdindex, rdidx );
-
-        for ( pi = 0, port = card->ports ; pi < card->nports ; pi++, port++ )
-        {
-                if ( ! port->run )
-                        continue;
-
-                /* Check for rx completions */
-                while ( ! ( FST_RDB ( card, rxDescrRing[pi][port->rxpos].bits )
-                                                                & DMA_OWN ))
-                {
-                        fst_intr_rx ( card, port );
-                }
-
-                /* Check for Tx completions */
-                while ( port->txcnt > 0 && ! ( FST_RDB ( card,
-                        txDescrRing[pi][port->txipos].bits ) & DMA_OWN ))
-                {
-                        --port->txcnt;
-                        if ( ++port->txipos >= NUM_TX_BUFFER )
-                                port->txipos = 0;
-                        netif_wake_queue ( port_to_dev ( port ));
-                }
-        }
-
-        spin_unlock ( &card->card_lock );
 }
 
 
@@ -942,28 +1640,165 @@
 
 
 static int
+fst_change_mtu ( struct net_device *dev, int new_mtu )
+{
+        if ( new_mtu < 128 || new_mtu > FST_MAX_MTU )
+                return -EINVAL;
+        dev->mtu = new_mtu;
+        return 0;
+}
+
+
+/* Sooner or later you can't avoid a forward declaration */
+static int fst_ioctl ( struct net_device *dev, struct ifreq *ifr, int cmd );
+
+static int
+switch_proto ( struct fst_port_info *port, int new_proto )
+{
+        int err;
+        int orig_mtu;
+        struct net_device *dev;
+
+        dev = port->dev;
+
+        /* Turn off sPPP module ? */
+        if (( new_proto != FST_HDLC && new_proto != FST_PPP )
+                && ( port->proto == FST_HDLC || port->proto == FST_PPP ))
+        {
+	        /*
+		 * Only close if we have opened before
+		 */
+                if ( port->pppdev.dev != NULL)
+		{
+                    sppp_close ( port->pppdev.dev );
+                    sppp_detach ( port->pppdev.dev );
+		}
+
+                /* Reset some fields overwritten by sPPP */
+                dev->hard_header     = NULL;
+                dev->rebuild_header  = NULL;
+                dev->tx_queue_len    = FST_TX_QUEUE_LEN;
+                dev->type            = ARPHRD_MYTYPE;
+                dev->addr_len        = 0;
+                dev->hard_header_len = 0;
+                dev->do_ioctl        = fst_ioctl;
+                dev->change_mtu      = fst_change_mtu;
+                dev->flags           = IFF_POINTOPOINT|IFF_NOARP;
+
+                return 0;
+        }
+
+        /* Turn on sPPP ? */
+        if (( new_proto == FST_HDLC || new_proto == FST_PPP )
+                && ( port->proto != FST_HDLC && port->proto != FST_PPP ))
+        {
+	        /*
+		 * I don't think we need this, as the way to return
+		 * to non-raw mode is to do ifdown/ifup on the
+		 * interface.  All of this is done in the ifup
+		 * processing
+		 */
+	        return 0;
+                orig_mtu = dev->mtu;
+
+                /* Attach to sync PPP module */
+                port->pppdev.dev = dev;
+                sppp_attach ( &port->pppdev );
+
+                if ( orig_mtu < dev->mtu )
+                        dev->change_mtu ( dev, orig_mtu );
+
+                /* Claw back the ioctl routine. We promise to be good and call
+                 * the sync PPP routines once we've eliminated our functions.
+                 */
+                dev->do_ioctl = fst_ioctl;
+
+                /* Set the mode */
+                if ( new_proto == FST_HDLC )
+                {
+                        err = sppp_do_ioctl ( port->pppdev.dev, NULL,
+                                                                SPPPIOCCISCO );
+                }
+                else
+                {
+                        err = sppp_do_ioctl ( port->pppdev.dev, NULL,
+                                                                SPPPIOCPPP );
+                }
+
+                /* Open the device */
+                if ( err == 0 )
+                {
+                        (void) sppp_open ( port->dev );
+                }
+
+                return err;
+        }
+
+        /* Switch sPPP mode to that desired */
+        err = 0;
+        if ( new_proto == FST_HDLC && port->pppdev.dev != NULL )
+        {
+                err = sppp_do_ioctl ( port->pppdev.dev, NULL, SPPPIOCCISCO );
+        }
+        else if ( new_proto == FST_PPP && port->pppdev.dev != NULL )
+        {
+                err = sppp_do_ioctl ( port->pppdev.dev, NULL, SPPPIOCPPP );
+        }
+
+        /* Anything else is switching from one raw mode to another which is
+         * basically a NOP
+         */
+
+        return err;
+}
+
+
+static int
 set_conf_from_info ( struct fst_card_info *card, struct fst_port_info *port,
                 struct fstioc_info *info )
 {
         int err;
 
-        /* Set things according to the user set valid flags.
-         * Several of the old options have been invalidated/replaced by the
-         * generic HDLC package.
-         */
+        /* Set things according to the user set valid flags */
         err = 0;
         if ( info->valid & FSTVAL_PROTO )
-                err = -EINVAL;
+        {
+                if ( port->proto != info->proto )
+                {
+                        err = switch_proto ( port, info->proto );
+                        if ( err == 0 )
+                                port->proto = info->proto;
+                }
+        }
         if ( info->valid & FSTVAL_CABLE )
-                err = -EINVAL;
+        {
+                FST_WRB ( card, portConfig[port->index].lineInterface,
+                                        info->lineInterface );
+                port->hwif = info->lineInterface;
+        }
         if ( info->valid & FSTVAL_SPEED )
-                err = -EINVAL;
-
+        {
+                FST_WRL ( card, portConfig[port->index].lineSpeed,
+                                        info->lineSpeed );
+                FST_WRB ( card, portConfig[port->index].internalClock,
+                                        info->internalClock );
+                FST_WRB ( card, portConfig[port->index].transparentMode,
+                                        0 );
+        }
+        if ( info->valid & FSTVAL_PHASE )
+	{
+                FST_WRB ( card, portConfig[port->index].invertClock,
+                                        info->invertClock );
+	}
         if ( info->valid & FSTVAL_MODE )
+        {
                 FST_WRW ( card, cardMode, info->cardMode );
+        }
 #if FST_DEBUG
         if ( info->valid & FSTVAL_DEBUG )
+        {
                 fst_debug_mask = info->debug;
+        }
 #endif
 
         return err;
@@ -981,7 +1816,7 @@
         info->nports = card->nports;
         info->type   = card->type;
         info->state  = card->state;
-        info->proto  = FST_GEN_HDLC;
+        info->proto  = port->proto;
         info->index  = i;
 #if FST_DEBUG
         info->debug  = fst_debug_mask;
@@ -1000,113 +1835,37 @@
         info->lineInterface = FST_RDW ( card, portConfig[i].lineInterface );
         info->internalClock = FST_RDB ( card, portConfig[i].internalClock );
         info->lineSpeed     = FST_RDL ( card, portConfig[i].lineSpeed );
+	info->invertClock   = FST_RDB ( card, portConfig[i].invertClock );
         info->v24IpSts      = FST_RDL ( card, v24IpSts[i] );
         info->v24OpSts      = FST_RDL ( card, v24OpSts[i] );
         info->clockStatus   = FST_RDW ( card, clockStatus[i] );
         info->cableStatus   = FST_RDW ( card, cableStatus );
         info->cardMode      = FST_RDW ( card, cardMode );
         info->smcFirmwareVersion  = FST_RDL ( card, smcFirmwareVersion );
-}
-
-
-static int
-fst_set_iface ( struct fst_card_info *card, struct fst_port_info *port,
-                struct ifreq *ifr )
-{
-        sync_serial_settings sync;
-        int i;
-
-        if (copy_from_user (&sync, ifr->ifr_settings.ifs_ifsu.sync,
-			    sizeof (sync)))
-                return -EFAULT;
-
-        if ( sync.loopback )
-                return -EINVAL;
-
-        i = port->index;
-
-        switch (ifr->ifr_settings.type)
-        {
-        case IF_IFACE_V35:
-                FST_WRW ( card, portConfig[i].lineInterface, V35 );
-                port->hwif = V35;
-                break;
-
-        case IF_IFACE_V24:
-                FST_WRW ( card, portConfig[i].lineInterface, V24 );
-                port->hwif = V24;
-                break;
-
-        case IF_IFACE_X21:
-                FST_WRW ( card, portConfig[i].lineInterface, X21 );
-                port->hwif = X21;
-                break;
-
-        case IF_IFACE_SYNC_SERIAL:
-                break;
 
-        default:
-                return -EINVAL;
-        }
-
-        switch ( sync.clock_type )
-        {
-        case CLOCK_EXT:
-                FST_WRB ( card, portConfig[i].internalClock, EXTCLK );
-                break;
-
-        case CLOCK_INT:
-                FST_WRB ( card, portConfig[i].internalClock, INTCLK );
-                break;
-
-        default:
-                return -EINVAL;
-        }
-        FST_WRL ( card, portConfig[i].lineSpeed, sync.clock_rate );
-        return 0;
-}
-
-static int
-fst_get_iface ( struct fst_card_info *card, struct fst_port_info *port,
-                struct ifreq *ifr )
-{
-        sync_serial_settings sync;
-        int i;
-
-        /* First check what line type is set, we'll default to reporting X.21
-         * if nothing is set as IF_IFACE_SYNC_SERIAL implies it can't be
-         * changed
-         */
-        switch ( port->hwif )
-        {
-        case V35:
-                ifr->ifr_settings.type = IF_IFACE_V35;
-                break;
-        case V24:
-                ifr->ifr_settings.type = IF_IFACE_V24;
-                break;
-        case X21:
-        default:
-                ifr->ifr_settings.type = IF_IFACE_X21;
-                break;
-        }
-
-	if (ifr->ifr_settings.size < sizeof(sync)) {
-		ifr->ifr_settings.size = sizeof(sync); /* data size wanted */
-		return -ENOBUFS;
-	}
-
-        i = port->index;
-        sync.clock_rate = FST_RDL ( card, portConfig[i].lineSpeed );
-        /* Lucky card and linux use same encoding here */
-        sync.clock_type = FST_RDB ( card, portConfig[i].internalClock );
-        sync.loopback = 0;
-
-        if (copy_to_user (ifr->ifr_settings.ifs_ifsu.sync, &sync,
-			  sizeof(sync)))
-                return -EFAULT;
-
-        return 0;
+	/*
+	 * The T2U can report cable presence for both A or B
+	 * in bits 0 and 1 of cableStatus.  See which port we are and 
+	 * do the mapping.
+	 */
+ 	if (card->family == FST_FAMILY_TXU)
+	  {
+	    if (port->index == 0)
+	      {
+		/*
+		 * Port A
+		 */
+		info->cableStatus = info->cableStatus & 1;
+	      }
+	    else
+	      {
+		/*
+		 * Port B
+		 */
+		info->cableStatus = info->cableStatus >> 1;
+		info->cableStatus = info->cableStatus & 1;
+	      }
+	  }
 }
 
 
@@ -1121,7 +1880,7 @@
 
         dbg ( DBG_IOCTL,"ioctl: %x, %p\n", cmd, ifr->ifr_data );
 
-        port = dev_to_port ( dev );
+        port = dev->priv;
         card = port->card;
 
         if ( !capable ( CAP_NET_ADMIN ))
@@ -1158,7 +1917,7 @@
                  * when going over the top
                  */
                 if ( wrthdr.size > FST_MEMSIZE || wrthdr.offset > FST_MEMSIZE
-				|| wrthdr.size + wrthdr.offset > FST_MEMSIZE )
+                                || wrthdr.size + wrthdr.offset > FST_MEMSIZE )
                 {
                         return -ENXIO;
                 }
@@ -1196,7 +1955,7 @@
                         if ( card->state == FST_RUNNING )
                         {
                                 spin_lock_irqsave ( &card->card_lock, flags );
-                                fst_clear_intr ( card );
+                                fst_enable_intr ( card );
                                 FST_WRB ( card, interruptHandshake, 0xEE );
                                 spin_unlock_irqrestore ( &card->card_lock,
                                                                 flags );
@@ -1218,9 +1977,11 @@
 
         case FSTSETCONF:
 
-                /* Most of the setting have been moved to the generic ioctls
-                 * this just covers debug and board ident mode now
-                 */
+                if(card->state != FST_RUNNING)
+	        {
+		  printk_err("FarSync: Attempt to configure card %d in non-running state (%d)\n", card->card_no, card->state);
+	                return -EIO;
+	        }
                 if ( copy_from_user ( &info,  ifr->ifr_data, sizeof ( info )))
                 {
                         return -EFAULT;
@@ -1228,25 +1989,12 @@
 
                 return set_conf_from_info ( card, port, &info );
 
-        case SIOCWANDEV:
-                switch (ifr->ifr_settings.type)
-                {
-                case IF_GET_IFACE:
-                        return fst_get_iface ( card, port, ifr );
-
-                case IF_IFACE_SYNC_SERIAL:
-                case IF_IFACE_V35:
-                case IF_IFACE_V24:
-                case IF_IFACE_X21:
-                        return fst_set_iface ( card, port, ifr );
-
-                default:
-                        return hdlc_ioctl ( dev, ifr, cmd );
-                }
-
         default:
-                /* Not one of ours. Pass through to HDLC package */
-                return hdlc_ioctl ( dev, ifr, cmd );
+                /* Not one of ours. Pass it through to sPPP package */
+                if ( port->proto == FST_HDLC || port->proto == FST_PPP )
+                        return sppp_do_ioctl ( dev, ifr, cmd );
+                else
+                        return -EINVAL;
         }
 }
 
@@ -1277,12 +2025,13 @@
                 port->run = 1;
 
                 signals = FST_RDL ( port->card, v24DebouncedSts[port->index]);
-                if ( signals & (( port->hwif == X21 ) ? IPSTS_INDICATE
-                                                      : IPSTS_DCD ))
-                        netif_carrier_on ( port_to_dev ( port ));
+                if ( signals & (((port->hwif == X21) || (port->hwif == X21D))
+				? IPSTS_INDICATE : IPSTS_DCD ))
+                        netif_carrier_on ( port->dev );
                 else
-                        netif_carrier_off ( port_to_dev ( port ));
+                        netif_carrier_off ( port->dev );
         }
+
 }
 
 static void
@@ -1308,15 +2057,64 @@
 static int
 fst_open ( struct net_device *dev )
 {
+        struct fst_card_info *card;
+        struct fst_port_info *port;
+        int orig_mtu;
         int err;
 
-        err = hdlc_open ( dev_to_hdlc ( dev ));
-        if ( err )
-                return err;
-
         MOD_INC_USE_COUNT;
 
-        fst_openport ( dev_to_port ( dev ));
+        port = dev->priv;
+        card = port->card;
+
+        switch ( port->proto )
+        {
+        case FST_HDLC:
+        case FST_PPP:
+
+                orig_mtu = dev->mtu;
+
+                /* Attach to sync PPP module */
+                port->pppdev.dev = dev;
+                sppp_attach ( &port->pppdev );
+
+                if ( orig_mtu < dev->mtu )
+                        dev->change_mtu ( dev, orig_mtu );
+
+                /* Claw back the ioctl routine. We promise to be good and call
+                 * the sync PPP routines once we've eliminated our functions.
+                 */
+                dev->do_ioctl = fst_ioctl;
+
+                err = sppp_do_ioctl ( dev, NULL, port->proto == FST_HDLC
+                                                ? SPPPIOCCISCO : SPPPIOCPPP );
+                if ( err )
+		{
+			sppp_detach ( dev );
+			MOD_DEC_USE_COUNT;
+			return err;
+		}
+
+                err = sppp_open ( dev );
+                if ( err )
+		{
+			sppp_detach ( dev );
+			MOD_DEC_USE_COUNT;
+			return err;
+		}
+                break;
+
+        case FST_MONITOR:
+        case FST_RAW:
+                break;
+
+        default:
+                dbg ( DBG_OPEN,"open: Unknown proto %d\n", port->proto );
+                break;
+        }
+
+        fst_openport ( port );
+
         netif_wake_queue ( dev );
         return 0;
 }
@@ -1324,19 +2122,42 @@
 static int
 fst_close ( struct net_device *dev )
 {
-        netif_stop_queue ( dev );
-        fst_closeport ( dev_to_port ( dev ));
-        hdlc_close ( dev_to_hdlc  ( dev ));
-        MOD_DEC_USE_COUNT;
-        return 0;
-}
+        struct fst_port_info *port;
+        struct fst_card_info *card;
+	unsigned char tx_dma_done;
+	unsigned char rx_dma_done;
 
-static int
-fst_attach ( hdlc_device *hdlc, unsigned short encoding, unsigned short parity )
-{
-        /* Setting currently fixed in FarSync card so we check and forget */
-        if ( encoding != ENCODING_NRZ || parity != PARITY_CRC16_PR1_CCITT )
-                return -EINVAL;
+        port = dev->priv;
+	card = port->card;
+
+	tx_dma_done = inb ( card->pci_conf + DMACSR1 );
+	rx_dma_done = inb ( card->pci_conf + DMACSR0 );
+	dbg(DBG_ASS, "Port Close: tx_dma_in_progress = %d (%x) rx_dma_in_progress = %d (%x)\n",
+	       card->dmatx_in_progress, tx_dma_done, 
+	       card->dmarx_in_progress, rx_dma_done);
+
+
+	netif_stop_queue ( dev );
+        switch ( port->proto )
+        {
+        case FST_HDLC:
+        case FST_PPP:
+                sppp_close ( dev );
+                sppp_detach ( dev );
+                break;
+
+        case FST_MONITOR:
+        case FST_RAW:
+                break;
+
+        default:
+                dbg ( DBG_OPEN,"close: Unknown proto %d\n", port->proto );
+                break;
+        }
+
+        fst_closeport ( port );
+
+        MOD_DEC_USE_COUNT;
         return 0;
 }
 
@@ -1345,19 +2166,20 @@
 fst_tx_timeout ( struct net_device *dev )
 {
         struct fst_port_info *port;
+        struct fst_card_info *card;
 
-        dbg ( DBG_INTR | DBG_TX,"tx_timeout\n");
-
-        port = dev_to_port ( dev );
-
-        port->hdlc.stats.tx_errors++;
-        port->hdlc.stats.tx_aborted_errors++;
+        port = dev->priv;
+        card = port->card;
 
-        if ( port->txcnt > 0 )
-                fst_issue_cmd ( port, ABORTTX );
+        port->stats.tx_errors++;
+        port->stats.tx_aborted_errors++;
+	dbg(DBG_ASS, "Tx timeout card %d port %d\n", 
+	    card->card_no, port->index);
+        fst_issue_cmd ( port, ABORTTX );
 
         dev->trans_start = jiffies;
         netif_wake_queue ( dev );
+	port->start = 0;
 }
 
 
@@ -1366,70 +2188,104 @@
 {
         struct fst_card_info *card;
         struct fst_port_info *port;
-        unsigned char dmabits;
         unsigned long flags;
-        int pi;
-        int txp;
+	int txq_length;
 
-        port = dev_to_port ( dev );
+        port = dev->priv;
         card = port->card;
 
+        /* Drop packet if in monitor (rx only) mode */
+        if ( port->proto == FST_MONITOR )
+        {
+                dev_kfree_skb ( skb );
+                return 0;
+        }
+
         /* Drop packet with error if we don't have carrier */
         if ( ! netif_carrier_ok ( dev ))
         {
                 dev_kfree_skb ( skb );
-                port->hdlc.stats.tx_errors++;
-                port->hdlc.stats.tx_carrier_errors++;
+                port->stats.tx_errors++;
+                port->stats.tx_carrier_errors++;
+		dbg(DBG_ASS, "No carrier on card %d por %d\n",
+		    card->card_no, port->index);
                 return 0;
         }
 
         /* Drop it if it's too big! MTU failure ? */
         if ( skb->len > LEN_TX_BUFFER )
         {
-                dbg ( DBG_TX,"Packet too large %d vs %d\n", skb->len,
+                dbg ( DBG_ASS,"Packet too large %d vs %d\n", skb->len,
                                                 LEN_TX_BUFFER );
                 dev_kfree_skb ( skb );
-                port->hdlc.stats.tx_errors++;
+                port->stats.tx_errors++;
                 return 0;
         }
 
-        /* Check we have a buffer */
-        pi = port->index;
+	/*
+	 * We are always going to queue the packet
+	 * so that the bottom half is the only place we tx from
+	 * Check there is room in the port txq
+	 */
         spin_lock_irqsave ( &card->card_lock, flags );
-        txp = port->txpos;
-        dmabits = FST_RDB ( card, txDescrRing[pi][txp].bits );
-        if ( dmabits & DMA_OWN )
-        {
-                spin_unlock_irqrestore ( &card->card_lock, flags );
-                dbg ( DBG_TX,"Out of Tx buffers\n");
-                dev_kfree_skb ( skb );
-                port->hdlc.stats.tx_errors++;
-                return 0;
-        }
-        if ( ++port->txpos >= NUM_TX_BUFFER )
-                port->txpos = 0;
-
-        if ( ++port->txcnt >= NUM_TX_BUFFER )
-                netif_stop_queue ( dev );
-
-        /* Release the card lock before we copy the data as we now have
-         * exclusive access to the buffer.
-         */
-        spin_unlock_irqrestore ( &card->card_lock, flags );
+	if ((txq_length = port->txqe - port->txqs) < 0)
+	  {
+	    /*
+	     * This is the case where the next free has wrapped but the
+	     * last used hasn't
+	     */
+	    txq_length = txq_length + FST_TXQ_DEPTH;
+	  }
+	spin_unlock_irqrestore ( &card->card_lock, flags );
+	if (txq_length > fst_txq_high)
+	  {
+	    /*
+	     * We have got enough buffers in the pipeline.  Ask the network
+	     * layer to stop sending frames down
+	     */
+	    netif_stop_queue ( dev );
+	    port->start = 1;   /* I'm using this to signal stop sent up */
+	  }
+
+	if (txq_length == FST_TXQ_DEPTH - 1)
+	  {
+	    /*
+	     * This shouldn't have happened but such is life
+	     */
+	    dev_kfree_skb ( skb );
+	    port->stats.tx_errors++;
+	    dbg(DBG_ASS, "Tx queue overflow card %d port %d\n",
+		card->card_no, port->index);
+	    return 0;
+	  }
+
+	/*
+	 * queue the buffer
+	 */
+        spin_lock_irqsave ( &card->card_lock, flags );
+	port->txq[port->txqe] = skb;
+	port->txqe++;
+	if (port->txqe == FST_TXQ_DEPTH)
+	  port->txqe = 0;
+	spin_unlock_irqrestore ( &card->card_lock, flags );
+	
+	/* Scehdule the bottom half which now does transmit processing */
+	queue_task(&card->card_tx_task, &tq_immediate); 
+	mark_bh(IMMEDIATE_BH); /* Note that this call must follow queue_task */
 
-        /* Enqueue the packet */
-        memcpy_toio ( card->mem + BUF_OFFSET ( txBuffer[pi][txp][0]),
-                                                skb->data, skb->len );
-        FST_WRW ( card, txDescrRing[pi][txp].bcnt, cnv_bcnt ( skb->len ));
-        FST_WRB ( card, txDescrRing[pi][txp].bits, DMA_OWN | TX_STP | TX_ENP );
+	return 0;
+}
 
-        port->hdlc.stats.tx_packets++;
-        port->hdlc.stats.tx_bytes += skb->len;
 
-        dev_kfree_skb ( skb );
+static struct net_device_stats *
+fst_get_stats ( struct net_device *dev )
+{
+        struct fst_port_info *port;
 
-        dev->trans_start = jiffies;
-        return 0;
+        if (( port = dev->priv ) != NULL )
+                return &port->stats;
+        else
+                return NULL;
 }
 
 
@@ -1443,7 +2299,10 @@
 static char *type_strings[] __devinitdata = {
         "no hardware",                  /* Should never be seen */
         "FarSync T2P",
-        "FarSync T4P"
+        "FarSync T4P",
+	"FarSync T1U",
+	"FarSync T2U",
+	"FarSync T4U"
 };
 
 static void __devinit
@@ -1459,13 +2318,34 @@
          */
         for ( i = 0 ; i < card->nports ; i++ )
         {
+                card->ports[i].if_ptr = &card->ports[i].pppdev;
                 card->ports[i].card   = card;
                 card->ports[i].index  = i;
+                card->ports[i].proto  = FST_HDLC;
                 card->ports[i].run    = 0;
 
-                dev = hdlc_to_dev ( &card->ports[i].hdlc );
+                dev = kmalloc ( sizeof ( struct net_device ), GFP_KERNEL );
+                if ( dev == NULL )
+                {
+                        printk_err ("Cannot allocate net_device for port %d\n",
+                                        i );
+                        /* No point going any further */
+                        card->nports = i;
+                        break;
+                }
+                memset ( dev, 0, sizeof ( struct net_device ));
+                card->ports[i].dev = dev;
 
-                /* Fill in the net device info */
+                if ( dev_alloc_name ( dev, FST_NDEV_NAME "%d") < 0 )
+                {
+                        printk_err ("Cannot allocate i/f name for port %d\n",
+                                        i );
+                        kfree ( dev );
+                        card->nports = i;
+                        break;
+                }
+
+                /* Fill in remainder of the net device info */
                                 /* Since this is a PCI setup this is purely
                                  * informational. Give them the buffer addresses
                                  * and basic card I/O.
@@ -1481,19 +2361,26 @@
                 dev->base_addr   = card->pci_conf;
                 dev->irq         = card->irq;
 
-                dev->tx_queue_len          = FST_TX_QUEUE_LEN;
-                dev->open                  = fst_open;
-                dev->stop                  = fst_close;
-                dev->do_ioctl              = fst_ioctl;
-                dev->watchdog_timeo        = FST_TX_TIMEOUT;
-                dev->tx_timeout            = fst_tx_timeout;
-                card->ports[i].hdlc.attach = fst_attach;
-                card->ports[i].hdlc.xmit   = fst_start_xmit;
-
-                if (( err = register_hdlc_device ( &card->ports[i].hdlc )) < 0 )
-                {
-                        printk_err ("Cannot register HDLC device for port %d"
-                                    " (errno %d)\n", i, -err );
+                dev->get_stats          = fst_get_stats;
+                dev->mtu                = FST_DEF_MTU;
+                dev->change_mtu         = fst_change_mtu;
+                dev->priv               = &card->ports[i];
+                dev->tx_queue_len       = FST_TX_QUEUE_LEN;
+                dev->type               = ARPHRD_MYTYPE;
+                dev->addr_len           = 0;
+                dev->open               = fst_open;
+                dev->stop               = fst_close;
+                dev->hard_start_xmit    = fst_start_xmit;
+                dev->do_ioctl           = fst_ioctl;
+                dev->watchdog_timeo     = FST_TX_TIMEOUT;
+                dev->tx_timeout         = fst_tx_timeout;
+                dev->flags              = IFF_POINTOPOINT|IFF_NOARP;
+
+                if (( err = register_netdev ( dev )) < 0 )
+                {
+                        printk_err ("Cannot register %s (errno %d)\n",
+                                        dev->name, -err );
+                        kfree ( dev );
                         card->nports = i;
                         break;
                 }
@@ -1502,9 +2389,32 @@
         spin_lock_init ( &card->card_lock );
 
         printk ( KERN_INFO "%s-%s: %s IRQ%d, %d ports\n",
-                        hdlc_to_dev(&card->ports[0].hdlc)->name,
-                        hdlc_to_dev(&card->ports[card->nports-1].hdlc)->name,
+                        card->ports[0].dev->name,
+                        card->ports[card->nports-1].dev->name,
                         type_strings[card->type], card->irq, card->nports );
+
+	if (card->family == FST_FAMILY_TXU)
+	  {
+	    /*
+	     * Allocate a dma buffer for transmit and receives
+	     */
+	    card->rx_dma_handle_host = 
+	      pci_alloc_consistent(card->device, FST_MAX_MTU, 
+				   &card->rx_dma_handle_card);
+	    if (card->rx_dma_handle_host == NULL)
+	      {
+		printk_err("farsync: Could not allocate rx dma buffer\n");
+		return;
+	      }
+	    card->tx_dma_handle_host = 
+	      pci_alloc_consistent(card->device, FST_MAX_MTU,
+				   &card->tx_dma_handle_card);
+	    if (card->tx_dma_handle_host == NULL)
+	      {
+		printk_err("farsync: Could not allocate tx dma buffer\n");
+		return;
+	      }
+	  }
 }
 
 
@@ -1516,16 +2426,38 @@
 fst_add_one ( struct pci_dev *pdev, const struct pci_device_id *ent )
 {
         static int firsttime_done = 0;
+	static int no_of_cards_added = 0;
         struct fst_card_info *card;
         int err = 0;
+	int i;
 
         if ( ! firsttime_done )
         {
                 printk ( KERN_INFO "FarSync X21 driver " FST_USER_VERSION
-                                " (c) 2001 FarSite Communications Ltd.\n");
+                                " (c) 2001-2002 FarSite Communications Ltd.\n");
                 firsttime_done = 1;
         }
 
+	/*
+	 * We are going to be clever and allow certain cards not to be
+	 * configured.  An exclude list can be provided in /etc/modules.conf
+	 */
+	if (fst_excluded_cards != 0)
+	  {
+	    /*
+	     * There are cards to exclude
+	     *
+	     */
+	    for (i=0; i< fst_excluded_cards; i++)
+	      {
+		if ((pdev->devfn)>>3 == fst_excluded_list[i])
+		  {
+		    printk("FarSync PCI device %d not assigned\n", (pdev->devfn)>>3);
+		    return -EBUSY;
+		  }
+	      }
+	  }
+
         /* Allocate driver private data */
         card = kmalloc ( sizeof ( struct fst_card_info ),  GFP_KERNEL);
         if (card == NULL)
@@ -1536,6 +2468,13 @@
         }
         memset ( card, 0, sizeof ( struct fst_card_info ));
 
+        /* Try to enable the device */
+        if (( err = pci_enable_device ( pdev )) != 0 )
+        {
+                printk_err ("Failed to enable card. Err %d\n", -err );
+                goto error_free_card;
+        }
+
         /* Record info we need*/
         card->irq         = pdev->irq;
         card->pci_conf    = pci_resource_start ( pdev, 1 );
@@ -1543,23 +2482,88 @@
         card->phys_ctlmem = pci_resource_start ( pdev, 3 );
 
         card->type        = ent->driver_data;
-        card->nports      = ( ent->driver_data == FST_TYPE_T2P ) ? 2 : 4;
+	card->family       = (( ent->driver_data == FST_TYPE_T2P ) ||
+                             ( ent->driver_data == FST_TYPE_T4P ) ) 
+	                     ? FST_FAMILY_TXP : FST_FAMILY_TXU;
+	if ( ent->driver_data == FST_TYPE_T1U )
+	  card->nports = 1;
+	else
+	  card->nports      = (( ent->driver_data == FST_TYPE_T2P ) || 
+			       ( ent->driver_data == FST_TYPE_T2U) ) ? 2 : 4;
 
         card->state       = FST_UNINIT;
+	card->device      = pdev;
 
         dbg ( DBG_PCI,"type %d nports %d irq %d\n", card->type,
                         card->nports, card->irq );
         dbg ( DBG_PCI,"conf %04x mem %08x ctlmem %08x\n",
                         card->pci_conf, card->phys_mem, card->phys_ctlmem );
 
+	/*
+	 * Initialise the task queue information
+	 *
+	 */
+	memset (&card->card_isr_task, 0, sizeof(struct tq_struct));
+	card->card_isr_task.data = card;            /* The data structure for the card */
+	card->card_tx_task.data = card;
+	switch (no_of_cards_added)
+	  {
+	  case 0:
+	    {
+	      card->card_isr_task.routine = fst_bh_task_1; 
+	      card->card_tx_task.routine = fst_bh_task_tx_1;
+	      break;
+	    }
+
+	  case 1:
+	    {
+	      card->card_isr_task.routine = fst_bh_task_2; 
+	      card->card_tx_task.routine = fst_bh_task_tx_2;
+	      break;
+	    }
+
+	  case 2:
+	    {
+	      card->card_isr_task.routine = fst_bh_task_3; 
+	      card->card_tx_task.routine = fst_bh_task_tx_3;
+	      break;
+	    }
+
+	  case 3:
+	    {
+	      card->card_isr_task.routine = fst_bh_task_4; 
+	      card->card_tx_task.routine = fst_bh_task_tx_4;
+	      break;
+	    }
+
+	  default:
+	    {
+	      printk_err("Could not set up bottom half for card %d\n", no_of_cards_added+1);
+	      break;
+	    }
+	  }
+
         /* Check we can get access to the memory and I/O regions */
-        if ( ! request_region ( card->pci_conf, 0x80,"PLX config regs"))
-        {
+	if (card->family == FST_FAMILY_TXU)
+	  {
+	    if ( ! request_region ( card->pci_conf, 0x100,"PLX 9054 config regs"))
+	      {
+                printk_err ("Unable to get config I/O @ 0x%04X\n",
+			    card->pci_conf );
+                err = -ENODEV;
+                goto error_free_card;
+	      }
+	  }
+	else
+	  {
+            if ( ! request_region ( card->pci_conf, 0x80,"PLX 9050/2 config regs"))
+              {
                 printk_err ("Unable to get config I/O @ 0x%04X\n",
                                                 card->pci_conf );
                 err = -ENODEV;
                 goto error_free_card;
-        }
+             }
+          }
         if ( ! request_mem_region ( card->phys_mem, FST_MEMSIZE,"Shared RAM"))
         {
                 printk_err ("Unable to get main memory @ 0x%08X\n",
@@ -1575,12 +2579,6 @@
                 goto error_release_mem;
         }
 
-        /* Try to enable the device */
-        if (( err = pci_enable_device ( pdev )) != 0 )
-        {
-                printk_err ("Failed to enable card. Err %d\n", -err );
-                goto error_release_ctlmem;
-        }
 
         /* Get virtual addresses of memory regions */
         if (( card->mem = ioremap ( card->phys_mem, FST_MEMSIZE )) == NULL )
@@ -1601,6 +2599,9 @@
         fst_cpureset ( card );
         card->state = FST_RESET;
 
+	/* Initialise DMA (if required) */
+	fst_init_dma ( card );
+
         /* Register the interrupt handler */
         if ( request_irq ( card->irq, fst_intr, SA_SHIRQ, FST_DEV_NAME, card ))
         {
@@ -1612,8 +2613,13 @@
 
         /* Record driver data for later use */
         pci_set_drvdata(pdev, card);
+	if (!pci_dma_supported(pdev, 0xffffffff))
+	  {
+	    printk("Can't do DMA on this device\n");
+	  }
 
         /* Remainder of card setup */
+	card->card_no = no_of_cards_added++;  /* Record instance and bump it */
         fst_init_card ( card );
 
         return 0;                       /* Success */
@@ -1654,7 +2660,8 @@
 
         for ( i = 0 ; i < card->nports ; i++ )
         {
-                unregister_hdlc_device ( &card->ports[i].hdlc );
+                unregister_netdev ( card->ports[i].dev );
+                kfree ( card->ports[i].dev );
         }
 
         fst_disable_intr ( card );
@@ -1665,16 +2672,36 @@
 
         release_mem_region ( card->phys_ctlmem, 0x10 );
         release_mem_region ( card->phys_mem, FST_MEMSIZE );
-        release_region ( card->pci_conf, 0x80 );
-
-        kfree ( card );
+	if (card->family == FST_FAMILY_TXU)
+	  {
+	    release_region ( card->pci_conf, 0x100 );
+	  }
+	else
+	  {
+	    release_region ( card->pci_conf, 0x80 );
+	  }
+
+	if ( card->family == FST_FAMILY_TXU)
+	  {
+	    /*
+	     * Free dma buffers
+	     */
+	    pci_free_consistent(card->device, 2048, card->rx_dma_handle_host, 
+				card->rx_dma_handle_card);
+	    pci_free_consistent(card->device, 2048, card->tx_dma_handle_host, 
+				card->tx_dma_handle_card);
+	  }
 }
 
 static struct pci_driver fst_driver = {
         name:           FST_NAME,
         id_table:       fst_pci_dev_id,
         probe:          fst_add_one,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,16)
         remove:         __devexit_p(fst_remove_one),
+#else
+        remove:         fst_remove_one,
+#endif
         suspend:        NULL,
         resume:         NULL,
 };
@@ -1694,3 +2721,7 @@
 module_init ( fst_init );
 module_exit ( fst_cleanup_module );
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,9)
+MODULE_LICENSE("GPL");
+#endif
+/* End $Id$ */
diff -ruNP linux-2.4.24/drivers/net/wan/farsync.h linux-2.4.24-p/drivers/net/wan/farsync.h
--- linux-2.4.24/drivers/net/wan/farsync.h	Fri Jun 13 16:51:35 2003
+++ linux-2.4.24-p/drivers/net/wan/farsync.h	Tue Jan  6 19:59:48 2004
@@ -32,8 +32,13 @@
  *      A short common prefix is useful for routines within the driver to avoid
  *      conflict with other similar drivers and I chosen to use "fst_" for this
  *      purpose (FarSite T-series).
+ *
+ *      Finally the device driver needs a short network interface name. Since
+ *      "hdlc" is already in use I've chosen the even less informative "sync"
+ *      for the present.
  */
 #define FST_NAME                "fst"           /* In debug/info etc */
+#define FST_NDEV_NAME           "sync"          /* For net interface */
 #define FST_DEV_NAME            "farsync"       /* For misc interfaces */
 
 
@@ -45,7 +50,7 @@
  *      have individual versions (or IDs) that move much faster than the
  *      the release version as individual updates are tracked.
  */
-#define FST_USER_VERSION        "0.09"
+#define FST_USER_VERSION        "1.02"
 
 
 /*      Ioctl call command values
@@ -110,6 +115,8 @@
         unsigned short cableStatus;     /* lsb: 0=> present, 1=> absent */
         unsigned short cardMode;        /* lsb: LED id mode */
         unsigned short debug;           /* Debug flags */
+        unsigned char  transparentMode; /* Not used always 0 */
+        unsigned char  invertClock;     /* Invert clock feature for syncing */
 };
 
 /* "valid" bitmask */
@@ -131,13 +138,21 @@
                                          */
 #define FSTVAL_PROTO    0x00000200      /* proto */
 #define FSTVAL_MODE     0x00000400      /* cardMode */
+#define FSTVAL_PHASE    0x00000800      /* Clock phase */
 #define FSTVAL_DEBUG    0x80000000      /* debug */
-#define FSTVAL_ALL      0x000007FF      /* Note: does not include DEBUG flag */
+#define FSTVAL_ALL      0x00000FFF      /* Note: does not include DEBUG flag */
 
 /* "type" */
 #define FST_TYPE_NONE   0               /* Probably should never happen */
 #define FST_TYPE_T2P    1               /* T2P X21 2 port card */
 #define FST_TYPE_T4P    2               /* T4P X21 4 port card */
+#define FST_TYPE_T1U    3               /* T1U X21 1 port card */
+#define FST_TYPE_T2U    4               /* T2U X21 2 port card */
+#define FST_TYPE_T4U    5               /* T4U X21 4 port card */
+
+/* "family" */
+#define FST_FAMILY_TXP  0               /* T2P or T4P */
+#define FST_FAMILY_TXU  1               /* T1U or T2U or T4U */
 
 /* "state" */
 #define FST_UNINIT      0               /* Raw uninitialised state following
@@ -155,6 +170,7 @@
 #define V24             1
 #define X21             2
 #define V35             3
+#define X21D            4
 
 /* "proto" */
 #define FST_HDLC        1               /* Cisco compatible HDLC */
diff -ruNP linux-2.4.24/fs/proc/root.c linux-2.4.24-p/fs/proc/root.c
--- linux-2.4.24/fs/proc/root.c	Sat Aug  3 02:39:45 2002
+++ linux-2.4.24-p/fs/proc/root.c	Tue Jan  6 19:59:48 2004
@@ -140,6 +140,7 @@
 EXPORT_SYMBOL(proc_mkdir);
 EXPORT_SYMBOL(create_proc_entry);
 EXPORT_SYMBOL(remove_proc_entry);
+EXPORT_SYMBOL(proc_get_inode);
 EXPORT_SYMBOL(proc_root);
 EXPORT_SYMBOL(proc_root_fs);
 EXPORT_SYMBOL(proc_net);
diff -ruNP linux-2.4.24/include/linux/byteorder/generic.h linux-2.4.24-p/include/linux/byteorder/generic.h
--- linux-2.4.24/include/linux/byteorder/generic.h	Fri Nov 28 19:26:21 2003
+++ linux-2.4.24-p/include/linux/byteorder/generic.h	Tue Jan  6 19:59:48 2004
@@ -122,7 +122,6 @@
 #define be16_to_cpus __be16_to_cpus
 #endif
 
-#if defined(__KERNEL__)
 /*
  * Handle ntohl and suches. These have various compatibility
  * issues - like we want to give the prototype even though we
@@ -146,12 +145,17 @@
  * Do the prototypes. Somebody might want to take the
  * address or some such sick thing..
  */
+#if defined(__KERNEL__) || (defined(__GLIBC__) && __GLIBC__ >= 2)
 extern __u32			ntohl(__u32);
 extern __u32			htonl(__u32);
+#else
+extern unsigned long int	htonl(unsigned short int);
+extern unsigned long int	ntohl(unsigned short int);
+#endif
 extern unsigned short int	ntohs(unsigned short int);
 extern unsigned short int	htons(unsigned short int);
 
-#if defined(__GNUC__) && defined(__OPTIMIZE__)
+#if defined(__GNUC__) //#&& defined(__OPTIMIZE__)
 
 #define ___htonl(x) __cpu_to_be32(x)
 #define ___htons(x) __cpu_to_be16(x)
@@ -164,8 +168,6 @@
 #define ntohs(x) ___ntohs(x)
 
 #endif /* OPTIMIZE */
-
-#endif /* KERNEL */
 
 
 #endif /* _LINUX_BYTEORDER_GENERIC_H */
