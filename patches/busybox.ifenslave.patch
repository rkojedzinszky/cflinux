--- busybox-1.10.4/networking/ifenslave.c	2008-06-25 12:55:22.000000000 +0200
+++ busybox-1.10.4/networking/ifenslave.c.new	2008-07-09 10:05:28.000000000 +0200
@@ -1,8 +1,4 @@
 /* Mode: C;
- *
- * Mini ifenslave implementation for busybox
- * Copyright (C) 2005 by Marc Leeman <marc.leeman@barco.com>
- *
  * ifenslave.c: Configure network interfaces for parallel routing.
  *
  *	This program controls the Linux implementation of running multiple
@@ -98,43 +94,100 @@
  *	   set version to 1.1.0
  */
 
-#include "libbb.h"
-
+#define APP_VERSION	"1.1.0"
+#define APP_RELDATE	"December 1, 2003"
+#define APP_NAME	"ifenslave"
+
+static char *version =
+APP_NAME ".c:v" APP_VERSION " (" APP_RELDATE ")\n"
+"o Donald Becker (becker@cesdis.gsfc.nasa.gov).\n"
+"o Detach support added on 2000/10/02 by Willy Tarreau (willy at meta-x.org).\n"
+"o 2.4 kernel support added on 2001/02/16 by Chad N. Tindel\n"
+"  (ctindel at ieee dot org).\n";
+
+static const char *usage_msg =
+"Usage: ifenslave [-f] <master-if> <slave-if> [<slave-if>...]\n"
+"       ifenslave -d   <master-if> <slave-if> [<slave-if>...]\n"
+"       ifenslave -c   <master-if> <slave-if>\n";
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <linux/if.h>
 #include <net/if_arp.h>
+#include <linux/if_ether.h>
 #include <linux/if_bonding.h>
 #include <linux/sockios.h>
+#include "busybox.h"
 
-typedef unsigned long long u64; /* hack, so we may include kernel's ethtool.h */
-typedef uint32_t u32;           /* ditto */
-typedef uint16_t u16;           /* ditto */
-typedef uint8_t u8;             /* ditto */
+typedef unsigned long long u64;	/* hack, so we may include kernel's ethtool.h */
+typedef __uint32_t u32;		/* ditto */
+typedef __uint16_t u16;		/* ditto */
+typedef __uint8_t u8;		/* ditto */
 #include <linux/ethtool.h>
 
-
-struct dev_data {
-	struct ifreq mtu, flags, hwaddr;
+static
+struct option longopts[] = {
+	/* { name  has_arg  *flag  val } */
+	{"all-interfaces",	0, 0, 'a'},	/* Show all interfaces. */
+	{"change-active",	0, 0, 'c'},	/* Change the active slave.  */
+	{"detach",		0, 0, 'd'},	/* Detach a slave interface. */
+	{"force",		0, 0, 'f'},	/* Force the operation. */
+	{"usage",		0, 0, 'u'},	/* Give usage */
+	{"verbose",		0, 0, 'v'},	/* Report each action taken. */
+	{"version",		0, 0, 'V'},	/* Emit version information. */
+	{ 0, 0, 0, 0}
 };
 
+/* Command-line flags. */
+static unsigned int
+opt_a = 0,	/* Show-all-interfaces flag. */
+opt_c = 0,	/* Change-active-slave flag. */
+opt_d = 0,	/* Detach a slave interface. */
+opt_f = 0,	/* Force the operation. */
+opt_u = 0,	/* Usage */
+opt_v = 0,	/* Verbose flag. */
+opt_V = 0;	/* Version */
+
+static int skfd = -1;		/* AF_INET socket for ioctl() calls.*/
+static int abi_ver = 0;	/* userland - kernel ABI version */
+static int hwaddr_set = 0;	/* Master's hwaddr is set */
+static int saved_errno;
+
+static struct ifreq master_mtu, master_flags, master_hwaddr;
+static struct ifreq slave_mtu, slave_flags, slave_hwaddr;
+
+struct dev_ifr {
+	struct ifreq *req_ifr;
+	char *req_name;
+	int req_type;
+};
 
-enum { skfd = 3 };      /* AF_INET socket for ioctl() calls.*/
-struct globals {
-	unsigned abi_ver;       /* userland - kernel ABI version */
-	smallint hwaddr_set;    /* Master's hwaddr is set */
-	struct dev_data master;
-	struct dev_data slave;
+static struct dev_ifr master_ifra[] = {
+	{&master_mtu,     "SIOCGIFMTU",     SIOCGIFMTU},
+	{&master_flags,   "SIOCGIFFLAGS",   SIOCGIFFLAGS},
+	{&master_hwaddr,  "SIOCGIFHWADDR",  SIOCGIFHWADDR},
+	{NULL, "", 0}
 };
-#define G (*ptr_to_globals)
-#define abi_ver    (G.abi_ver   )
-#define hwaddr_set (G.hwaddr_set)
-#define master     (G.master    )
-#define slave      (G.slave     )
-#define INIT_G() do { \
-        SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
-} while (0)
 
+static struct dev_ifr slave_ifra[] = {
+	{&slave_mtu,     "SIOCGIFMTU",     SIOCGIFMTU},
+	{&slave_flags,   "SIOCGIFFLAGS",   SIOCGIFFLAGS},
+	{&slave_hwaddr,  "SIOCGIFHWADDR",  SIOCGIFHWADDR},
+	{NULL, "", 0}
+};
 
-static void get_drv_info(char *master_ifname);
-static int get_if_settings(char *ifname, struct dev_data *dd);
+static void if_print(char *ifname);
+static int get_drv_info(char *master_ifname);
+static int get_if_settings(char *ifname, struct dev_ifr ifra[]);
 static int get_slave_flags(char *slave_ifname);
 static int set_master_hwaddr(char *master_ifname, struct sockaddr *hwaddr);
 static int set_slave_hwaddr(char *slave_ifname, struct sockaddr *hwaddr);
@@ -144,162 +197,372 @@
 static int set_if_down(char *ifname, short flags);
 static int clear_if_addr(char *ifname);
 static int set_if_addr(char *master_ifname, char *slave_ifname);
-static void change_active(char *master_ifname, char *slave_ifname);
+static int change_active(char *master_ifname, char *slave_ifname);
 static int enslave(char *master_ifname, char *slave_ifname);
 static int release(char *master_ifname, char *slave_ifname);
+#define v_print(fmt, args...)	\
+	if (opt_v)		\
+		fprintf(stderr, fmt, ## args )
 
-
-int ifenslave_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int ifenslave_main(int argc ATTRIBUTE_UNUSED, char **argv)
+int ifenslave_main(int argc, char *argv[]) MAIN_EXTERNALLY_VISIBLE;
+int ifenslave_main(int argc, char *argv[])
 {
-	char *master_ifname, *slave_ifname;
-	int rv;
-	int res;
-	unsigned opt;
-	enum {
-		OPT_c = (1 << 0),
-		OPT_d = (1 << 1),
-		OPT_f = (1 << 2),
-	};
-#if ENABLE_GETOPT_LONG
-	static const char ifenslave_longopts[] ALIGN1 =
-		"change-active" No_argument "c"
-		"detach"        No_argument "d"
-		"force"         No_argument "f"
-	;
-
-	applet_long_options = ifenslave_longopts;
-#endif
-	opt = getopt32(argv, "cdf");
-	argv += optind;
-	if (opt & (opt-1)) /* options check */
-		bb_show_usage();
+	char **spp, *master_ifname, *slave_ifname;
+	int c, i, rv;
+	int res = 0;
+	int exclusive = 0;
 
-	/* Copy the interface name */
-	master_ifname = *argv++;
+	while ((c = getopt_long(argc, argv, "acdfhuvV", longopts, 0)) != EOF) {
+		switch (c) {
+		case 'a': opt_a++; exclusive++; break;
+		case 'c': opt_c++; exclusive++; break;
+		case 'd': opt_d++; exclusive++; break;
+		case 'f': opt_f++; exclusive++; break;
+		case 'u': opt_u++; exclusive++; break;
+		case 'v': opt_v++; break;
+		case 'V': opt_V++; exclusive++; break;
+
+		case '?':
+			fprintf(stderr, usage_msg);
+			res = 2;
+			goto out;
+		}
+	}
+
+	/* options check */
+	if (exclusive > 1) {
+		fprintf(stderr, usage_msg);
+		res = 2;
+		goto out;
+	}
 
-	/* No remaining args means show all interfaces. */
-	if (!master_ifname) {
-		display_interfaces(NULL);
-		return EXIT_SUCCESS;
+	if (opt_v || opt_V) {
+		printf(version);
+		if (opt_V) {
+			res = 0;
+			goto out;
+		}
+	}
+
+	if (opt_u) {
+		printf(usage_msg);
+		res = 0;
+		goto out;
 	}
 
 	/* Open a basic socket */
-	xmove_fd(xsocket(AF_INET, SOCK_DGRAM, 0), skfd);
+	if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+		perror("socket");
+		res = 1;
+		goto out;
+	}
+
+	if (opt_a) {
+		if (optind == argc) {
+			/* No remaining args */
+			/* show all interfaces */
+			if_print((char *)NULL);
+			goto out;
+		} else {
+			/* Just show usage */
+			fprintf(stderr, usage_msg);
+			res = 2;
+			goto out;
+		}
+	}
+
+	/* Copy the interface name */
+	spp = argv + optind;
+	master_ifname = *spp++;
+
+	if (master_ifname == NULL) {
+		fprintf(stderr, usage_msg);
+		res = 2;
+		goto out;
+	}
 
 	/* exchange abi version with bonding module */
-	get_drv_info(master_ifname);
+	res = get_drv_info(master_ifname);
+	if (res) {
+		fprintf(stderr,
+			"Master '%s': Error: handshake with driver failed. "
+			"Aborting\n",
+			master_ifname);
+		goto out;
+	}
+
+	slave_ifname = *spp++;
 
-	slave_ifname = *argv++;
-	if (!slave_ifname) {
-		if (opt & (OPT_d|OPT_c)) {
-			display_interfaces(slave_ifname);
-			return 2; /* why? */
+	if (slave_ifname == NULL) {
+		if (opt_d || opt_c) {
+			fprintf(stderr, usage_msg);
+			res = 2;
+			goto out;
 		}
+
 		/* A single arg means show the
 		 * configuration for this interface
 		 */
-		display_interfaces(master_ifname);
-		return EXIT_SUCCESS;
+		if_print(master_ifname);
+		goto out;
 	}
 
-	res = get_if_settings(master_ifname, &master);
+	res = get_if_settings(master_ifname, master_ifra);
 	if (res) {
 		/* Probably a good reason not to go on */
-		bb_perror_msg_and_die("%s: can't get settings", master_ifname);
+		fprintf(stderr,
+			"Master '%s': Error: get settings failed: %s. "
+			"Aborting\n",
+			master_ifname, strerror(res));
+		goto out;
 	}
 
 	/* check if master is indeed a master;
 	 * if not then fail any operation
 	 */
-	if (!(master.flags.ifr_flags & IFF_MASTER))
-		bb_error_msg_and_die("%s is not a master", master_ifname);
+	if (!(master_flags.ifr_flags & IFF_MASTER)) {
+		fprintf(stderr,
+			"Illegal operation; the specified interface '%s' "
+			"is not a master. Aborting\n",
+			master_ifname);
+		res = 1;
+		goto out;
+	}
 
 	/* check if master is up; if not then fail any operation */
-	if (!(master.flags.ifr_flags & IFF_UP))
-		bb_error_msg_and_die("%s is not up", master_ifname);
+	if (!(master_flags.ifr_flags & IFF_UP)) {
+		fprintf(stderr,
+			"Illegal operation; the specified master interface "
+			"'%s' is not up.\n",
+			master_ifname);
+		res = 1;
+		goto out;
+	}
 
 	/* Only for enslaving */
-	if (!(opt & (OPT_c|OPT_d))) {
-		sa_family_t master_family = master.hwaddr.ifr_hwaddr.sa_family;
+	if (!opt_c && !opt_d) {
+		sa_family_t master_family = master_hwaddr.ifr_hwaddr.sa_family;
+		unsigned char *hwaddr =
+			(unsigned char *)master_hwaddr.ifr_hwaddr.sa_data;
 
 		/* The family '1' is ARPHRD_ETHER for ethernet. */
-		if (master_family != 1 && !(opt & OPT_f)) {
-			bb_error_msg_and_die(
-				"%s is not ethernet-like (-f overrides)",
+		if (master_family != 1 && !opt_f) {
+			fprintf(stderr,
+				"Illegal operation: The specified master "
+				"interface '%s' is not ethernet-like.\n "
+				"This program is designed to work with "
+				"ethernet-like network interfaces.\n "
+				"Use the '-f' option to force the "
+				"operation.\n",
 				master_ifname);
+			res = 1;
+			goto out;
+		}
+
+		/* Check master's hw addr */
+		for (i = 0; i < 6; i++) {
+			if (hwaddr[i] != 0) {
+				hwaddr_set = 1;
+				break;
+			}
+		}
+
+		if (hwaddr_set) {
+			v_print("current hardware address of master '%s' "
+				"is %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x, "
+				"type %d\n",
+				master_ifname,
+				hwaddr[0], hwaddr[1],
+				hwaddr[2], hwaddr[3],
+				hwaddr[4], hwaddr[5],
+				master_family);
 		}
 	}
 
 	/* Accepts only one slave */
-	if (opt & OPT_c) {
+	if (opt_c) {
 		/* change active slave */
 		res = get_slave_flags(slave_ifname);
 		if (res) {
-			bb_perror_msg_and_die(
-				"%s: can't get flags", slave_ifname);
+			fprintf(stderr,
+				"Slave '%s': Error: get flags failed. "
+				"Aborting\n",
+				slave_ifname);
+			goto out;
 		}
-		change_active(master_ifname, slave_ifname);
-		return EXIT_SUCCESS;
-	}
-
-	/* Accept multiple slaves */
-	res = 0;
-	do {
-		if (opt & OPT_d) {
-			/* detach a slave interface from the master */
-			rv = get_slave_flags(slave_ifname);
-			if (rv) {
-				/* Can't work with this slave. */
-				/* remember the error and skip it*/
-				bb_perror_msg(
-					"skipping %s: can't get flags",
-					slave_ifname);
-				res = rv;
-				continue;
-			}
-			rv = release(master_ifname, slave_ifname);
-			if (rv) {
-				bb_perror_msg(
-					"master %s, slave %s: "
-					"can't release",
-					master_ifname, slave_ifname);
-				res = rv;
-			}
-		} else {
-			/* attach a slave interface to the master */
-			rv = get_if_settings(slave_ifname, &slave);
-			if (rv) {
-				/* Can't work with this slave. */
-				/* remember the error and skip it*/
-				bb_perror_msg(
-					"skipping %s: can't get settings",
-					slave_ifname);
-				res = rv;
-				continue;
-			}
-			rv = enslave(master_ifname, slave_ifname);
-			if (rv) {
-				bb_perror_msg(
-					"master %s, slave %s: "
-					"can't enslave",
-					master_ifname, slave_ifname);
-				res = rv;
-			}
+		res = change_active(master_ifname, slave_ifname);
+		if (res) {
+			fprintf(stderr,
+				"Master '%s', Slave '%s': Error: "
+				"Change active failed\n",
+				master_ifname, slave_ifname);
 		}
-	} while ((slave_ifname = *argv++) != NULL);
+	} else {
+		/* Accept multiple slaves */
+		do {
+			if (opt_d) {
+				/* detach a slave interface from the master */
+				rv = get_slave_flags(slave_ifname);
+				if (rv) {
+					/* Can't work with this slave. */
+					/* remember the error and skip it*/
+					fprintf(stderr,
+						"Slave '%s': Error: get flags "
+						"failed. Skipping\n",
+						slave_ifname);
+					res = rv;
+					continue;
+				}
+				rv = release(master_ifname, slave_ifname);
+				if (rv) {
+					fprintf(stderr,
+						"Master '%s', Slave '%s': Error: "
+						"Release failed\n",
+						master_ifname, slave_ifname);
+					res = rv;
+				}
+			} else {
+				/* attach a slave interface to the master */
+				rv = get_if_settings(slave_ifname, slave_ifra);
+				if (rv) {
+					/* Can't work with this slave. */
+					/* remember the error and skip it*/
+					fprintf(stderr,
+						"Slave '%s': Error: get "
+						"settings failed: %s. "
+						"Skipping\n",
+						slave_ifname, strerror(rv));
+					res = rv;
+					continue;
+				}
+				rv = enslave(master_ifname, slave_ifname);
+				if (rv) {
+					fprintf(stderr,
+						"Master '%s', Slave '%s': Error: "
+						"Enslave failed\n",
+						master_ifname, slave_ifname);
+					res = rv;
+				}
+			}
+		} while ((slave_ifname = *spp++) != NULL);
+	}
 
-	if (ENABLE_FEATURE_CLEAN_UP) {
+out:
+	if (skfd >= 0) {
 		close(skfd);
 	}
 
 	return res;
 }
 
-static void get_drv_info(char *master_ifname)
+static short mif_flags;
+
+/* Get the inteface configuration from the kernel. */
+static int if_getconfig(char *ifname)
+{
+	struct ifreq ifr;
+	int metric, mtu;	/* Parameters of the master interface. */
+	struct sockaddr dstaddr, broadaddr, netmask;
+	unsigned char *hwaddr;
+
+	strcpy(ifr.ifr_name, ifname);
+	if (ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0)
+		return -1;
+	mif_flags = ifr.ifr_flags;
+	printf("The result of SIOCGIFFLAGS on %s is %x.\n",
+	       ifname, ifr.ifr_flags);
+
+	strcpy(ifr.ifr_name, ifname);
+	if (ioctl(skfd, SIOCGIFADDR, &ifr) < 0)
+		return -1;
+	printf("The result of SIOCGIFADDR is %2.2x.%2.2x.%2.2x.%2.2x.\n",
+	       ifr.ifr_addr.sa_data[0], ifr.ifr_addr.sa_data[1],
+	       ifr.ifr_addr.sa_data[2], ifr.ifr_addr.sa_data[3]);
+
+	strcpy(ifr.ifr_name, ifname);
+	if (ioctl(skfd, SIOCGIFHWADDR, &ifr) < 0)
+		return -1;
+
+	/* Gotta convert from 'char' to unsigned for printf(). */
+	hwaddr = (unsigned char *)ifr.ifr_hwaddr.sa_data;
+	printf("The result of SIOCGIFHWADDR is type %d  "
+	       "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x.\n",
+	       ifr.ifr_hwaddr.sa_family, hwaddr[0], hwaddr[1],
+	       hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);
+
+	strcpy(ifr.ifr_name, ifname);
+	if (ioctl(skfd, SIOCGIFMETRIC, &ifr) < 0) {
+		metric = 0;
+	} else
+		metric = ifr.ifr_metric;
+
+	strcpy(ifr.ifr_name, ifname);
+	if (ioctl(skfd, SIOCGIFMTU, &ifr) < 0)
+		mtu = 0;
+	else
+		mtu = ifr.ifr_mtu;
+
+	strcpy(ifr.ifr_name, ifname);
+	if (ioctl(skfd, SIOCGIFDSTADDR, &ifr) < 0) {
+		memset(&dstaddr, 0, sizeof(struct sockaddr));
+	} else
+		dstaddr = ifr.ifr_dstaddr;
+
+	strcpy(ifr.ifr_name, ifname);
+	if (ioctl(skfd, SIOCGIFBRDADDR, &ifr) < 0) {
+		memset(&broadaddr, 0, sizeof(struct sockaddr));
+	} else
+		broadaddr = ifr.ifr_broadaddr;
+
+	strcpy(ifr.ifr_name, ifname);
+	if (ioctl(skfd, SIOCGIFNETMASK, &ifr) < 0) {
+		memset(&netmask, 0, sizeof(struct sockaddr));
+	} else
+		netmask = ifr.ifr_netmask;
+
+	return 0;
+}
+
+static void if_print(char *ifname)
+{
+	char buff[1024];
+	struct ifconf ifc;
+	struct ifreq *ifr;
+	int i;
+
+	if (ifname == (char *)NULL) {
+		ifc.ifc_len = sizeof(buff);
+		ifc.ifc_buf = buff;
+		if (ioctl(skfd, SIOCGIFCONF, &ifc) < 0) {
+			perror("SIOCGIFCONF failed");
+			return;
+		}
+
+		ifr = ifc.ifc_req;
+		for (i = ifc.ifc_len / sizeof(struct ifreq); --i >= 0; ifr++) {
+			if (if_getconfig(ifr->ifr_name) < 0) {
+				fprintf(stderr,
+					"%s: unknown interface.\n",
+					ifr->ifr_name);
+				continue;
+			}
+
+			if (((mif_flags & IFF_UP) == 0) && !opt_a) continue;
+			/*ife_print(&ife);*/
+		}
+	} else {
+		if (if_getconfig(ifname) < 0) {
+			fprintf(stderr,
+				"%s: unknown interface.\n", ifname);
+		}
+	}
+}
+
+static int get_drv_info(char *master_ifname)
 {
 	struct ifreq ifr;
 	struct ethtool_drvinfo info;
+	char *endptr;
 
 	memset(&ifr, 0, sizeof(ifr));
 	strncpy(ifr.ifr_name, master_ifname, IFNAMSIZ);
@@ -310,55 +573,77 @@
 	snprintf(info.fw_version, 32, "%d", BOND_ABI_VERSION);
 
 	if (ioctl(skfd, SIOCETHTOOL, &ifr) < 0) {
-		if (errno == EOPNOTSUPP)
-			return;
-		bb_perror_msg_and_die("%s: SIOCETHTOOL error", master_ifname);
+		if (errno == EOPNOTSUPP) {
+			goto out;
+		}
+
+		saved_errno = errno;
+		v_print("Master '%s': Error: get bonding info failed %s\n",
+			master_ifname, strerror(saved_errno));
+		return 1;
 	}
 
-	abi_ver = bb_strtou(info.fw_version, NULL, 0);
-	if (errno)
-		bb_error_msg_and_die("%s: SIOCETHTOOL error", master_ifname);
+	abi_ver = strtoul(info.fw_version, &endptr, 0);
+	if (*endptr) {
+                v_print("Master '%s': Error: got invalid string as an ABI "
+			"version from the bonding module\n",
+			master_ifname);
+		return 1;
+	}
+
+out:
+	v_print("ABI ver is %d\n", abi_ver);
 
-	return;
+	return 0;
 }
 
-static void change_active(char *master_ifname, char *slave_ifname)
+static int change_active(char *master_ifname, char *slave_ifname)
 {
 	struct ifreq ifr;
+	int res = 0;
 
-	if (!(slave.flags.ifr_flags & IFF_SLAVE)) {
-		bb_error_msg_and_die(
-			"%s is not a slave",
+	if (!(slave_flags.ifr_flags & IFF_SLAVE)) {
+		fprintf(stderr,
+			"Illegal operation: The specified slave interface "
+			"'%s' is not a slave\n",
 			slave_ifname);
+		return 1;
 	}
 
 	strncpy(ifr.ifr_name, master_ifname, IFNAMSIZ);
 	strncpy(ifr.ifr_slave, slave_ifname, IFNAMSIZ);
-	if (ioctl(skfd, SIOCBONDCHANGEACTIVE, &ifr) < 0
-	 && ioctl(skfd, BOND_CHANGE_ACTIVE_OLD, &ifr) < 0
-	) {
-		bb_perror_msg_and_die(
-			"master %s, slave %s: can't "
-			"change active",
-			master_ifname, slave_ifname);
+	if ((ioctl(skfd, SIOCBONDCHANGEACTIVE, &ifr) < 0) &&
+	    (ioctl(skfd, BOND_CHANGE_ACTIVE_OLD, &ifr) < 0)) {
+		saved_errno = errno;
+		v_print("Master '%s': Error: SIOCBONDCHANGEACTIVE failed: "
+			"%s\n",
+			master_ifname, strerror(saved_errno));
+		res = 1;
 	}
+
+	return res;
 }
 
 static int enslave(char *master_ifname, char *slave_ifname)
 {
 	struct ifreq ifr;
-	int res;
+	int res = 0;
 
-	if (slave.flags.ifr_flags & IFF_SLAVE) {
-		bb_error_msg(
-			"%s is already a slave",
+	if (slave_flags.ifr_flags & IFF_SLAVE) {
+		fprintf(stderr,
+			"Illegal operation: The specified slave interface "
+			"'%s' is already a slave\n",
 			slave_ifname);
 		return 1;
 	}
 
-	res = set_if_down(slave_ifname, slave.flags.ifr_flags);
-	if (res)
+	res = set_if_down(slave_ifname, slave_flags.ifr_flags);
+	if (res) {
+		fprintf(stderr,
+			"Slave '%s': Error: bring interface down failed\n",
+			slave_ifname);
 		return res;
+	}
 
 	if (abi_ver < 2) {
 		/* Older bonding versions would panic if the slave has no IP
@@ -366,21 +651,27 @@
 		 */
 		res = set_if_addr(master_ifname, slave_ifname);
 		if (res) {
-			bb_perror_msg("%s: can't set address", slave_ifname);
+			fprintf(stderr,
+				"Slave '%s': Error: set address failed\n",
+				slave_ifname);
 			return res;
 		}
 	} else {
 		res = clear_if_addr(slave_ifname);
 		if (res) {
-			bb_perror_msg("%s: can't clear address", slave_ifname);
+			fprintf(stderr,
+				"Slave '%s': Error: clear address failed\n",
+				slave_ifname);
 			return res;
 		}
 	}
 
-	if (master.mtu.ifr_mtu != slave.mtu.ifr_mtu) {
-		res = set_slave_mtu(slave_ifname, master.mtu.ifr_mtu);
+	if (master_mtu.ifr_mtu != slave_mtu.ifr_mtu) {
+		res = set_slave_mtu(slave_ifname, master_mtu.ifr_mtu);
 		if (res) {
-			bb_perror_msg("%s: can't set MTU", slave_ifname);
+			fprintf(stderr,
+				"Slave '%s': Error: set MTU failed\n",
+				slave_ifname);
 			return res;
 		}
 	}
@@ -395,19 +686,26 @@
 			 * hwaddr
 			 */
 			res = set_slave_hwaddr(slave_ifname,
-					       &(master.hwaddr.ifr_hwaddr));
+					       &(master_hwaddr.ifr_hwaddr));
 			if (res) {
-				bb_perror_msg("%s: can't set hw address",
-						slave_ifname);
+				fprintf(stderr,
+					"Slave '%s': Error: set hw address "
+					"failed\n",
+					slave_ifname);
 				goto undo_mtu;
 			}
 
 			/* For old ABI the application needs to bring the
 			 * slave back up
 			 */
-			res = set_if_up(slave_ifname, slave.flags.ifr_flags);
-			if (res)
+			res = set_if_up(slave_ifname, slave_flags.ifr_flags);
+			if (res) {
+				fprintf(stderr,
+					"Slave '%s': Error: bring interface "
+					"down failed\n",
+					slave_ifname);
 				goto undo_slave_mac;
+			}
 		}
 		/* The driver is using a new ABI,
 		 * so the driver takes care of setting
@@ -422,15 +720,22 @@
 			/* For old ABI, the master needs to be
 			 * down before setting it's hwaddr
 			 */
-			res = set_if_down(master_ifname, master.flags.ifr_flags);
-			if (res)
+			res = set_if_down(master_ifname, master_flags.ifr_flags);
+			if (res) {
+				fprintf(stderr,
+					"Master '%s': Error: bring interface "
+					"down failed\n",
+					master_ifname);
 				goto undo_mtu;
+			}
 		}
 
 		res = set_master_hwaddr(master_ifname,
-					&(slave.hwaddr.ifr_hwaddr));
+					&(slave_hwaddr.ifr_hwaddr));
 		if (res) {
-			bb_error_msg("%s: can't set hw address",
+			fprintf(stderr,
+				"Master '%s': Error: set hw address "
+				"failed\n",
 				master_ifname);
 			goto undo_mtu;
 		}
@@ -439,9 +744,14 @@
 			/* For old ABI, bring the master
 			 * back up
 			 */
-			res = set_if_up(master_ifname, master.flags.ifr_flags);
-			if (res)
+			res = set_if_up(master_ifname, master_flags.ifr_flags);
+			if (res) {
+				fprintf(stderr,
+					"Master '%s': Error: bring interface "
+					"up failed\n",
+					master_ifname);
 				goto undo_master_mac;
+			}
 		}
 
 		hwaddr_set = 1;
@@ -450,26 +760,29 @@
 	/* Do the real thing */
 	strncpy(ifr.ifr_name, master_ifname, IFNAMSIZ);
 	strncpy(ifr.ifr_slave, slave_ifname, IFNAMSIZ);
-	if (ioctl(skfd, SIOCBONDENSLAVE, &ifr) < 0
-	 && ioctl(skfd, BOND_ENSLAVE_OLD, &ifr) < 0
-	) {
+	if ((ioctl(skfd, SIOCBONDENSLAVE, &ifr) < 0) &&
+	    (ioctl(skfd, BOND_ENSLAVE_OLD, &ifr) < 0)) {
+		saved_errno = errno;
+		v_print("Master '%s': Error: SIOCBONDENSLAVE failed: %s\n",
+			master_ifname, strerror(saved_errno));
 		res = 1;
 	}
 
-	if (res)
+	if (res) {
 		goto undo_master_mac;
+	}
 
 	return 0;
 
 /* rollback (best effort) */
- undo_master_mac:
-	set_master_hwaddr(master_ifname, &(master.hwaddr.ifr_hwaddr));
+undo_master_mac:
+	set_master_hwaddr(master_ifname, &(master_hwaddr.ifr_hwaddr));
 	hwaddr_set = 0;
 	goto undo_mtu;
- undo_slave_mac:
-	set_slave_hwaddr(slave_ifname, &(slave.hwaddr.ifr_hwaddr));
- undo_mtu:
-	set_slave_mtu(slave_ifname, slave.mtu.ifr_mtu);
+undo_slave_mac:
+	set_slave_hwaddr(slave_ifname, &(slave_hwaddr.ifr_hwaddr));
+undo_mtu:
+	set_slave_mtu(slave_ifname, slave_mtu.ifr_mtu);
 	return res;
 }
 
@@ -478,24 +791,33 @@
 	struct ifreq ifr;
 	int res = 0;
 
-	if (!(slave.flags.ifr_flags & IFF_SLAVE)) {
-		bb_error_msg("%s is not a slave",
+	if (!(slave_flags.ifr_flags & IFF_SLAVE)) {
+		fprintf(stderr,
+			"Illegal operation: The specified slave interface "
+			"'%s' is not a slave\n",
 			slave_ifname);
 		return 1;
 	}
 
 	strncpy(ifr.ifr_name, master_ifname, IFNAMSIZ);
 	strncpy(ifr.ifr_slave, slave_ifname, IFNAMSIZ);
-	if (ioctl(skfd, SIOCBONDRELEASE, &ifr) < 0
-	 && ioctl(skfd, BOND_RELEASE_OLD, &ifr) < 0
-	) {
+	if ((ioctl(skfd, SIOCBONDRELEASE, &ifr) < 0) &&
+	    (ioctl(skfd, BOND_RELEASE_OLD, &ifr) < 0)) {
+		saved_errno = errno;
+		v_print("Master '%s': Error: SIOCBONDRELEASE failed: %s\n",
+			master_ifname, strerror(saved_errno));
 		return 1;
-	}
-	if (abi_ver < 1) {
+	} else if (abi_ver < 1) {
 		/* The driver is using an old ABI, so we'll set the interface
 		 * down to avoid any conflicts due to same MAC/IP
 		 */
-		res = set_if_down(slave_ifname, slave.flags.ifr_flags);
+		res = set_if_down(slave_ifname, slave_flags.ifr_flags);
+		if (res) {
+			fprintf(stderr,
+				"Slave '%s': Error: bring interface "
+				"down failed\n",
+				slave_ifname);
+		}
 	}
 
 	/* set to default mtu */
@@ -504,108 +826,207 @@
 	return res;
 }
 
-static int get_if_settings(char *ifname, struct dev_data *dd)
+static int get_if_settings(char *ifname, struct dev_ifr ifra[])
 {
-	int res;
+	int i;
+	int res = 0;
 
-	strncpy(dd->mtu.ifr_name, ifname, IFNAMSIZ);
-	res = ioctl(skfd, SIOCGIFMTU, &dd->mtu);
-	strncpy(dd->flags.ifr_name, ifname, IFNAMSIZ);
-	res |= ioctl(skfd, SIOCGIFFLAGS, &dd->flags);
-	strncpy(dd->hwaddr.ifr_name, ifname, IFNAMSIZ);
-	res |= ioctl(skfd, SIOCGIFHWADDR, &dd->hwaddr);
+	for (i = 0; ifra[i].req_ifr; i++) {
+		strncpy(ifra[i].req_ifr->ifr_name, ifname, IFNAMSIZ);
+		res = ioctl(skfd, ifra[i].req_type, ifra[i].req_ifr);
+		if (res < 0) {
+			saved_errno = errno;
+			v_print("Interface '%s': Error: %s failed: %s\n",
+				ifname, ifra[i].req_name,
+				strerror(saved_errno));
 
-	return res;
+			return saved_errno;
+		}
+	}
+
+	return 0;
 }
 
 static int get_slave_flags(char *slave_ifname)
 {
-	strncpy(slave.flags.ifr_name, slave_ifname, IFNAMSIZ);
-	return ioctl(skfd, SIOCGIFFLAGS, &slave.flags);
+	int res = 0;
+
+	strncpy(slave_flags.ifr_name, slave_ifname, IFNAMSIZ);
+	res = ioctl(skfd, SIOCGIFFLAGS, &slave_flags);
+	if (res < 0) {
+		saved_errno = errno;
+		v_print("Slave '%s': Error: SIOCGIFFLAGS failed: %s\n",
+			slave_ifname, strerror(saved_errno));
+	} else {
+		v_print("Slave %s: flags %04X.\n",
+			slave_ifname, slave_flags.ifr_flags);
+	}
+
+	return res;
 }
 
 static int set_master_hwaddr(char *master_ifname, struct sockaddr *hwaddr)
 {
+	unsigned char *addr = (unsigned char *)hwaddr->sa_data;
 	struct ifreq ifr;
+	int res = 0;
 
 	strncpy(ifr.ifr_name, master_ifname, IFNAMSIZ);
 	memcpy(&(ifr.ifr_hwaddr), hwaddr, sizeof(struct sockaddr));
-	return ioctl(skfd, SIOCSIFHWADDR, &ifr);
+	res = ioctl(skfd, SIOCSIFHWADDR, &ifr);
+	if (res < 0) {
+		saved_errno = errno;
+		v_print("Master '%s': Error: SIOCSIFHWADDR failed: %s\n",
+			master_ifname, strerror(saved_errno));
+		return res;
+	} else {
+		v_print("Master '%s': hardware address set to "
+			"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x.\n",
+			master_ifname, addr[0], addr[1], addr[2],
+			addr[3], addr[4], addr[5]);
+	}
+
+	return res;
 }
 
 static int set_slave_hwaddr(char *slave_ifname, struct sockaddr *hwaddr)
 {
+	unsigned char *addr = (unsigned char *)hwaddr->sa_data;
 	struct ifreq ifr;
+	int res = 0;
 
 	strncpy(ifr.ifr_name, slave_ifname, IFNAMSIZ);
 	memcpy(&(ifr.ifr_hwaddr), hwaddr, sizeof(struct sockaddr));
-	return ioctl(skfd, SIOCSIFHWADDR, &ifr);
+	res = ioctl(skfd, SIOCSIFHWADDR, &ifr);
+	if (res < 0) {
+		saved_errno = errno;
+
+		v_print("Slave '%s': Error: SIOCSIFHWADDR failed: %s\n",
+			slave_ifname, strerror(saved_errno));
+
+		if (saved_errno == EBUSY) {
+			v_print("  The device is busy: it must be idle "
+				"before running this command.\n");
+		} else if (saved_errno == EOPNOTSUPP) {
+			v_print("  The device does not support setting "
+				"the MAC address.\n"
+				"  Your kernel likely does not support slave "
+				"devices.\n");
+		} else if (saved_errno == EINVAL) {
+			v_print("  The device's address type does not match "
+				"the master's address type.\n");
+		}
+		return res;
+	} else {
+		v_print("Slave '%s': hardware address set to "
+			"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x.\n",
+			slave_ifname, addr[0], addr[1], addr[2],
+			addr[3], addr[4], addr[5]);
+	}
+
+	return res;
 }
 
 static int set_slave_mtu(char *slave_ifname, int mtu)
 {
 	struct ifreq ifr;
+	int res = 0;
 
 	ifr.ifr_mtu = mtu;
 	strncpy(ifr.ifr_name, slave_ifname, IFNAMSIZ);
-	return ioctl(skfd, SIOCSIFMTU, &ifr);
+
+	res = ioctl(skfd, SIOCSIFMTU, &ifr);
+	if (res < 0) {
+		saved_errno = errno;
+		v_print("Slave '%s': Error: SIOCSIFMTU failed: %s\n",
+			slave_ifname, strerror(saved_errno));
+	} else {
+		v_print("Slave '%s': MTU set to %d.\n", slave_ifname, mtu);
+	}
+
+	return res;
 }
 
 static int set_if_flags(char *ifname, short flags)
 {
 	struct ifreq ifr;
+	int res = 0;
 
 	ifr.ifr_flags = flags;
 	strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
-	return ioctl(skfd, SIOCSIFFLAGS, &ifr);
+
+	res = ioctl(skfd, SIOCSIFFLAGS, &ifr);
+	if (res < 0) {
+		saved_errno = errno;
+		v_print("Interface '%s': Error: SIOCSIFFLAGS failed: %s\n",
+			ifname, strerror(saved_errno));
+	} else {
+		v_print("Interface '%s': flags set to %04X.\n", ifname, flags);
+	}
+
+	return res;
 }
 
 static int set_if_up(char *ifname, short flags)
 {
-	int res = set_if_flags(ifname, flags | IFF_UP);
-	if (res)
-		bb_perror_msg("%s: can't up", ifname);
-	return res;
+	return set_if_flags(ifname, flags | IFF_UP);
 }
 
 static int set_if_down(char *ifname, short flags)
 {
-	int res = set_if_flags(ifname, flags & ~IFF_UP);
-	if (res)
-		bb_perror_msg("%s: can't down", ifname);
-	return res;
+	return set_if_flags(ifname, flags & ~IFF_UP);
 }
 
 static int clear_if_addr(char *ifname)
 {
 	struct ifreq ifr;
+	int res = 0;
 
 	strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
 	ifr.ifr_addr.sa_family = AF_INET;
 	memset(ifr.ifr_addr.sa_data, 0, sizeof(ifr.ifr_addr.sa_data));
-	return ioctl(skfd, SIOCSIFADDR, &ifr);
+
+	res = ioctl(skfd, SIOCSIFADDR, &ifr);
+	if (res < 0) {
+		saved_errno = errno;
+		v_print("Interface '%s': Error: SIOCSIFADDR failed: %s\n",
+			ifname, strerror(saved_errno));
+	} else {
+		v_print("Interface '%s': address cleared\n", ifname);
+	}
+
+	return res;
 }
 
 static int set_if_addr(char *master_ifname, char *slave_ifname)
 {
-	static const struct {
+	struct ifreq ifr;
+	int res;
+	unsigned char *ipaddr;
+	int i;
+	struct {
+		char *req_name;
+		char *desc;
 		int g_ioctl;
 		int s_ioctl;
 	} ifra[] = {
-		{ SIOCGIFADDR,    SIOCSIFADDR    },
-		{ SIOCGIFDSTADDR, SIOCSIFDSTADDR },
-		{ SIOCGIFBRDADDR, SIOCSIFBRDADDR },
-		{ SIOCGIFNETMASK, SIOCSIFNETMASK },
+		{"IFADDR", "addr", SIOCGIFADDR, SIOCSIFADDR},
+		{"DSTADDR", "destination addr", SIOCGIFDSTADDR, SIOCSIFDSTADDR},
+		{"BRDADDR", "broadcast addr", SIOCGIFBRDADDR, SIOCSIFBRDADDR},
+		{"NETMASK", "netmask", SIOCGIFNETMASK, SIOCSIFNETMASK},
+		{NULL, NULL, 0, 0},
 	};
 
-	struct ifreq ifr;
-	int res;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ifra); i++) {
+	for (i = 0; ifra[i].req_name; i++) {
 		strncpy(ifr.ifr_name, master_ifname, IFNAMSIZ);
 		res = ioctl(skfd, ifra[i].g_ioctl, &ifr);
 		if (res < 0) {
+			saved_errno = errno;
+
+			v_print("Interface '%s': Error: SIOCG%s failed: %s\n",
+				master_ifname, ifra[i].req_name,
+				strerror(saved_errno));
+
 			ifr.ifr_addr.sa_family = AF_INET;
 			memset(ifr.ifr_addr.sa_data, 0,
 			       sizeof(ifr.ifr_addr.sa_data));
@@ -613,9 +1034,33 @@
 
 		strncpy(ifr.ifr_name, slave_ifname, IFNAMSIZ);
 		res = ioctl(skfd, ifra[i].s_ioctl, &ifr);
-		if (res < 0)
+		if (res < 0) {
+			saved_errno = errno;
+
+			v_print("Interface '%s': Error: SIOCS%s failed: %s\n",
+				slave_ifname, ifra[i].req_name,
+				strerror(saved_errno));
+
 			return res;
+		}
+
+		ipaddr = ifr.ifr_addr.sa_data;
+		v_print("Interface '%s': set IP %s to %d.%d.%d.%d\n",
+			slave_ifname, ifra[i].desc,
+			ipaddr[0], ipaddr[1], ipaddr[2], ipaddr[3]);
 	}
 
 	return 0;
 }
+
+/*
+ * Local variables:
+ *  version-control: t
+ *  kept-new-versions: 5
+ *  c-indent-level: 4
+ *  c-basic-offset: 4
+ *  tab-width: 4
+ *  compile-command: "gcc -Wall -Wstrict-prototypes -O -I/usr/src/linux/include ifenslave.c -o ifenslave"
+ * End:
+ */
+
--- busybox-1.10.4/include/usage.h.orig	2008-07-09 09:21:22.000000000 +0200
+++ busybox-1.10.4/include/usage.h	2008-07-09 10:08:54.000000000 +0200
@@ -1586,31 +1586,9 @@
        "	[up|down] ..."
 
 #define ifenslave_trivial_usage \
-       "[-cdf] master-iface <slave-iface...>"
+	"[-adfrvVXh] <master-interface> < <slave-if> [metric <N>] > ..."
 #define ifenslave_full_usage \
-       "Configure network interfaces for parallel routing\n" \
-     "\nOptions:" \
-     "\n	-c, --change-active	Change active slave" \
-     "\n	-d, --detach		Remove slave interface from bonding device" \
-     "\n	-f, --force		Force, even if interface is not Ethernet" \
-/*   "\n	-r, --receive-slave	Create a receive-only slave" */
-
-#define ifenslave_example_usage \
-       "To create a bond device, simply follow these three steps :\n" \
-       "- ensure that the required drivers are properly loaded :\n" \
-       "  # modprobe bonding ; modprobe <3c59x|eepro100|pcnet32|tulip|...>\n" \
-       "- assign an IP address to the bond device :\n" \
-       "  # ifconfig bond0 <addr> netmask <mask> broadcast <bcast>\n" \
-       "- attach all the interfaces you need to the bond device :\n" \
-       "  # ifenslave bond0 eth0 eth1 eth2\n" \
-       "  If bond0 didn't have a MAC address, it will take eth0's. Then, all\n" \
-       "  interfaces attached AFTER this assignment will get the same MAC addr.\n\n" \
-       "  To detach a dead interface without setting the bond device down :\n" \
-       "   # ifenslave -d bond0 eth1\n\n" \
-       "  To set the bond device down and automatically release all the slaves :\n" \
-       "   # ifconfig bond0 down\n\n" \
-       "  To change active slave :\n" \
-       "   # ifenslave -c bond0 eth0\n" \
+	""
 
 #define ifup_trivial_usage \
        "[-ain"USE_FEATURE_IFUPDOWN_MAPPING("m")"vf] ifaces..."
