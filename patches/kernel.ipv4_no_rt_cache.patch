--- linux-2.6.18.orig/net/ipv4/route.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/route.c	2006-10-22 13:07:56.000000000 +0200
@@ -928,6 +928,7 @@
 	candp = NULL;
 	now = jiffies;
 
+#ifndef CONFIG_IP_NO_ROUTE_CACHE
 	rthp = &rt_hash_table[hash].chain;
 
 	spin_lock_bh(rt_hash_lock_addr(hash));
@@ -991,13 +992,16 @@
 		}
 	}
 
+#endif /* CONFIG_IP_NO_ROUTE_CACHE */
 	/* Try to bind route to arp only if it is output
 	   route or unicast forwarding path.
 	 */
 	if (rt->rt_type == RTN_UNICAST || rt->fl.iif == 0) {
 		int err = arp_bind_neighbour(&rt->u.dst);
 		if (err) {
+#ifndef CONFIG_IP_NO_ROUTE_CACHE
 			spin_unlock_bh(rt_hash_lock_addr(hash));
+#endif /* CONFIG_IP_NO_ROUTE_CACHE */
 
 			if (err != -ENOBUFS) {
 				rt_drop(rt);
@@ -1026,7 +1030,9 @@
 		}
 	}
 
+#ifndef CONFIG_IP_NO_ROUTE_CACHE
 	rt->u.rt_next = rt_hash_table[hash].chain;
+#endif
 #if RT_CACHE_DEBUG >= 2
 	if (rt->u.rt_next) {
 		struct rtable *trt;
@@ -1037,8 +1043,12 @@
 		printk("\n");
 	}
 #endif
+#ifndef CONFIG_IP_NO_ROUTE_CACHE
 	rt_hash_table[hash].chain = rt;
 	spin_unlock_bh(rt_hash_lock_addr(hash));
+#else
+	rt_free(rt);
+#endif
 	*rp = rt;
 	return 0;
 }
@@ -1830,8 +1840,12 @@
 		return err;
 
 	/* put it into the cache */
+#ifndef CONFIG_IP_NO_ROUTE_CACHE
 	hash = rt_hash_code(daddr, saddr ^ (fl->iif << 5));
 	return rt_intern_hash(hash, rth, (struct rtable**)&skb->dst);	
+#else
+	return rt_intern_hash(0, rth, (struct rtable**)&skb->dst);	
+#endif
 }
 
 static inline int ip_mkroute_input(struct sk_buff *skb, 
@@ -1871,8 +1885,12 @@
 			return err;
 
 		/* put it into the cache */
+#ifndef CONFIG_IP_NO_ROUTE_CACHE
 		hash = rt_hash_code(daddr, saddr ^ (fl->iif << 5));
 		err = rt_intern_hash(hash, rth, &rtres);
+#else
+		err = rt_intern_hash(0, rth, &rtres);
+#endif /* CONFIG_IP_NO_ROUTE_CACHE */
 		if (err)
 			return err;
 
@@ -2095,6 +2113,7 @@
 	int iif = dev->ifindex;
 
 	tos &= IPTOS_RT_MASK;
+#ifndef CONFIG_IP_NO_ROUTE_CACHE
 	hash = rt_hash_code(daddr, saddr ^ (iif << 5));
 
 	rcu_read_lock();
@@ -2119,6 +2138,7 @@
 		RT_CACHE_STAT_INC(in_hlist_search);
 	}
 	rcu_read_unlock();
+#endif /* CONFIG_IP_NO_ROUTE_CACHE */
 
 	/* Multicast recognition logic is moved from route cache to here.
 	   The problem was that too many Ethernet cards have broken/missing
--- linux-2.6.18.orig/net/ipv4/Kconfig	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/Kconfig	2006-10-22 15:34:56.000000000 +0200
@@ -85,6 +85,12 @@
 config IP_FIB_HASH
 	def_bool ASK_IP_FIB_HASH || !IP_ADVANCED_ROUTER
 
+config IP_NO_ROUTE_CACHE
+	bool "IP: disable route cache"
+	depends on IP_ADVANCED_ROUTER
+	---help---
+	You can disable the internal route cache used in the Linux kernel, for now only for IPV4.
+
 config IP_MULTIPLE_TABLES
 	bool "IP: policy routing"
 	depends on IP_ADVANCED_ROUTER
