--- rp-pppoe-3.5.orig/src/relay.h	2002-07-08 16:38:24.000000000 +0200
+++ rp-pppoe-3.5/src/relay.h	2005-08-14 16:47:04.000000000 +0200
@@ -17,6 +17,15 @@
 
 #include "pppoe.h"
 
+#if defined(USE_LINUX_PACKET)
+#define SUPPORT_8021Q_VLAN
+#endif
+
+typedef struct PPPoEPacketStruct8021Q {
+	unsigned char vhdr[4];
+	PPPoEPacket packet;
+} PPPoEPacket8021Q;
+
 /* Description for each active Ethernet interface */
 typedef struct InterfaceStruct {
     char name[IFNAMSIZ+1];	/* Interface name */
@@ -24,6 +33,9 @@
     int sessionSock;		/* Socket for session frames */
     int clientOK;		/* Client requests allowed (PADI, PADR) */
     int acOK;			/* AC replies allowed (PADO, PADS) */
+#ifdef SUPPORT_8021Q_VLAN
+    UINT16_t dot1q;			/* This interface is a 802.1Q trunk */
+#endif
     unsigned char mac[ETH_ALEN]; /* MAC address */
 } PPPoEInterface;
 
@@ -34,6 +46,9 @@
     struct SessionStruct *prev;	/* Free list link */
     struct SessionHashStruct *acHash; /* Hash bucket for AC MAC/Session */
     struct SessionHashStruct *clientHash; /* Hash bucket for client MAC/Session */
+#ifdef SUPPORT_8021Q_VLAN
+    UINT16_t dot1qTag;		/* 802.1Q Tag on client side if needed */
+#endif
     unsigned int epoch;		/* Epoch when last activity was seen */
     UINT16_t sesNum;		/* Session number assigned by relay */
 } PPPoESession;
@@ -49,10 +64,41 @@
     PPPoESession *ses;		/* Session data */
 } SessionHash;
 
+#define SERVNAME_HT_SIZE			23
+
+/* PRE-Session data struct, and hashes */
+/* Service-Name hashes */
+typedef struct ServiceNameStruct {
+	struct ServiceNameStruct*		next;
+	void*												serviceName;		/* the service name, not null terminated string */
+	unsigned										serviceNameLen; /* the serviceName's length */
+	unsigned char								serverMac[ETH_ALEN];	/* the server's MAC address */
+	PPPoEInterface const*				interface;			/* the server's interface */
+} ServiceName;
+
+typedef struct PreSessionStruct {
+	struct PreSessionStruct*		next;	/* Free list link */
+	struct PreSessionStruct*		prev; /* Free list link */
+	void*												uniqueID;								/* the unique ID used in the relay-session-id */
+	unsigned int								uniqueIDLen;
+	ServiceName*								SNHT[SERVNAME_HT_SIZE]; /* available serviceNames */
+	unsigned char								clientMac[ETH_ALEN];		/* client's MAC address */
+	PPPoEInterface const*				interface;							/* client's interface */
+	unsigned int								epoch;									/* the epoch when last data was seen */
+#ifdef SUPPORT_8021Q_VLAN
+  UINT16_t dot1qTag;		/* 802.1Q Tag on client side if needed */
+#endif
+} PreSession;
+
 /* Function prototypes */
 
 void relayGotSessionPacket(PPPoEInterface const *i);
 void relayGotDiscoveryPacket(PPPoEInterface const *i);
+#ifdef SUPPORT_8021Q_VLAN
+PPPoEPacket* relayUnTag8021QPacket(PPPoEPacket8021Q* packet, int* size, UINT16_t* dot1qTag);
+PPPoEPacket8021Q* relayTag8021QPacket(PPPoEPacket* packet, int* size, UINT16_t dot1qTag);
+void relayGotTrunkPacket(PPPoEInterface const *i);
+#endif
 PPPoEInterface *findInterface(int sock);
 unsigned int hash(unsigned char const *mac, UINT16_t sesNum);
 SessionHash *findSession(unsigned char const *mac, UINT16_t sesNum);
@@ -61,9 +107,10 @@
 			    PPPoEInterface const *cli,
 			    unsigned char const *acMac,
 			    unsigned char const *cliMac,
-			    UINT16_t acSes);
+			    UINT16_t acSes,
+			    UINT16_t dot1qTag);
 void freeSession(PPPoESession *ses, char const *msg);
-void addInterface(char const *ifname, int clientOK, int acOK);
+void addInterface(char const *ifname, int clientOK, int acOK, int dot1q);
 void usage(char const *progname);
 void initRelay(int nsess);
 void relayLoop(void);
@@ -71,9 +118,9 @@
 void unhash(SessionHash *sh);
 
 void relayHandlePADT(PPPoEInterface const *iface, PPPoEPacket *packet, int size);
-void relayHandlePADI(PPPoEInterface const *iface, PPPoEPacket *packet, int size);
+void relayHandlePADI(PPPoEInterface const *iface, PPPoEPacket *packet, int size, UINT16_t dot1qTag);
 void relayHandlePADO(PPPoEInterface const *iface, PPPoEPacket *packet, int size);
-void relayHandlePADR(PPPoEInterface const *iface, PPPoEPacket *packet, int size);
+void relayHandlePADR(PPPoEInterface const *iface, PPPoEPacket *packet, int size, UINT16_t dot1qTag);
 void relayHandlePADS(PPPoEInterface const *iface, PPPoEPacket *packet, int size);
 
 int addTag(PPPoEPacket *packet, PPPoETag const *tag);
@@ -86,7 +133,8 @@
 		    PPPoEInterface const *iface,
 		    unsigned char const *mac,
 		    PPPoETag const *hostUniq,
-		    char const *errMsg);
+		    char const *errMsg,
+		    UINT16_t dot1qTag);
 
 void alarmHandler(int sig);
 void cleanSessions(void);
--- rp-pppoe-3.5.orig/src/relay.c	2002-07-08 16:38:24.000000000 +0200
+++ rp-pppoe-3.5/src/relay.c	2005-08-14 18:02:01.000000000 +0200
@@ -47,11 +47,51 @@
 #include <unistd.h>
 #endif
 
-
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#ifdef SUPPORT_8021Q_VLAN
+/* This is stolen from /usr/include/linux/if_vlan.h */
+#define VLAN_HLEN	4
+struct vlan_ethhdr {
+   unsigned char	h_dest[ETH_ALEN];	   /* destination eth addr	*/
+   unsigned char	h_source[ETH_ALEN];	   /* source ether addr	*/
+   unsigned short       h_vlan_proto;              /* Should always be 0x8100 */
+   unsigned short       h_vlan_TCI;                /* Encapsulates priority and VLAN ID */
+   unsigned short	h_vlan_encapsulated_proto; /* packet type ID field (or len) */
+};
+#endif
 /* Interfaces (max MAX_INTERFACES) */
 PPPoEInterface Interfaces[MAX_INTERFACES];
 int NumInterfaces;
 
+#define APS_HASHTAB_SIZE	47
+#define PRESESSION_TIMEOUT 5
+
+/* Pre-Session variables */
+PreSession*			FreePreSessions;
+PreSession*			ActivePreSessions[APS_HASHTAB_SIZE];
+
+/* this can be specified on the command line, but this should be enough
+ * specifying a smaller number may have a point in it */
+static unsigned MaxPreSessions = 128;
+
+/* hack for devices which can not handle the Relay-Session-Id tag in
+ * the protocol. I hate these devices. They do not comply with the
+ * PPPoE rfc (2516). This hack tries to guess, which PreSession the
+ * client is talking about. This is to be turned on on the command line */
+typedef struct clMacToPreSessStruct {
+	struct clMacToPreSessStruct*	next;	/* used in linking */
+	unsigned char			clMac[ETH_ALEN];
+	const PreSession*		psess;
+} clMacToPreSess;
+
+clMacToPreSess*				fclMacToPreSess;
+clMacToPreSess**			clMacToPreSessT;
+
+static int				enableClientHack = 0;
+
 /* Relay info */
 int NumSessions;
 int MaxSessions;
@@ -77,6 +117,9 @@
 /* Pipe for breaking select() to initiate periodic cleaning */
 int CleanPipe[2];
 
+/* /dev/urandom fd */
+static int dev_urandom_fd;
+
 /* Our relay: if_index followed by peer_mac */
 #define MY_RELAY_TAG_LEN (sizeof(int) + ETH_ALEN)
 
@@ -94,6 +137,7 @@
 keepDescriptor(int fd)
 {
     int i;
+		if (fd == dev_urandom_fd) return 1;
     if (fd == CleanPipe[0] || fd == CleanPipe[1]) return 1;
     for (i=0; i<NumInterfaces; i++) {
 	if (fd == Interfaces[i].discoverySock ||
@@ -203,9 +247,16 @@
     fprintf(stderr, "   -S if_name     -- Specify interface for PPPoE Server\n");
     fprintf(stderr, "   -C if_name     -- Specify interface for PPPoE Client\n");
     fprintf(stderr, "   -B if_name     -- Specify interface for both clients and server\n");
+#ifdef SUPPORT_8021Q_VLAN
+    fprintf(stderr, "   -V if_name     -- Specify interface for PPPoE Clients over 802.1Q vlan trunk\n");
+#endif
     fprintf(stderr, "   -n nsess       -- Maxmimum number of sessions to relay\n");
+    fprintf(stderr, "   -N nsess       -- Maxmimum number of PreSessions to relay\n");
     fprintf(stderr, "   -i timeout     -- Idle timeout in seconds (0 = no timeout)\n");
     fprintf(stderr, "   -F             -- Do not fork into background\n");
+    fprintf(stderr, "   -H             -- Enable hack for broken devices that do not send the Relay-Session-Id\n");
+    fprintf(stderr, "                     tag back. With this, pppoe-relay tries to find out what Id was forgotten\n");
+    fprintf(stderr, "                     and adds it\n");
     fprintf(stderr, "   -h             -- Print this help message\n");
 
     fprintf(stderr, "\nPPPoE Version %s, Copyright (C) 2001 Roaring Penguin Software Inc.\n", VERSION);
@@ -227,6 +278,7 @@
 * -C ifname           -- Use interface for PPPoE clients
 * -S ifname           -- Use interface for PPPoE servers
 * -B ifname           -- Use interface for both clients and servers
+* -V ifname           -- Use interface for PPPoe clients over 802.1Q trunk
 * -n sessions         -- Maximum of "n" sessions
 ***********************************************************************/
 int
@@ -238,7 +290,11 @@
     int beDaemon = 1;
     openlog("pppoe-relay", LOG_PID, LOG_DAEMON);
 
-    while((opt = getopt(argc, argv, "hC:S:B:n:i:F")) != -1) {
+#ifdef SUPPORT_8021Q_VLAN
+    while((opt = getopt(argc, argv, "hC:S:B:V:n:N:i:FH")) != -1) {
+#else
+    while((opt = getopt(argc, argv, "hC:S:B:n:N:i:FH")) != -1) {
+#endif
 	switch(opt) {
 	case 'h':
 	    usage(argv[0]);
@@ -247,14 +303,19 @@
 	    beDaemon = 0;
 	    break;
 	case 'C':
-	    addInterface(optarg, 1, 0);
+	    addInterface(optarg, 1, 0, 0);
 	    break;
 	case 'S':
-	    addInterface(optarg, 0, 1);
+	    addInterface(optarg, 0, 1, 0);
 	    break;
 	case 'B':
-	    addInterface(optarg, 1, 1);
+	    addInterface(optarg, 1, 1, 0);
 	    break;
+#ifdef SUPPORT_8021Q_VLAN
+	case 'V':
+	    addInterface(optarg, 1, 0, 1);
+	    break;
+#endif
 	case 'i':
 	    if (sscanf(optarg, "%u", &IdleTimeout) != 1) {
 		fprintf(stderr, "Illegal argument to -i: should be -i timeout\n");
@@ -273,6 +334,19 @@
 		exit(EXIT_FAILURE);
 	    }
 	    break;
+	case 'N':
+	    if (sscanf(optarg,"%u",&MaxPreSessions) != 1) {
+		    fprintf(stderr,"Illegal argument to -N: should be -N #PreSessions\n");
+		    exit(EXIT_FAILURE);
+	    }
+	    if (MaxPreSessions < 1) {
+		    fprintf(stderr,"Illegal argument to -N: must be greater than 0\n");
+		    exit(EXIT_FAILURE);
+	    }
+	    break;
+	case 'H':
+	    enableClientHack++;
+	    break;
 	default:
 	    usage(argv[0]);
 	}
@@ -354,6 +428,7 @@
 * ifname -- interface name
 * clientOK -- true if this interface should relay PADI, PADR packets.
 * acOK -- true if this interface should relay PADO, PADS packets.
+* dot1q -- true if this interface handles packets in 802.1Q trunk
 *%RETURNS:
 * Nothing
 *%DESCRIPTION:
@@ -362,7 +437,8 @@
 void
 addInterface(char const *ifname,
 	     int clientOK,
-	     int acOK)
+	     int acOK,
+	     int dot1q)
 {
     PPPoEInterface *i;
     int j;
@@ -382,8 +458,17 @@
     strncpy(i->name, ifname, IFNAMSIZ);
     i->name[IFNAMSIZ] = 0;
 
-    i->discoverySock = openInterface(ifname, Eth_PPPOE_Discovery, i->mac);
-    i->sessionSock   = openInterface(ifname, Eth_PPPOE_Session,   NULL);
+#ifdef SUPPORT_8021Q_VLAN
+    if ( dot1q ) {
+	i->discoverySock = i->sessionSock = openInterface(ifname, ETH_P_8021Q, i->mac);
+    } else {
+#endif
+	i->discoverySock = openInterface(ifname, Eth_PPPOE_Discovery, i->mac);
+	i->sessionSock   = openInterface(ifname, Eth_PPPOE_Session,   NULL);
+#ifdef SUPPORT_8021Q_VLAN
+    }
+    i->dot1q = dot1q;
+#endif
     i->clientOK = clientOK;
     i->acOK = acOK;
 }
@@ -432,6 +517,35 @@
     FreeSessions = AllSessions;
     ActiveSessions = NULL;
 
+    FreePreSessions = (PreSession*)calloc(MaxPreSessions, sizeof(PreSession));
+    if (!FreePreSessions) {
+	rp_fatal("Unable to allocate memory for PPPoE Pre-session table");
+    }
+
+    		/* make the linked list */
+		for (i=0; i<MaxPreSessions; i++) {
+			FreePreSessions[i].prev = &FreePreSessions[i-1];
+			FreePreSessions[i].next = &FreePreSessions[i+1];
+		}
+		/* fix the first and the last elem */
+		FreePreSessions[0].prev = NULL;
+		FreePreSessions[i-1].next = NULL;
+    /* initialize the fclMacToPreSess and clMacToPreSessT tables if requested */
+    if (enableClientHack) {
+	fclMacToPreSess=
+		(clMacToPreSess*)calloc(MaxPreSessions, sizeof(clMacToPreSess));
+	clMacToPreSessT=
+		(clMacToPreSess**)calloc(APS_HASHTAB_SIZE, sizeof(clMacToPreSess*));
+	if (!fclMacToPreSess || !clMacToPreSessT) {
+		rp_fatal("Unable to allocate memory for PPPoE Pre-session table");
+	}
+	/* make the linked list */
+	for (i=0; i<MaxPreSessions; i++) {
+		fclMacToPreSess[i].next = &fclMacToPreSess[i+1];
+	}
+	fclMacToPreSess[i-1].next = NULL;
+    }
+
     /* Initialize session numbers which we hand out */
     for (i=0; i<MaxSessions; i++) {
 	AllSessions[i].sesNum = htons((UINT16_t) i+1);
@@ -448,6 +562,462 @@
     AllHashes[2*MaxSessions-1].next = NULL;
 
     FreeHashes = AllHashes;
+
+		/* initialize the PreSession hash */
+		memset(ActivePreSessions,0,sizeof(PreSession*)*APS_HASHTAB_SIZE);
+
+		/* initialize the random source */
+		dev_urandom_fd = open("/dev/urandom",O_RDONLY);
+		if (dev_urandom_fd == -1) {
+			rp_fatal("Unable to open /dev/urandom");
+		}
+}
+
+/**********************************************************************
+ * %FUNCTION: genRandString
+ * %ARGUMENTS:
+ * uniqueID -- pointer to where to generate the string
+ * len -- the length of the string
+ * %RETURNS:
+ * Nothing
+**********************************************************************/
+static void
+genRandString(void* uniqueID, unsigned int len)
+{
+	read(dev_urandom_fd,uniqueID,len);
+}
+
+
+/**********************************************************************
+ * %FUNCTION: stringHash
+ * %ARGUMENTS:
+ * string -- the pointer to the uniqueID
+ * len -- the length of the id
+ * max -- the maximum value+1 for the hash value
+ * %RETURNS:
+ * the calculated hash for the string
+ * %DESCRIPTION:
+ * calculates a hash for the given string
+**********************************************************************/
+static unsigned int
+stringHash(const void* string,
+		unsigned int len,
+		unsigned int max)
+{
+	unsigned int		hv=0;
+	unsigned char*	hp=(unsigned char*)string;
+
+	while( len ) {
+		hv += hp[0];
+		if (len > 1) {
+			hv += hp[0]*hp[1];
+		}
+		len--;
+		hp++;
+	}
+	return (hv % max);
+}
+
+#define sessIdHash(s,l)	stringHash((s),(l),APS_HASHTAB_SIZE)
+#define servNameHash(s,l) stringHash((s),(l),SERVNAME_HT_SIZE)
+#define macHash(m) stringHash((m),ETH_ALEN,APS_HASHTAB_SIZE)
+
+/**********************************************************************
+ * %FUNCTION: hack_registerClient
+ * %ARGUMENTS:
+ * psess -- the newly created PreSession
+ * %RETURNS:
+ * nothing
+ * %DESCRIPTION:
+ * associates the session with the clients mac address
+**********************************************************************/
+static void
+hack_registerClient(const PreSession* psess)
+{
+	clMacToPreSess*	clp;
+	unsigned	hv=macHash(psess->clientMac);
+
+	clp = clMacToPreSessT[hv];
+	while(clp && memcmp(clp->clMac,psess->clientMac,ETH_ALEN))
+		clp = clp->next;
+	if (!clp) {
+		clp = fclMacToPreSess;
+		if (!clp) {
+			/* no free clMacToPreSess exists, we can not do anything
+			 * but this should not happen */
+			return;
+		}
+		fclMacToPreSess = clp->next;
+		memcpy(clp->clMac,psess->clientMac,ETH_ALEN);
+		clp->next = clMacToPreSessT[hv];
+		clMacToPreSessT[hv] = clp;
+	}
+	/* hold the latest PreSession */
+	clp->psess = psess;
+}
+
+/**********************************************************************
+ * %FUNCTION: hack_findClient
+ * %ARGUMENTS:
+ * clMac -- the client's MAC address
+ * %RETURNS:
+ * psess -- the PreSession associated with the MAC address if found, else NULL
+ * %DESCRIPTION:
+ * finds the associated PreSession with clMac
+**********************************************************************/
+static const PreSession*
+hack_findClient(unsigned char const clMac[ETH_ALEN])
+{
+	clMacToPreSess* clp = clMacToPreSessT[macHash(clMac)];
+	while(clp && memcmp(clp->clMac,clMac,ETH_ALEN))
+		clp = clp->next;
+	if (clp)
+		return clp->psess;
+	return NULL;
+}
+
+/**********************************************************************
+ * %FUNCTION: hack_removeClient
+ * %ARGUMENTS:
+ * clMac -- the client's MAC address
+ * %RETURNS:
+ * nothing
+ * %DESCRIPTION:
+ * removes the association if found
+**********************************************************************/
+static void
+hack_removeClient(unsigned char const clMac[ETH_ALEN])
+{
+	clMacToPreSess** clpp = &clMacToPreSessT[macHash(clMac)];
+	clMacToPreSess*  clp = *clpp;
+
+	while(clp && memcmp(clp->clMac,clMac,ETH_ALEN)) {
+		clpp = &clp->next;
+		clp = *clpp;
+	}
+	if (clp) {
+		*clpp = clp->next;
+		clp->next = fclMacToPreSess;
+		fclMacToPreSess = clp;
+	}
+}
+
+/**********************************************************************
+ * %FUNCTION: newServiceName
+ * %ARGUMENTS:
+ * serviceName -- the pointer to the serviceName
+ * length -- the serviceName's length
+ * ac -- the interface it was received on
+ * acMac -- the AC's MAC address who sent this
+ * %RETURNS:
+ * the pointer to ServiceName
+ * %DESCRIPTION:
+ * allocates a new ServiceName and fills in the structure
+**********************************************************************/
+static ServiceName*
+newServiceName(const void* serviceName,
+		unsigned int length,
+		const PPPoEInterface* ac,
+		const unsigned char* acMac)
+{
+	ServiceName*	sp;
+
+	sp = (ServiceName*)malloc(sizeof(ServiceName));
+	if (sp) {
+		sp->serviceName = malloc(length);
+		if (sp->serviceName || length == 0) {
+			sp->next = NULL;
+			memcpy(sp->serviceName,serviceName,length);
+			sp->serviceNameLen = length;
+			sp->interface = ac;
+			memcpy(sp->serverMac,acMac,ETH_ALEN);
+			return sp;
+		}
+		free(sp);
+	}
+	return NULL;
+}
+
+/**********************************************************************
+ * %FUNCTION: hashServiceName
+ * %ARGUMENTS:
+ * psess -- the PreSession where to hash the ServiceName
+ * sname -- the ServiceName to be hashed
+ * %RETURNS:
+ * nothing
+ * %DESCRIPTION:
+ * this inserts the given ServiceName into the PreSession's
+**********************************************************************/
+static void
+hashServiceName(
+		PreSession* psess,
+		ServiceName* sname)
+{
+	unsigned int	v=servNameHash(sname->serviceName,sname->serviceNameLen);
+
+	sname->next = psess->SNHT[v];
+	psess->SNHT[v] = sname;
+}
+
+/**********************************************************************
+ * %FUNCTION: findServiceName
+ * %ARGUMENTS:
+ * psess -- presession where to search for the service name
+ * serviceName -- the requested serviceName
+ * serviceNameLen -- the length of the serviceName
+ * any -- find any serviceName only if serviceNameLen == 0
+ * %RETURNS:
+ * ServiceName -- the found ServiceName or NULL
+ * %DESCRIPTION:
+ * This function searches for the given serviceName in the psess
+**********************************************************************/
+static ServiceName*
+findServiceName(
+		PreSession* psess,
+		const void* serviceName,
+		unsigned int serviceNameLen,
+		int any)
+{
+	ServiceName* sname;
+
+	if (any && serviceNameLen == 0) {
+		for(any=0; any<SERVNAME_HT_SIZE; any++) {
+			sname=psess->SNHT[any];
+			if (sname)
+				break;
+		}
+		return sname;
+	}
+
+	sname = psess->SNHT[servNameHash(serviceName,serviceNameLen)];
+	while( sname &&
+			(sname->serviceNameLen != serviceNameLen ||
+			 memcmp(sname->serviceName,serviceName,serviceNameLen)) ) {
+		sname = sname->next;
+	}
+	return sname;
+}
+
+/**********************************************************************
+ * %FUNCTION: allocPreSession
+ * %ARGUMENTS:
+ * none
+ * %RETURNS:
+ * psess -- the allocated PreSession
+ * %DESCRIPTION:
+ * allocates a PreSession, initializes it,
+ * and removes it from the free list
+**********************************************************************/
+static PreSession*
+allocPreSession(void)
+{
+	PreSession*	psess;
+
+	psess = FreePreSessions;
+	if (psess) {
+		FreePreSessions = psess->next;
+		if (FreePreSessions) {
+			FreePreSessions->prev = NULL;
+		}
+		psess->uniqueID = NULL;
+		memset(psess->SNHT,0,sizeof(ServiceName*)*SERVNAME_HT_SIZE);
+		psess->epoch = Epoch;
+	}
+	return psess;
+}
+
+/**********************************************************************
+ * %FUNCTION: releasePreSession
+ * %ARGUMENTS:
+ * sess -- the session to be released
+ * %RETURNS:
+ * none
+ * %DESCRIPTION:
+ * it frees the struct, and links it in the free list
+**********************************************************************/
+static void
+releasePreSession(
+		PreSession*	psess)
+{
+	ServiceName*	sp;
+	ServiceName*	spt;
+	unsigned int	i;
+
+	/* free the uniqueID if defined */
+	if (psess->uniqueID)
+		free(psess->uniqueID);
+
+	/* free the serviceNames if any */
+	for(i=0;i<SERVNAME_HT_SIZE;i++) {
+		sp = psess->SNHT[i];
+		while(sp) {
+			spt = sp->next;
+			if (sp->serviceName)
+				free(sp->serviceName);
+			free(sp);
+			sp = spt;
+		}
+	}
+
+	psess->next = FreePreSessions;
+	if (psess->next) {
+		psess->next->prev = psess;
+	}
+	psess->prev = NULL;
+	FreePreSessions = psess;
+
+	/* free the mac address association */
+	if (enableClientHack)
+		hack_removeClient(psess->clientMac);
+}
+
+/**********************************************************************
+ * %FUNCTION: createPreSession
+ * %ARGUMENTS:
+ * sessID -- PreSessionId
+ * sessIDLen -- PreSessionId length
+ * cli -- client's interface
+ * cliMac -- client's MAC address
+ * dot1qTag -- the 8021q VLAN ID of the client
+ * %DESCRIPTION:
+ * creates a new PreSession and inserts into the hash
+ * it assumes that the unique id is really unique
+**********************************************************************/
+static PreSession*
+createPreSession(
+		const unsigned char* sessID,
+		unsigned int sessIDLen,
+		PPPoEInterface const* cli,
+		const unsigned char* cliMac,
+		UINT16_t dot1qTag)
+{
+	PreSession*				psess;
+
+	psess = allocPreSession();
+	if (!psess)
+		return NULL;
+
+	/* initialize the default values */
+	psess->uniqueID = malloc(sessIDLen);
+	if (!psess->uniqueID) {
+		releasePreSession(psess);
+		return NULL;
+	}
+
+	/* initialize the struct */
+	memcpy(psess->uniqueID,sessID,sessIDLen);
+	psess->uniqueIDLen = sessIDLen;
+	memcpy(psess->clientMac,cliMac,ETH_ALEN);
+	psess->interface = cli;
+#ifdef SUPPORT_8021Q_VLAN
+	psess->dot1qTag = dot1qTag;
+#endif
+
+	return psess;
+}
+
+/**********************************************************************
+ * %FUNCTION: hashPreSession
+ * %ARGUMENTS:
+ * psess -- the PreSession to be hashed
+ * %RETURNS:
+ * nothing
+ * %DESCRIPTION:
+ * this hashes the given PreSession to ActivePreSessions
+**********************************************************************/
+static void
+hashPreSession(PreSession* psess)
+{
+	unsigned int	v=sessIdHash(psess->uniqueID,psess->uniqueIDLen);
+
+	psess->next = ActivePreSessions[v];
+	psess->prev = NULL;
+	if (psess->next) {
+		psess->next->prev = psess;
+	}
+	ActivePreSessions[v] = psess;
+}
+
+/**********************************************************************
+ * %FUNCTION: unhashPreSession
+ * %ARGUMENTS:
+ * psess -- the PreSession to be unhashed
+ * %RETURNS:
+ * nothing
+ * %DESCRIPTION:
+ * this unhashes the given PreSession from ActivePreSessions
+**********************************************************************/
+static void
+unhashPreSession(PreSession* psess)
+{
+	unsigned int	v=sessIdHash(psess->uniqueID,psess->uniqueIDLen);
+
+	if (psess->next) {
+		psess->next->prev = psess->prev;
+	}
+	if (psess->prev) {
+		psess->prev->next = psess->next;
+	} else {
+		ActivePreSessions[v] = psess->next;
+	}
+}
+
+/**********************************************************************
+ * %FUNCTION: findPreSession
+ * %ARGUMENTS:
+ * sessID -- the session id
+ * sessIDLen -- the length of the sessID
+ * %RETURNS:
+ * psess -- the found PreSession if found, NULL otherwise
+ * %DESCRIPTION:
+ * this finds the PreSession by it's sessID
+**********************************************************************/
+static PreSession*
+findPreSession(const void* sessID,
+		unsigned int sessIDLen)
+{
+	PreSession* psess;
+	unsigned int	v=sessIdHash(sessID,sessIDLen);
+
+	psess = ActivePreSessions[v];
+	while( psess &&
+			(psess->uniqueIDLen != sessIDLen || memcmp(psess->uniqueID,sessID,sessIDLen)) ) {
+		psess = psess->next;
+	}
+	return psess;
+}
+
+/**********************************************************************
+ * %FUNCTION: cleanPreSession
+ * %ARGUMENTS:
+ * nothing
+ * %RETURNS:
+ * nothing
+ * %DESCRIPTION:
+ * cleans PreSessions if they are too old (they age 2 seconds)
+***********************************************************************/
+static void
+cleanPreSession(void)
+{
+	PreSession**	pps;
+	PreSession*		ps;
+	unsigned int	i;
+
+	for(i=0;i<APS_HASHTAB_SIZE;i++) {
+		pps=&ActivePreSessions[i];
+		ps=*pps;
+
+		while(ps) {
+			if (ps->epoch < Epoch-PRESESSION_TIMEOUT) {
+				unhashPreSession(ps);
+				releasePreSession(ps);
+				ps=*pps;
+			} else {
+				pps=&ps->next;
+				ps=ps->next;
+			}
+		}
+	}
 }
 
 /**********************************************************************
@@ -458,6 +1028,7 @@
 * acMac -- Access concentrator's MAC address
 * cliMac -- Client's MAC address
 * acSess -- Access concentrator's session ID.
+* dot1qTag -- 802.1Q Tag on client side
 *%RETURNS:
 * PPPoESession structure; NULL if one could not be allocated
 *%DESCRIPTION:
@@ -468,7 +1039,8 @@
 	      PPPoEInterface const *cli,
 	      unsigned char const *acMac,
 	      unsigned char const *cliMac,
-	      UINT16_t acSes)
+	      UINT16_t acSes,
+	      UINT16_t dot1qTag)
 {
     PPPoESession *sess;
     SessionHash *acHash, *cliHash;
@@ -504,6 +1076,10 @@
     sess->acHash = acHash;
     sess->clientHash = cliHash;
 
+#ifdef SUPPORT_8021Q_VLAN
+    sess->dot1qTag = dot1qTag;
+#endif
+
     acHash->interface = ac;
     cliHash->interface = cli;
 
@@ -774,24 +1350,42 @@
 
 	/* Handle session packets first */
 	for (i=0; i<NumInterfaces; i++) {
+#ifdef SUPPORT_8021Q_VLAN
+	    if (!Interfaces[i].dot1q && FD_ISSET(Interfaces[i].sessionSock, &readableCopy)) {
+#else
 	    if (FD_ISSET(Interfaces[i].sessionSock, &readableCopy)) {
+#endif
 		relayGotSessionPacket(&Interfaces[i]);
 	    }
 	}
 
 	/* Now handle discovery packets */
 	for (i=0; i<NumInterfaces; i++) {
+#ifdef SUPPORT_8021Q_VLAN
+	    if (!Interfaces[i].dot1q && FD_ISSET(Interfaces[i].discoverySock, &readableCopy)) {
+#else
 	    if (FD_ISSET(Interfaces[i].discoverySock, &readableCopy)) {
+#endif
 		relayGotDiscoveryPacket(&Interfaces[i]);
 	    }
 	}
 
+#ifdef SUPPORT_8021Q_VLAN
+	/* At last, handle 802.1Q trunk packets */
+	for (i=0; i<NumInterfaces; i++) {
+	    if (Interfaces[i].dot1q && FD_ISSET(Interfaces[i].discoverySock, &readableCopy)) {
+		relayGotTrunkPacket(&Interfaces[i]);
+	    }
+	}
+#endif
+
 	/* Handle the session-cleaning process */
 	if (FD_ISSET(CleanPipe[0], &readableCopy)) {
 	    char dummy;
 	    CleanCounter = 0;
 	    read(CleanPipe[0], &dummy, 1);
 	    if (IdleTimeout) cleanSessions();
+			cleanPreSession();
 	}
     }
 }
@@ -808,48 +1402,49 @@
 void
 relayGotDiscoveryPacket(PPPoEInterface const *iface)
 {
-    PPPoEPacket packet;
+    PPPoEPacket8021Q packet8021q;
+    PPPoEPacket* packet = &packet8021q.packet;
     int size;
 
-    if (receivePacket(iface->discoverySock, &packet, &size) < 0) {
+    if (receivePacket(iface->discoverySock, packet, &size) < 0) {
 	return;
     }
     /* Ignore unknown code/version */
-    if (packet.ver != 1 || packet.type != 1) {
+    if (packet->ver != 1 || packet->type != 1) {
 	return;
     }
 
     /* Validate length */
-    if (ntohs(packet.length) + HDR_SIZE > size) {
+    if (ntohs(packet->length) + HDR_SIZE > size) {
 	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
-	       (unsigned int) ntohs(packet.length));
+	       (unsigned int) ntohs(packet->length));
 	return;
     }
 
     /* Drop Ethernet frame padding */
-    if (size > ntohs(packet.length) + HDR_SIZE) {
-	size = ntohs(packet.length) + HDR_SIZE;
+    if (size > ntohs(packet->length) + HDR_SIZE) {
+	size = ntohs(packet->length) + HDR_SIZE;
     }
 
-    switch(packet.code) {
+    switch(packet->code) {
     case CODE_PADT:
-	relayHandlePADT(iface, &packet, size);
+	relayHandlePADT(iface, packet, size);
 	break;
     case CODE_PADI:
-	relayHandlePADI(iface, &packet, size);
+	relayHandlePADI(iface, packet, size, 0);
 	break;
     case CODE_PADO:
-	relayHandlePADO(iface, &packet, size);
+	relayHandlePADO(iface, packet, size);
 	break;
     case CODE_PADR:
-	relayHandlePADR(iface, &packet, size);
+	relayHandlePADR(iface, packet, size, 0);
 	break;
     case CODE_PADS:
-	relayHandlePADS(iface, &packet, size);
+	relayHandlePADS(iface, packet, size);
 	break;
     default:
 	syslog(LOG_ERR, "Discovery packet on %s with unknown code %d",
-	       iface->name, (int) packet.code);
+	       iface->name, (int) packet->code);
     }
 }
 
@@ -865,45 +1460,46 @@
 void
 relayGotSessionPacket(PPPoEInterface const *iface)
 {
-    PPPoEPacket packet;
+    PPPoEPacket8021Q packet8021q;
+    PPPoEPacket* packet=&packet8021q.packet;
     int size;
     SessionHash *sh;
     PPPoESession *ses;
 
-    if (receivePacket(iface->sessionSock, &packet, &size) < 0) {
+    if (receivePacket(iface->sessionSock, packet, &size) < 0) {
 	return;
     }
 
     /* Ignore unknown code/version */
-    if (packet.ver != 1 || packet.type != 1) {
+    if (packet->ver != 1 || packet->type != 1) {
 	return;
     }
 
     /* Must be a session packet */
-    if (packet.code != CODE_SESS) {
-	syslog(LOG_ERR, "Session packet with code %d", (int) packet.code);
+    if (packet->code != CODE_SESS) {
+	syslog(LOG_ERR, "Session packet with code %d", (int) packet->code);
 	return;
     }
 
     /* Ignore session packets whose destination address isn't ours */
-    if (memcmp(packet.ethHdr.h_dest, iface->mac, ETH_ALEN)) {
+    if (memcmp(packet->ethHdr.h_dest, iface->mac, ETH_ALEN)) {
 	return;
     }
 
     /* Validate length */
-    if (ntohs(packet.length) + HDR_SIZE > size) {
+    if (ntohs(packet->length) + HDR_SIZE > size) {
 	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
-	       (unsigned int) ntohs(packet.length));
+	       (unsigned int) ntohs(packet->length));
 	return;
     }
 
     /* Drop Ethernet frame padding */
-    if (size > ntohs(packet.length) + HDR_SIZE) {
-	size = ntohs(packet.length) + HDR_SIZE;
+    if (size > ntohs(packet->length) + HDR_SIZE) {
+	size = ntohs(packet->length) + HDR_SIZE;
     }
 
     /* We're in business!  Find the hash */
-    sh = findSession(packet.ethHdr.h_source, packet.session);
+    sh = findSession(packet->ethHdr.h_source, packet->session);
     if (!sh) {
 	/* Don't log this.  Someone could be running the client and the
 	   relay on the same box. */
@@ -914,9 +1510,9 @@
     ses = sh->ses;
     ses->epoch = Epoch;
     sh = sh->peer;
-    packet.session = sh->sesNum;
-    memcpy(packet.ethHdr.h_source, sh->interface->mac, ETH_ALEN);
-    memcpy(packet.ethHdr.h_dest, sh->peerMac, ETH_ALEN);
+    packet->session = sh->sesNum;
+    memcpy(packet->ethHdr.h_source, sh->interface->mac, ETH_ALEN);
+    memcpy(packet->ethHdr.h_dest, sh->peerMac, ETH_ALEN);
 #if 0
     fprintf(stderr, "Relaying %02x:%02x:%02x:%02x:%02x:%02x(%s:%d) to %02x:%02x:%02x:%02x:%02x:%02x(%s:%d)\n",
 	    sh->peer->peerMac[0], sh->peer->peerMac[1], sh->peer->peerMac[2],
@@ -926,8 +1522,181 @@
 	    sh->peerMac[3], sh->peerMac[4], sh->peerMac[5],
 	    sh->interface->name, ntohs(sh->sesNum));
 #endif
-    sendPacket(NULL, sh->interface->sessionSock, &packet, size);
+#ifdef SUPPORT_8021Q_VLAN
+    if ( sh->interface->dot1q ) {
+	    packet = (PPPoEPacket*)relayTag8021QPacket(packet, &size, ses->dot1qTag);
+    }
+#endif
+    sendPacket(NULL, sh->interface->sessionSock, packet, size);
+}
+
+#ifdef SUPPORT_8021Q_VLAN
+/**********************************************************************
+*%FUNCTION relayUnTag8021QPacket
+* packet -- the received packet
+* size -- size of the packet
+*%RETURNS:
+* size -- the resulting size
+* dot1qTag -- the tag extracted from packet
+* packet -- the untagged packet
+*%DESCRIPTION
+* Extracts the tag field from a packet, and untags it
+***********************************************************************/
+PPPoEPacket*
+relayUnTag8021QPacket(PPPoEPacket8021Q* packet,
+			int* size,
+			UINT16_t* dot1qTag)
+{
+	struct vlan_ethhdr* vhdr = (struct vlan_ethhdr*)packet;
+
+	if ( vhdr->h_vlan_proto != htons(ETH_P_8021Q) ) {
+		return NULL;
+	}
+	*dot1qTag=ntohs(vhdr->h_vlan_TCI) & 0xfff;
+	memmove(&packet->packet,vhdr,2 * ETH_ALEN);
+	*size -= VLAN_HLEN;
+	return &packet->packet;
+}
+#endif
+
+#ifdef SUPPORT_8021Q_VLAN
+/**********************************************************************
+*%FUNCTION relayTag8021QPacket
+* packet -- the pppoe packet to be sent
+* size -- size of the packet
+* dot1qTag -- the tag to be included in the packet
+*%RETURNS:
+* ret -- the resulting size
+*%DESCRIPTION
+* Extracts the tag field from a packet, and untags it
+***********************************************************************/
+PPPoEPacket8021Q*
+relayTag8021QPacket(PPPoEPacket* packet,
+			int* size,
+			UINT16_t dot1qTag)
+{
+	struct vlan_ethhdr* vhdr = (struct vlan_ethhdr*)((char*)packet - VLAN_HLEN);
+
+	memmove(vhdr,packet,2 * ETH_ALEN);
+	vhdr->h_vlan_proto = htons(ETH_P_8021Q);
+	vhdr->h_vlan_TCI = htons(dot1qTag & 0xfff);
+
+	*size += VLAN_HLEN;
+	return (PPPoEPacket8021Q*)vhdr;
 }
+#endif
+
+#ifdef SUPPORT_8021Q_VLAN
+/**********************************************************************
+*%FUNCTION: relayGotTrunkPacket
+*%ARGUMENTS:
+* iface -- interface on which packet is waiting
+*%RETURNS:
+* Nothing
+*%DESCRIPTION:
+* Receives and processes a discovery packet.
+***********************************************************************/
+void
+relayGotTrunkPacket(PPPoEInterface const *iface)
+{
+    PPPoEPacket8021Q packet8021q;
+    PPPoEPacket *packet;
+    int size;
+    UINT16_t dot1qTag;
+    SessionHash *sh;
+    PPPoESession *ses;
+
+    if ( (size=recv(iface->discoverySock, &packet8021q, sizeof(packet8021q), 0)) < sizeof(struct vlan_ethhdr) ) {
+	    sysErr("recv (relayGotTrunkPacket)");
+	    return;
+    }
+    if ( (packet=relayUnTag8021QPacket(&packet8021q, &size, &dot1qTag)) == NULL ) {
+	    sysErr("recv (relayGotTrunkPacket)");
+	    return;
+    }
+    if ( packet->ethHdr.h_proto != htons(Eth_PPPOE_Discovery) &&
+	 packet->ethHdr.h_proto != htons(Eth_PPPOE_Session) ) {
+	    return;
+    }
+
+    /* Ignore unknown code/version */
+    if (packet->ver != 1 || packet->type != 1) {
+	return;
+    }
+
+    /* Validate length */
+    if (ntohs(packet->length) + HDR_SIZE > size) {
+	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
+	       (unsigned int) ntohs(packet->length));
+	return;
+    }
+
+    /* Drop Ethernet frame padding */
+    if (size > ntohs(packet->length) + HDR_SIZE) {
+	size = ntohs(packet->length) + HDR_SIZE;
+    }
+
+    if ( packet->ethHdr.h_proto == htons(Eth_PPPOE_Discovery) ) {
+	    switch(packet->code) {
+	    case CODE_PADT:
+		relayHandlePADT(iface, packet, size);
+		break;
+	    case CODE_PADI:
+		relayHandlePADI(iface, packet, size, dot1qTag);
+		break;
+	    case CODE_PADO:
+		relayHandlePADO(iface, packet, size);
+		break;
+	    case CODE_PADR:
+		relayHandlePADR(iface, packet, size, dot1qTag);
+		break;
+	    case CODE_PADS:
+		relayHandlePADS(iface, packet, size);
+		break;
+	    default:
+		syslog(LOG_ERR, "Discovery packet on %s with unknown code %d",
+		       iface->name, (int) packet->code);
+	    }
+    } else {
+	    /* Must be a session packet */
+	    if (packet->code != CODE_SESS) {
+		syslog(LOG_ERR, "Session packet with code %d", (int) packet->code);
+		return;
+	    }
+
+	    /* Ignore session packets whose destination address isn't ours */
+	    if (memcmp(packet->ethHdr.h_dest, iface->mac, ETH_ALEN)) {
+		return;
+	    }
+
+	    /* We're in business!  Find the hash */
+	    sh = findSession(packet->ethHdr.h_source, packet->session);
+	    if (!sh) {
+		/* Don't log this.  Someone could be running the client and the
+		   relay on the same box. */
+		return;
+	    }
+
+	    /* Relay it */
+	    ses = sh->ses;
+	    ses->epoch = Epoch;
+	    sh = sh->peer;
+	    packet->session = sh->sesNum;
+	    memcpy(packet->ethHdr.h_source, sh->interface->mac, ETH_ALEN);
+	    memcpy(packet->ethHdr.h_dest, sh->peerMac, ETH_ALEN);
+#if 0
+	    fprintf(stderr, "Relaying %02x:%02x:%02x:%02x:%02x:%02x(%s:%d) to %02x:%02x:%02x:%02x:%02x:%02x(%s:%d)\n",
+		    sh->peer->peerMac[0], sh->peer->peerMac[1], sh->peer->peerMac[2],
+		    sh->peer->peerMac[3], sh->peer->peerMac[4], sh->peer->peerMac[5],
+		    sh->peer->interface->name, ntohs(sh->peer->sesNum),
+		    sh->peerMac[0], sh->peerMac[1], sh->peerMac[2],
+		    sh->peerMac[3], sh->peerMac[4], sh->peerMac[5],
+		    sh->interface->name, ntohs(sh->sesNum));
+#endif
+	    sendPacket(NULL, sh->interface->sessionSock, packet, size);
+    }
+}
+#endif
 
 /**********************************************************************
 *%FUNCTION: relayHandlePADT
@@ -957,6 +1726,11 @@
     packet->session = sh->sesNum;
     memcpy(packet->ethHdr.h_source, sh->interface->mac, ETH_ALEN);
     memcpy(packet->ethHdr.h_dest, sh->peerMac, ETH_ALEN);
+#ifdef SUPPORT_8021Q_VLAN
+    if ( sh->interface->dot1q ) {
+	    packet = (PPPoEPacket*)relayTag8021QPacket(packet, &size, ses->dot1qTag);
+    }
+#endif
     sendPacket(NULL, sh->interface->sessionSock, packet, size);
 
     /* Destroy the session */
@@ -968,6 +1742,7 @@
 *%ARGUMENTS:
 * iface -- interface on which packet was received
 * packet -- the PADI packet
+* dot1qTag -- the 802.1Q tag associated with packet
 *%RETURNS:
 * Nothing
 *%DESCRIPTION:
@@ -976,14 +1751,14 @@
 void
 relayHandlePADI(PPPoEInterface const *iface,
 		PPPoEPacket *packet,
-		int size)
+		int size,
+		UINT16_t dot1qTag)
 {
     PPPoETag tag;
+		PreSession*	psess;
     unsigned char *loc;
     int i, r;
 
-    int ifIndex;
-
     /* Can a client legally be behind this interface? */
     if (!iface->clientOK) {
 	syslog(LOG_ERR,
@@ -1026,26 +1801,43 @@
 	return;
     }
 
-    /* Get array index of interface */
-    ifIndex = iface - Interfaces;
-
     loc = findTag(packet, TAG_RELAY_SESSION_ID, &tag);
     if (!loc) {
 	tag.type = htons(TAG_RELAY_SESSION_ID);
-	tag.length = htons(MY_RELAY_TAG_LEN);
-	memcpy(tag.payload, &ifIndex, sizeof(ifIndex));
-	memcpy(tag.payload+sizeof(ifIndex), packet->ethHdr.h_source, ETH_ALEN);
-	/* Add a relay tag if there's room */
+	tag.length = htons(12);
+	genRandString(tag.payload,ntohs(tag.length));
 	r = addTag(packet, &tag);
-	if (r < 0) return;
+	if ( r < 0 )
+		return;
 	size += r;
     } else {
-	/* We do not re-use relay-id tags.  Drop the frame.  The RFC says the
+	/* We do re-use relay-id tags only if it is at least 6 bytes long.
+	   Otherwise drop the frame.  The RFC says the
 	   relay agent SHOULD return a Generic-Error tag, but this does not
 	   make sense for PADI packets. */
-	return;
+			if (ntohs(tag.length) < 6)
+				return;
     }
 
+		psess = findPreSession(tag.payload, ntohs(tag.length));
+		if (psess) {
+			/* if such a session with the same PreSessionId exists
+			 * skip this packet. It should be wiped out in the next
+			 * cleanPeriod */
+			return;
+		}
+
+		psess = createPreSession(
+				tag.payload,ntohs(tag.length),
+				iface, packet->ethHdr.h_source, dot1qTag);
+		if (!psess) {
+			/* some error occured */
+			return;
+		}
+		hashPreSession(psess);
+		if (enableClientHack)
+			hack_registerClient(psess);
+
     /* Broadcast the PADI on all AC-capable interfaces except the interface
        on which it came */
     for (i=0; i < NumInterfaces; i++) {
@@ -1073,9 +1865,9 @@
 		int size)
 {
     PPPoETag tag;
+		PreSession* psess;
+		ServiceName* sname;
     unsigned char *loc;
-    int ifIndex;
-    int acIndex;
 
     /* Can a server legally be behind this interface? */
     if (!iface->acOK) {
@@ -1091,8 +1883,6 @@
 	return;
     }
 
-    acIndex = iface - Interfaces;
-
     /* Source address must be unicast */
     if (NOT_UNICAST(packet->ethHdr.h_source)) {
 	syslog(LOG_ERR,
@@ -1127,10 +1917,12 @@
 	return;
     }
 
-    /* If it's the wrong length, ignore it */
-    if (ntohs(tag.length) != MY_RELAY_TAG_LEN) {
+		psess = findPreSession(tag.payload, ntohs(tag.length));
+
+    /* If it is not found, log it and ignore it */
+		if (!psess) {
 	syslog(LOG_ERR,
-	       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have correct length Relay-Session-Id tag",
+	       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have a valid Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
 	       packet->ethHdr.h_source[2],
@@ -1141,14 +1933,11 @@
 	return;
     }
 
-    /* Extract interface index */
-    memcpy(&ifIndex, tag.payload, sizeof(ifIndex));
-
-    if (ifIndex < 0 || ifIndex >= NumInterfaces ||
-	!Interfaces[ifIndex].clientOK ||
-	iface == &Interfaces[ifIndex]) {
-	syslog(LOG_ERR,
-	       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s has invalid interface in Relay-Session-Id tag",
+		/* record the offered Service-Name */
+    loc = findTag(packet, TAG_SERVICE_NAME, &tag);
+		if (!loc) {
+			syslog(LOG_ERR,
+	       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have Service-Name tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
 	       packet->ethHdr.h_source[2],
@@ -1157,20 +1946,38 @@
 	       packet->ethHdr.h_source[5],
 	       iface->name);
 	return;
-    }
+		}
 
-    /* Replace Relay-ID tag with opposite-direction tag */
-    memcpy(loc+TAG_HDR_SIZE, &acIndex, sizeof(acIndex));
-    memcpy(loc+TAG_HDR_SIZE+sizeof(ifIndex), packet->ethHdr.h_source, ETH_ALEN);
+		sname = findServiceName(psess, tag.payload, ntohs(tag.length), 0);
+		if (sname) {
+			/* we only record one host for each Service-Name, the others are ignored */
+			return;
+		}
+		sname = newServiceName(tag.payload, ntohs(tag.length),
+				iface,
+				packet->ethHdr.h_source);
+		if (!sname) {
+			/* some error occured */
+			return;
+		}
+		hashServiceName(psess, sname);
 
-    /* Set destination address to MAC address in relay ID */
-    memcpy(packet->ethHdr.h_dest, tag.payload + sizeof(ifIndex), ETH_ALEN);
+		/* update the epoch timer */
+		psess->epoch = Epoch;
+
+    /* Set destination address to MAC address in PreSession */
+    memcpy(packet->ethHdr.h_dest, psess->clientMac, ETH_ALEN);
 
     /* Set source address to MAC address of interface */
-    memcpy(packet->ethHdr.h_source, Interfaces[ifIndex].mac, ETH_ALEN);
+    memcpy(packet->ethHdr.h_source, psess->interface->mac, ETH_ALEN);
 
     /* Send the PADO to the proper client */
-    sendPacket(NULL, Interfaces[ifIndex].discoverySock, packet, size);
+#ifdef SUPPORT_8021Q_VLAN
+    if ( psess->interface->dot1q ) {
+	    packet = (PPPoEPacket*)relayTag8021QPacket(packet, &size, psess->dot1qTag);
+    }
+#endif
+    sendPacket(NULL, psess->interface->discoverySock, packet, size);
 }
 
 /**********************************************************************
@@ -1178,6 +1985,7 @@
 *%ARGUMENTS:
 * iface -- interface on which packet was received
 * packet -- the PADR packet
+* dot1qTag -- the 802.1Q tag associated with packet
 *%RETURNS:
 * Nothing
 *%DESCRIPTION:
@@ -1186,12 +1994,14 @@
 void
 relayHandlePADR(PPPoEInterface const *iface,
 		PPPoEPacket *packet,
-		int size)
+		int size,
+		UINT16_t dot1qTag)
 {
     PPPoETag tag;
+    PreSession* psess;
+    ServiceName* sname;
     unsigned char *loc;
-    int ifIndex;
-    int cliIndex;
+    int r;
 
     /* Can a client legally be behind this interface? */
     if (!iface->clientOK) {
@@ -1207,8 +2017,6 @@
 	return;
     }
 
-    cliIndex = iface - Interfaces;
-
     /* Source address must be unicast */
     if (NOT_UNICAST(packet->ethHdr.h_source)) {
 	syslog(LOG_ERR,
@@ -1230,7 +2038,7 @@
 
     /* Find relay tag */
     loc = findTag(packet, TAG_RELAY_SESSION_ID, &tag);
-    if (!loc) {
+    if (!loc && !enableClientHack) {
 	syslog(LOG_ERR,
 	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
@@ -1242,11 +2050,26 @@
 	       iface->name);
 	return;
     }
+    if (!loc) {
+	    /* enableClientHack was enabled */
+	syslog(LOG_ERR,
+	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have Relay-Session-Id tag, guessing",
+	       packet->ethHdr.h_source[0],
+	       packet->ethHdr.h_source[1],
+	       packet->ethHdr.h_source[2],
+	       packet->ethHdr.h_source[3],
+	       packet->ethHdr.h_source[4],
+	       packet->ethHdr.h_source[5],
+	       iface->name);
+	psess = (PreSession*)hack_findClient(packet->ethHdr.h_source);
+    } else {
+		psess = findPreSession(tag.payload, ntohs(tag.length));
+    }
 
-    /* If it's the wrong length, ignore it */
-    if (ntohs(tag.length) != MY_RELAY_TAG_LEN) {
+    /* If it is not valid, log and skip it */
+		if (!psess) {
 	syslog(LOG_ERR,
-	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have correct length Relay-Session-Id tag",
+	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have a valid Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
 	       packet->ethHdr.h_source[2],
@@ -1256,15 +2079,37 @@
 	       iface->name);
 	return;
     }
+		if (!loc) {
+			/* loc must point to the Relay-Session-Id tag. if not, enableClientHack is enabled
+			 * and we must correct the packet */
+			tag.type = htons(TAG_RELAY_SESSION_ID);
+			tag.length = htons(psess->uniqueIDLen);
+			memcpy(tag.payload, psess->uniqueID, psess->uniqueIDLen);
+			r = addTag(packet, &tag);
+			if (r < 0) {
+				return;
+			}
+			size += r;
+		}
 
-    /* Extract interface index */
-    memcpy(&ifIndex, tag.payload, sizeof(ifIndex));
+		/* check if the correct client sent the relay session id */
+		if (memcmp(psess->clientMac, packet->ethHdr.h_source, ETH_ALEN)) {
+	syslog(LOG_ERR,
+	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does have a strange Relay-Session-Id tag",
+	       packet->ethHdr.h_source[0],
+	       packet->ethHdr.h_source[1],
+	       packet->ethHdr.h_source[2],
+	       packet->ethHdr.h_source[3],
+	       packet->ethHdr.h_source[4],
+	       packet->ethHdr.h_source[5],
+	       iface->name);
+	return;
+		}
 
-    if (ifIndex < 0 || ifIndex >= NumInterfaces ||
-	!Interfaces[ifIndex].acOK ||
-	iface == &Interfaces[ifIndex]) {
+		loc = findTag(packet, TAG_SERVICE_NAME, &tag);
+		if (!loc) {
 	syslog(LOG_ERR,
-	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s has invalid interface in Relay-Session-Id tag",
+	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have a Service-Name tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
 	       packet->ethHdr.h_source[2],
@@ -1273,20 +2118,27 @@
 	       packet->ethHdr.h_source[5],
 	       iface->name);
 	return;
-    }
+		}
+
+		sname = findServiceName(psess, tag.payload, ntohs(tag.length), 1);
+		if (!sname) {
+			/* the requested Service-Name is not found, cannot handle this */
+			return;
+		}
+
+		/* update the epoch timer */
+		psess->epoch = Epoch;
 
-    /* Replace Relay-ID tag with opposite-direction tag */
-    memcpy(loc+TAG_HDR_SIZE, &cliIndex, sizeof(cliIndex));
-    memcpy(loc+TAG_HDR_SIZE+sizeof(ifIndex), packet->ethHdr.h_source, ETH_ALEN);
+    /* We dont touch 802.1Q Vlan IDs here */
 
     /* Set destination address to MAC address in relay ID */
-    memcpy(packet->ethHdr.h_dest, tag.payload + sizeof(ifIndex), ETH_ALEN);
+    memcpy(packet->ethHdr.h_dest, sname->serverMac, ETH_ALEN);
 
     /* Set source address to MAC address of interface */
-    memcpy(packet->ethHdr.h_source, Interfaces[ifIndex].mac, ETH_ALEN);
+    memcpy(packet->ethHdr.h_source, sname->interface->mac, ETH_ALEN);
 
     /* Send the PADR to the proper access concentrator */
-    sendPacket(NULL, Interfaces[ifIndex].discoverySock, packet, size);
+    sendPacket(NULL, sname->interface->discoverySock, packet, size);
 }
 
 /**********************************************************************
@@ -1305,11 +2157,11 @@
 		int size)
 {
     PPPoETag tag;
+		PreSession* psess;
     unsigned char *loc;
-    int ifIndex;
-    int acIndex;
     PPPoESession *ses = NULL;
     SessionHash *sh;
+    UINT16_t dot1qTag = 0;
 
     /* Can a server legally be behind this interface? */
     if (!iface->acOK) {
@@ -1325,8 +2177,6 @@
 	return;
     }
 
-    acIndex = iface - Interfaces;
-
     /* Source address must be unicast */
     if (NOT_UNICAST(packet->ethHdr.h_source)) {
 	syslog(LOG_ERR,
@@ -1361,28 +2211,12 @@
 	return;
     }
 
-    /* If it's the wrong length, ignore it */
-    if (ntohs(tag.length) != MY_RELAY_TAG_LEN) {
-	syslog(LOG_ERR,
-	       "PADS packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have correct length Relay-Session-Id tag",
-	       packet->ethHdr.h_source[0],
-	       packet->ethHdr.h_source[1],
-	       packet->ethHdr.h_source[2],
-	       packet->ethHdr.h_source[3],
-	       packet->ethHdr.h_source[4],
-	       packet->ethHdr.h_source[5],
-	       iface->name);
-	return;
-    }
-
-    /* Extract interface index */
-    memcpy(&ifIndex, tag.payload, sizeof(ifIndex));
+		psess = findPreSession(tag.payload, ntohs(tag.length));
 
-    if (ifIndex < 0 || ifIndex >= NumInterfaces ||
-	!Interfaces[ifIndex].clientOK ||
-	iface == &Interfaces[ifIndex]) {
+		/* If it is not found, log it and ignore it */
+		if (!psess) {
 	syslog(LOG_ERR,
-	       "PADS packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s has invalid interface in Relay-Session-Id tag",
+	       "PADS packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have correct length Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
 	       packet->ethHdr.h_source[2],
@@ -1408,9 +2242,10 @@
 
 	if (!ses) {
 	    /* Create a new session */
-	    ses = createSession(iface, &Interfaces[ifIndex],
+	    ses = createSession(iface, psess->interface,
 				packet->ethHdr.h_source,
-				loc + TAG_HDR_SIZE + sizeof(ifIndex), packet->session);
+				psess->clientMac, packet->session,
+				psess->dot1qTag);
 	    if (!ses) {
 		/* Can't allocate session -- send error PADS to client and
 		   PADT to server */
@@ -1420,12 +2255,12 @@
 		} else {
 		    hu = NULL;
 		}
-		relaySendError(CODE_PADS, htons(0), &Interfaces[ifIndex],
-			       loc + TAG_HDR_SIZE + sizeof(ifIndex),
-			       hu, "RP-PPPoE: Relay: Unable to allocate session");
+		relaySendError(CODE_PADS, htons(0), psess->interface,
+			       psess->clientMac,
+			       hu, "RP-PPPoE: Relay: Unable to allocate session", dot1qTag);
 		relaySendError(CODE_PADT, packet->session, iface,
 			       packet->ethHdr.h_source, NULL,
-			       "RP-PPPoE: Relay: Unable to allocate session");
+			       "RP-PPPoE: Relay: Unable to allocate session", 0);
 		return;
 	    }
 	}
@@ -1433,18 +2268,23 @@
 	packet->session = ses->sesNum;
     }
 
-    /* Remove relay-ID tag */
-    removeBytes(packet, loc, MY_RELAY_TAG_LEN + TAG_HDR_SIZE);
-    size -= (MY_RELAY_TAG_LEN + TAG_HDR_SIZE);
-
-    /* Set destination address to MAC address in relay ID */
-    memcpy(packet->ethHdr.h_dest, tag.payload + sizeof(ifIndex), ETH_ALEN);
+    /* Set destination address to MAC address in PreSession */
+    memcpy(packet->ethHdr.h_dest, psess->clientMac, ETH_ALEN);
 
     /* Set source address to MAC address of interface */
-    memcpy(packet->ethHdr.h_source, Interfaces[ifIndex].mac, ETH_ALEN);
+    memcpy(packet->ethHdr.h_source, psess->interface->mac, ETH_ALEN);
 
     /* Send the PADS to the proper client */
-    sendPacket(NULL, Interfaces[ifIndex].discoverySock, packet, size);
+#ifdef SUPPORT_8021Q_VLAN
+    if ( psess->interface->dot1q ) {
+	    packet = (PPPoEPacket*)relayTag8021QPacket(packet, &size, psess->dot1qTag);
+    }
+#endif
+    sendPacket(NULL, psess->interface->discoverySock, packet, size);
+
+		/* release the allocated PreSession */
+		unhashPreSession(psess);
+		releasePreSession(psess);
 }
 
 /**********************************************************************
@@ -1456,6 +2296,7 @@
 * mac -- Ethernet address to which frame should be sent
 * hostUniq -- if non-NULL, a hostUniq tag to add to error frame
 * errMsg -- error message to insert into Generic-Error tag.
+* dot1qTag -- 802.1Q Vlan ID to use when sending errors
 *%RETURNS:
 * Nothing
 *%DESCRIPTION:
@@ -1468,32 +2309,40 @@
 	       PPPoEInterface const *iface,
 	       unsigned char const *mac,
 	       PPPoETag const *hostUniq,
-	       char const *errMsg)
+	       char const *errMsg,
+	       UINT16_t dot1qTag)
 {
-    PPPoEPacket packet;
+    PPPoEPacket8021Q packet8021q;
+    PPPoEPacket* packet=&packet8021q.packet;
     PPPoETag errTag;
     int size;
 
-    memcpy(packet.ethHdr.h_source, iface->mac, ETH_ALEN);
-    memcpy(packet.ethHdr.h_dest, mac, ETH_ALEN);
-    packet.ethHdr.h_proto = htons(Eth_PPPOE_Discovery);
-    packet.type = 1;
-    packet.ver = 1;
-    packet.code = code;
-    packet.session = session;
-    packet.length = htons(0);
+    memcpy(packet->ethHdr.h_source, iface->mac, ETH_ALEN);
+    memcpy(packet->ethHdr.h_dest, mac, ETH_ALEN);
+    packet->ethHdr.h_proto = htons(Eth_PPPOE_Discovery);
+    packet->type = 1;
+    packet->ver = 1;
+    packet->code = code;
+    packet->session = session;
+    packet->length = htons(0);
     if (hostUniq) {
-	if (addTag(&packet, hostUniq) < 0) return;
+	if (addTag(packet, hostUniq) < 0) return;
     }
     errTag.type = htons(TAG_GENERIC_ERROR);
     errTag.length = htons(strlen(errMsg));
     strcpy(errTag.payload, errMsg);
-    if (addTag(&packet, &errTag) < 0) return;
-    size = ntohs(packet.length) + HDR_SIZE;
+    if (addTag(packet, &errTag) < 0) return;
+    size = ntohs(packet->length) + HDR_SIZE;
+
+#ifdef SUPPORT_8021Q_VLAN
+    if ( iface->dot1q ) {
+	    packet = (PPPoEPacket*)relayTag8021QPacket(packet, &size, dot1qTag);
+    }
+#endif
     if (code == CODE_PADT) {
-	sendPacket(NULL, iface->discoverySock, &packet, size);
+	sendPacket(NULL, iface->discoverySock, packet, size);
     } else {
-	sendPacket(NULL, iface->sessionSock, &packet, size);
+	sendPacket(NULL, iface->sessionSock, packet, size);
     }
 }
 
@@ -1539,11 +2388,23 @@
 	    relaySendError(CODE_PADT, cur->acHash->sesNum,
 			   cur->acHash->interface,
 			   cur->acHash->peerMac, NULL,
-			   "RP-PPPoE: Relay: Session exceeded idle timeout");
+			   "RP-PPPoE: Relay: Session exceeded idle timeout",
+#ifdef SUPPORT_8021Q_VLAN
+			   cur->dot1qTag
+#else
+			   0
+#endif
+			   );
 	    relaySendError(CODE_PADT, cur->clientHash->sesNum,
 			   cur->clientHash->interface,
 			   cur->clientHash->peerMac, NULL,
-			   "RP-PPPoE: Relay: Session exceeded idle timeout");
+			   "RP-PPPoE: Relay: Session exceeded idle timeout",
+#ifdef SUPPORT_8021Q_VLAN
+			   cur->dot1qTag
+#else
+			   0
+#endif
+			  );
 	    freeSession(cur, "Idle Timeout");
 	}
 	cur = next;
