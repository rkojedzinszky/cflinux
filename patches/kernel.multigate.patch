diff -NurpabB linux-2.4.27/Documentation/Configure.help linux-2.4.27-multigate/Documentation/Configure.help
--- linux-2.4.27/Documentation/Configure.help	2004-08-08 01:26:04.000000000 +0200
+++ linux-2.4.27-multigate/Documentation/Configure.help	2004-08-17 14:34:31.000000000 +0200
@@ -14467,14 +14467,27 @@ CONFIG_MTD_CSTM_MIPS_IXX_BUSWIDTH
   This is the total bus width of the mapping of the flash chips
   on your particular board.
 
-JEDEC Flash device mapped on Mixcom piggyback card
+JEDEC Flash device mapped on MixMEM/FlashCOM cards
 CONFIG_MTD_MIXMEM
-  This supports the paging arrangement for access to flash chips
-  on the MixCOM piggyback card, allowing the flash chip drivers
-  to get on with their job of driving the flash chips without
-  having to know about the paging. If you have one of these boards,
-  you probably want to enable this mapping driver. More info is at
-  <http://www.itc.hu/>.
+  If you say Y here and create block special file(s) /dev/flash[x] with
+  major number 31 and minor number x (0 for first, but move on to 1, 2
+  etc. if you have more flash devices) using mknod ("man mknod"), you
+  will get support for the paging arrangement for access to flash chips
+  on the MixCOM piggyback card (MixMEM) and the FlashCOM board.
+
+  This allows the flash chip drivers to get on with their job of
+  driving the flash chips without having to know about the paging.
+  If you have one of these boards, you probably want to enable this
+  mapping driver. More info is at <http://www.itc.hu/>.
+
+  This driver needs jedec (JEDEC device support, jedec.o) (at
+  RAM/ROM/Flash chip drivers) and mtdblock (Caching block device
+  access to MTD devices, mtdblock.o) to work.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mixmem.o. If you want to compile it as
+  a module, say M here and read <file:Documentation/modules.txt>.
 
 JEDEC Flash device mapped on Octagon 5066 SBC
 CONFIG_MTD_OCTAGON
diff -NurpabB linux-2.4.27/drivers/mtd/chips/jedec.c linux-2.4.27-multigate/drivers/mtd/chips/jedec.c
--- linux-2.4.27/drivers/mtd/chips/jedec.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.27-multigate/drivers/mtd/chips/jedec.c	2004-08-17 14:34:31.000000000 +0200
@@ -15,6 +15,7 @@
  */
 
 #include <linux/mtd/jedec.h>
+#include <asm/delay.h>
 
 static struct mtd_info *jedec_probe(struct map_info *);
 static int jedec_probe8(struct map_info *map,unsigned long base,
@@ -33,13 +34,14 @@ static unsigned long my_bank_size;
 
 /* Listing of parts and sizes. We need this table to learn the sector
    size of the chip and the total length */
-static const struct JEDECTable JEDEC_table[] = 
-  {{0x013D,"AMD Am29F017D",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
-   {0x01AD,"AMD Am29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
-   {0x01D5,"AMD Am29F080",1*1024*1024,64*1024,MTD_CAP_NORFLASH},
-   {0x01A4,"AMD Am29F040",512*1024,64*1024,MTD_CAP_NORFLASH},
-   {0x20E3,"AMD Am29W040B",512*1024,64*1024,MTD_CAP_NORFLASH},
-   {0xC2AD,"Macronix MX29F016",2*1024*1024,64*1024,MTD_CAP_NORFLASH},
+static const struct JEDECTable JEDEC_table[] = {
+   {0x013D, "AMD Am29F017D",	2*1024*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0x0141, "AMD Am29F032",     4*1024*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0x01AD, "AMD Am29F016",	2*1024*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0x01D5, "AMD Am29F080",	1*1024*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0x01A4, "AMD Am29F040",	512*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0x20E3, "AMD Am29W040B",	512*1024,	64*1024, MTD_CAP_NORFLASH},
+   {0xC2AD, "Macronix MX29F016",2*1024*1024,	64*1024, MTD_CAP_NORFLASH},
    {}};
 
 static const struct JEDECTable *jedec_idtoinf(__u8 mfr,__u8 id);
@@ -79,6 +81,14 @@ static struct mtd_info *jedec_probe(stru
    memset(MTD, 0, sizeof(struct mtd_info) + sizeof(struct jedec_private));
    priv = (struct jedec_private *)&MTD[1];
    
+   my_bank_size = 0;
+
+/*
+With this initialization, the loop would only run once, regardless of
+the number of chips on the card, thus failing to detect anything else
+than the first chip
+*/
+/*
    my_bank_size = map->size;
 
    if (map->size/my_bank_size > MAX_JEDEC_CHIPS)
@@ -87,6 +97,7 @@ static struct mtd_info *jedec_probe(stru
       kfree(MTD);
       return 0;
    }
+*/
    
    for (Base = 0; Base < map->size; Base += my_bank_size)
    {
@@ -96,9 +107,8 @@ static struct mtd_info *jedec_probe(stru
       
       if (map->buswidth == 1){
 	 if (jedec_probe8(map,Base,priv) == 0) {
-		 printk("did recognize jedec chip\n");
 		 kfree(MTD);
-	         return 0;
+	         break;
 	 }
       }
       if (map->buswidth == 2)
@@ -107,9 +117,16 @@ static struct mtd_info *jedec_probe(stru
 	 jedec_probe32(map,Base,priv);
    }
    
+/* If there are really no chips, quit */
+   if(!priv->chips[0].jedec)
+   {
+       printk("Jedec: did not recognize jedec chip\n");
+       return 0;
+   }
+
    // Get the biggest sector size
    SectorSize = 0;
-   for (I = 0; priv->chips[I].jedec != 0 && I < MAX_JEDEC_CHIPS; I++)
+   for (I = 0; priv->chips[I].jedec && I < MAX_JEDEC_CHIPS; I++)
    {
 	   //	   printk("priv->chips[%d].jedec is %x\n",I,priv->chips[I].jedec);
 	   //	   printk("priv->chips[%d].sectorsize is %lx\n",I,priv->chips[I].sectorsize);
@@ -128,6 +145,8 @@ static struct mtd_info *jedec_probe(stru
       }      
    }
    
+   printk(KERN_NOTICE "Jedec: detected %d chips total\n", I);
+
    /* Generate a part name that includes the number of different chips and
       other configuration information */
    count = 1;
@@ -193,7 +212,7 @@ static struct mtd_info *jedec_probe(stru
 		      
 		      /* This even could be eliminated, but new de-optimized read/write
 			 functions have to be written */
-		      printk("priv->bank_fill[%d] is %lx, priv->bank_fill[0] is %lx\n",I,priv->bank_fill[I],priv->bank_fill[0]);
+//		      printk("priv->bank_fill[%d] is %lx, priv->bank_fill[0] is %lx\n",I,priv->bank_fill[I],priv->bank_fill[0]);
 		      if (priv->bank_fill[I] != priv->bank_fill[0])
 		      {
 			 printk("mtd: Failed. Cannot handle unsymmetric banking\n");
@@ -218,7 +237,7 @@ static struct mtd_info *jedec_probe(stru
    //   printk("MTD->erasesize is %x\n",(unsigned int)MTD->erasesize);
    MTD->size = priv->size;
    //   printk("MTD->size is %x\n",(unsigned int)MTD->size);
-   //MTD->module = THIS_MODULE; // ? Maybe this should be the low level module?
+   MTD->module = THIS_MODULE; // ? Maybe this should be the low level module?
    MTD->erase = flash_erase;
    if (priv->is_banked == 1)
       MTD->read = jedec_read_banked;
@@ -312,12 +331,14 @@ static int handle_jedecs(struct map_info
 	 
       JEDEC = jedec_idtoinf(Mfg[J],Id[J]);
       priv->chips[I].jedec = (Mfg[J] << 8) | Id[J];
-      priv->chips[I].size = JEDEC->size;
+      my_bank_size = priv->chips[I].size = JEDEC->size;
       priv->chips[I].sectorsize = JEDEC->sectorsize;
       priv->chips[I].base = base + J;
       priv->chips[I].datashift = J*8;
       priv->chips[I].capabilities = JEDEC->capabilities;
       priv->chips[I].offset = priv->size + J;
+      printk(KERN_NOTICE "Jedec: found %s chip, size=0x%lX, sectorsize=0x%lX\n",
+      JEDEC->name, JEDEC->size, JEDEC->sectorsize);
 
       // log2 n :|
       priv->chips[I].addrshift = 0;
@@ -351,8 +372,8 @@ static const struct JEDECTable *jedec_id
 static int jedec_probe8(struct map_info *map,unsigned long base,
 		  struct jedec_private *priv)
 { 
-   #define flread(x) map->read8(map,base+x)
-   #define flwrite(v,x) map->write8(map,v,base+x)
+#define flread(x) map->read8(map,base+x)
+#define flwrite(v,x) map->write8(map,v,base+x)
 
    const unsigned long AutoSel1 = 0xAA;
    const unsigned long AutoSel2 = 0x55;
@@ -396,8 +417,8 @@ static int jedec_probe8(struct map_info 
    
    return 1;
    
-   #undef flread
-   #undef flwrite
+#undef flread
+#undef flwrite
 }
 
 // Look for flash using a 16 bit bus interface (ie 2 8-bit chips)
@@ -480,8 +501,8 @@ static int jedec_probe32(struct map_info
    
    return 1;
    
-   #undef flread
-   #undef flwrite
+#undef flread
+#undef flwrite
 }
 
 /* Linear read. */
@@ -545,8 +566,8 @@ static void jedec_flash_failed(unsigned 
 static int flash_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
    // Does IO to the currently selected chip
-   #define flread(x) map->read8(map,chip->base+((x)<<chip->addrshift))
-   #define flwrite(v,x) map->write8(map,v,chip->base+((x)<<chip->addrshift))
+#define flread(x) map->read8(map,chip->base+((x)<<chip->addrshift))
+#define flwrite(v,x) map->write8(map,v,chip->base+((x)<<chip->addrshift))
    
    unsigned long Time = 0;
    unsigned long NoTime = 0;
@@ -693,8 +714,8 @@ static int flash_erase(struct mtd_info *
 	       todo_left--;
 	    }
 	    
-/*	    if (NoTime == 0)
-	       Time += HZ/10 - schedule_timeout(HZ/10);*/
+	    if (NoTime == 0)
+	       Time += HZ/10  - schedule_timeout(HZ/10);
 	    NoTime = 0;
 
 	    switch (map->buswidth) {
@@ -710,12 +731,12 @@ static int flash_erase(struct mtd_info *
 	    }
 	    Count++;
 	    
-/*	    // Count time, max of 15s per sector (according to AMD)
+	    // Count time, max of 15s per sector (according to AMD)
 	    if (Time > 15*len/mtd->erasesize*HZ)
 	    {
 	       printk("mtd: Flash Erase Timed out\n");
 	       return -EIO;
-	    }	    */
+	    }
 	 }
 	 	 
 	 // Skip to the next chip if we used chip erase
@@ -743,8 +764,8 @@ static int flash_erase(struct mtd_info *
 	instr->callback(instr);
    return 0;
    
-   #undef flread
-   #undef flwrite
+#undef flread
+#undef flwrite
 }
 
 /* This is the simple flash writing function. It writes to every byte, in
@@ -757,8 +778,8 @@ static int flash_write(struct mtd_info *
    /* Does IO to the currently selected chip. It takes the bank addressing
       base (which is divisable by the chip size) adds the necesary lower bits
       of addrshift (interleve index) and then adds the control register index. */
-   #define flread(x) map->read8(map,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
-   #define flwrite(v,x) map->write8(map,v,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
+#define flread(x) map->read8(map,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
+#define flwrite(v,x) map->write8(map,v,base+(off&((1<<chip->addrshift)-1))+((x)<<chip->addrshift))
    
    struct map_info *map = (struct map_info *)mtd->priv;
    struct jedec_private *priv = (struct jedec_private *)map->fldrv_priv;
@@ -806,9 +827,9 @@ static int flash_write(struct mtd_info *
 	    printk("mtd: warn: Trying to set a 0 to a 1\n");
 	     
 	 // Write
-	 flwrite(0xAA,0x555);
-	 flwrite(0x55,0x2AA);
-	 flwrite(0xA0,0x555);
+	 flwrite(0xAA, chip->base + 0x555);
+	 flwrite(0x55, chip->base + 0x2AA);
+	 flwrite(0xA0, chip->base + 0x555);
 	 map->write8(map,*buf,base + off);
 	 Last[0] = map->read8(map,base + off);
 	 Last[1] = map->read8(map,base + off);
@@ -819,8 +840,13 @@ static int flash_write(struct mtd_info *
 	    it failed. The toggle bits keep toggling when there is a 
 	    failure */
 	 for (Count = 3; Last[(Count - 1) % 4] != Last[(Count - 2) % 4] &&
-	      Count < 10000; Count++)
+        	Count < 50; Count++)
+	{
+       		udelay(3);
 	    Last[Count % 4] = map->read8(map,base + off);
+	}
+
+
 	 if (Last[(Count - 1) % 4] != *buf)
 	 {
 	    jedec_flash_failed(Last[(Count - 3) % 4]);
diff -NurpabB linux-2.4.27/drivers/mtd/maps/Makefile linux-2.4.27-multigate/drivers/mtd/maps/Makefile
--- linux-2.4.27/drivers/mtd/maps/Makefile	2003-06-13 16:51:34.000000000 +0200
+++ linux-2.4.27-multigate/drivers/mtd/maps/Makefile	2004-08-17 14:34:31.000000000 +0200
@@ -34,6 +34,7 @@ ifneq ($(CONFIG_MTD_PHYSMAP),n)
     obj-$(CONFIG_MTD_PHYSMAP)	+= physmap.o 
   endif
 endif
+obj-$(CONFIG_MTD_MIXMEM)	+= mixmem.o
 obj-$(CONFIG_MTD_PNC2000)	+= pnc2000.o
 obj-$(CONFIG_MTD_PCMCIA)	+= pcmciamtd.o
 obj-$(CONFIG_MTD_RPXLITE)	+= rpxlite.o
diff -NurpabB linux-2.4.27/drivers/mtd/maps/mixmem.c linux-2.4.27-multigate/drivers/mtd/maps/mixmem.c
--- linux-2.4.27/drivers/mtd/maps/mixmem.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.27-multigate/drivers/mtd/maps/mixmem.c	2004-08-17 14:34:31.000000000 +0200
@@ -0,0 +1,430 @@
+/*
+* mixmem - device driver for flash rom found on the flashcom and
+*          piggyback board of the multi-purpose mixcom card
+*
+* Copyright: Szilard Pasztor <don@itc.hu> and
+*            ITConsult-Pro Co. <info@itc.hu>
+*
+* If compiled as a module, it can take a parameter that may contain
+* * "ro" (disable write to the flash)
+* * "force" (force module loading even if the memory address appears
+*            already mapped, this may occur if the flash contains an
+*            extension ROM image recognized by the kernel early on)
+* * or both ("roforce" for example).
+*
+* parts of code borrowed from nbd.c and xd.c
+* partly based on code by Gergely Madarasz <gorgo@itc.hu>
+*
+* This code is GPL
+*/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/ioport.h>
+#include <linux/malloc.h>
+#include <asm/delay.h>
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/init.h> 
+#include <linux/spinlock.h>
+#include <asm/io.h>
+
+#include <linux/mtd/map.h>
+
+/* This call is only needed to autoload the mtdblock module.            *
+ * WARNING: If the mtdblock_thread function becomes declared as static, *
+ * the module has to be loaded manually.                                */
+extern int mtdblock_thread(void);
+
+static unsigned int mixmem_addrs[] = { 0xc0000, 0xc4000, 0xc8000, 0xcc000,
+				       0xd0000, 0xd4000, 0xd8000, 0xdc000, 0 };
+
+static unsigned int mixcom_ports[] = { 0x180, 0x280, 0x380, 0 };
+static unsigned int flashcom_ports[] = { 0x300, 0x308, 0x310, 0x318, 0x320,
+					 0x328, 0x330, 0x338, 0x340, 0x348, 0x350,
+					 0x358, 0x360, 0x368, 0x370, 0x378, 0 };
+
+//#define MIXMEM_DEBUG
+
+static unsigned long iomapaddr, phys_address, pagesize;
+
+static void *virt_address;
+
+static int port, readonly, force;
+
+static char* mode = "rw";
+
+#define MIXCOM_ID_OFFSET 0xc10
+#define MIXCOM_PAGE_OFFSET 0xc11
+#define MIXCOM_ID 0x11
+
+#define FLASHCOM_ID 0x18
+
+#define FIRST_BLOCK_OFFSET 4096
+
+#define MIN(a, b) ((a < b) ? a : b)
+#define MAX(a, b) ((a > b) ? a : b)
+
+static spinlock_t mixmem_spin = SPIN_LOCK_UNLOCKED;
+
+MODULE_PARM(mode, "s");
+
+/* The paging function. 12 bits of the page register are relevant.
+   We store the page register in a private tag since paging costs time */
+static inline void mixmem_page(struct map_info *map, unsigned long linear_addr)
+{
+    int pagecount;
+
+    pagecount = linear_addr / pagesize;
+
+    if (map->map_priv_1 != pagecount)
+    {
+	outb(pagecount & 255, port + 1);
+	outb((pagecount >> 8) & 15, port + 2);
+	map->map_priv_1 = pagecount;
+    }
+}
+
+/* Read one byte from a linear address */
+static __u8 mixmem_read8(struct map_info *map, unsigned long flashaddr)
+{
+    __u8 ret;
+
+    spin_lock(&mixmem_spin);
+    mixmem_page(map, flashaddr);
+    ret = readb(virt_address + flashaddr % pagesize);
+    spin_unlock(&mixmem_spin);
+    return ret;
+}
+
+/* Just to have mtdblock loaded */
+static void nevercalled(void)
+{
+    mtdblock_thread();
+}
+
+/* Read a block beginning at the linear address */
+static void mixmem_copyfrom(struct map_info *map, void *mem_to,
+		unsigned long flash_from, ssize_t len)
+{
+    unsigned long thislen;
+    unsigned long mask = pagesize - 1;
+
+    while (len)
+    {
+	thislen = len;
+
+	if (len > (pagesize - (flash_from & mask)))
+	    thislen = pagesize - (flash_from & mask);
+	spin_lock(&mixmem_spin);
+	mixmem_page(map, flash_from);
+	memcpy_fromio(mem_to, iomapaddr + (flash_from & mask), thislen);
+	spin_unlock(&mixmem_spin);
+	mem_to += thislen;
+	flash_from += thislen;
+	len -= thislen;
+    }
+}
+
+/* Write one byte to a linear address */
+static void mixmem_write8(struct map_info *map, __u8 what, unsigned long flashaddr)
+{
+    if (readonly) return;
+
+    spin_lock(&mixmem_spin);
+    mixmem_page(map, flashaddr);
+    writeb(what, virt_address + flashaddr % pagesize);
+    spin_unlock(&mixmem_spin);
+}
+
+/* JEDEC does NOT use this function (yet?), it writes bytewise instead */
+/* Read a block beginning at the linear address */
+static void mixmem_copyto(struct map_info *map, unsigned long flash_to,
+			const void *mem_from, ssize_t len)
+{
+    unsigned long thislen;
+    unsigned long mask = pagesize - 1;
+
+    if (readonly) return;
+
+    while (len)
+    {
+	thislen = len;
+
+	if (len > (pagesize - (flash_to & mask)))
+	    thislen = pagesize - (flash_to & mask);
+	spin_lock(&mixmem_spin);
+	mixmem_page(map, flash_to);
+	memcpy_toio(iomapaddr + (flash_to & mask), mem_from, thislen);
+	spin_unlock(&mixmem_spin);
+	mem_from += thislen;
+	flash_to += thislen;
+	len -= thislen;
+    }
+}
+
+/* Our reference structure for the device */
+static struct map_info mixmem_map =
+{
+    name: "FlashCOM/MixCOM Onboard Flash",
+    buswidth: 1,
+    read8: mixmem_read8,
+    copy_from: mixmem_copyfrom,
+    write8: mixmem_write8,
+    copy_to: mixmem_copyto,
+    map_priv_1: 0	// always the current content of the page register
+};
+
+/* Expandable array if necessary (more cards) */
+static struct
+{
+    char *name;
+    unsigned int maxchips;
+    unsigned int pagereg_offset;
+} *cardtype, flash_card[] =
+{
+    { "FlashCOM", 8, 0 },
+    { "MixMEM", 4, 1 }
+};
+
+/* Is JEDEC supposed to do this task? So far, it seems to fail.
+   Or I fail in understanding the code. So this function stays in */
+int flash_probe(const void *base)
+{
+    int prev, curr;
+    unsigned long flags;
+
+    writeb(0xf0, base);
+    save_flags(flags);
+    cli();
+
+    prev = readw(base);
+
+    writeb(0xaa, base + 0x555);
+    writeb(0x55, base + 0x2AA);
+    writeb(0x90, base + 0x555);
+
+    curr = readw(base);
+
+    restore_flags(flags);
+#ifdef MIXMEM_DEBUG
+    printk("prev: 0x%04x, returned value: 0x%04x\n", prev, curr);
+#endif
+    writeb(0xf0, base);
+    return curr == 0xd501 ? curr : 0;
+    return prev == curr ? 0 : curr;
+}
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_mixmem init_module
+#define cleanup_mixmem cleanup_module
+#endif
+
+static struct mtd_info *mixmem_mtd = NULL;
+
+static int recursive_shutdown(unsigned char flagsbyte)
+{
+    int errcode = 0;
+
+    if (flagsbyte & 8)
+    {
+	printk(KERN_ERR "Mixmem: Terrible! Unable to allocate IO space for %s, try again\n", cardtype->name);
+	errcode = -EAGAIN;
+    }
+    if (flagsbyte & 4)
+    {
+	iounmap((void *) iomapaddr);
+	if (!errcode) errcode = -ENODEV;
+    }
+    if ((flagsbyte & 2) && !force)
+    {
+	release_mem_region(phys_address, pagesize * 2);
+	if (!errcode) errcode = -EIO;
+    }
+    if (flagsbyte & 1)
+    {
+	release_region(port + cardtype->pagereg_offset,
+		cardtype == &flash_card[0] ? 5 : 2);
+	if (!errcode) errcode = -ENXIO;
+    }
+    return errcode;
+}
+
+static void __exit cleanup_mixmem(void)
+{
+    if (mixmem_mtd)
+    {
+	del_mtd_device(mixmem_mtd);
+
+/* This call causes the kernel to collapse since do_map_probe
+   for jedec doesn't initialize the map->fldrv->destroy
+   pointer. So, for now, we just skip calling this function
+
+	map_destroy(mixmem_mtd);
+*/
+
+// Decrease JEDEC module's use count
+	__MOD_DEC_USE_COUNT(mixmem_mtd->module);
+    }
+    recursive_shutdown(7);
+}
+
+int __init init_mixmem(void)
+{
+    int i, id, mem_ro = 0;
+
+    for (port = i = 0; flashcom_ports[i]; i++)
+    {
+	id = inb(flashcom_ports[i]) & 0x7f;
+	if (id == FLASHCOM_ID)
+	{
+#ifdef MIXMEM_DEBUG
+	    printk("Mixmem: FlashCOM candidate at 0x%3X\n", flashcom_ports[i]);
+#endif
+	    if ((inb(flashcom_ports[i] + 3) & 0x7f) == id
+		    && (inb(flashcom_ports[i] + 3) & 0x7f) == id)
+	    {
+		cardtype = &flash_card[0];
+
+		if (!request_region
+			(flashcom_ports[i], 5, flash_card[0].name))
+		    return recursive_shutdown(8);
+
+		port = flashcom_ports[i];
+		break;
+	    }
+	}
+    }
+
+    if (!port)	// No flashcom. Is there a mixcom?
+    {
+	for (i = 0; mixcom_ports[i]; i++)
+	{
+	    id = inb(mixcom_ports[i] + MIXCOM_ID_OFFSET);
+	    if (id == MIXCOM_ID)
+	    {
+		cardtype = &flash_card[1];
+
+		if (!request_region
+			(mixcom_ports[i] +
+			 MIXCOM_PAGE_OFFSET, 2, flash_card[1].name))
+		    return recursive_shutdown(8);
+		port = mixcom_ports[i];
+		break;
+	    }
+	}
+    }
+
+    if (port)
+    {
+	printk("Mixmem: %s board (%s) found at IO=0x%3X", cardtype->name,
+	    strstr(mode, "ro") ? "read-only" : "read-write", port);
+    }
+    else
+    {
+	printk("Mixmem: no flash card found\n");
+	return -ENODEV;
+    }
+
+#ifdef MIXMEM_DEBUG
+    printk("\nMixmem: probing for flash\n");
+#endif
+    if (cardtype == &flash_card[0])	// Flashcom
+    {
+	printk("\n");
+	if (!(inb(port + 2) & 0x08))
+	{
+	    printk(KERN_ERR "Mixmem: flash memory enable jumper not present! Aborting...\n");
+	    return recursive_shutdown(1);
+	}
+	if ((inb(port + 2) & 0x80) && !mem_ro)
+	{
+	    printk(KERN_NOTICE "Mixmem: memory write disabled by jumper, treating as ROM\n");
+	    mem_ro = 1;
+	}
+
+	pagesize = 2 * FIRST_BLOCK_OFFSET;
+	phys_address = 0xC0000 + ((inb(port + 2) & 0x7) << 14);
+	mixmem_map.size = inb(port + 1) * 1024 * 1024;
+	virt_address = phys_to_virt(phys_address);
+    }
+    else				// Mixcom
+    {
+	for (i = 0; mixmem_addrs[i]; i++)
+	{
+	    id = flash_probe(phys_to_virt(mixmem_addrs[i] + 2 * FIRST_BLOCK_OFFSET));
+	    if (id)
+	    {
+		pagesize = 2 * FIRST_BLOCK_OFFSET;
+		break;
+	    }
+	    id = flash_probe(phys_to_virt(mixmem_addrs[i] + FIRST_BLOCK_OFFSET));
+	    if (id)
+	    {
+		pagesize = FIRST_BLOCK_OFFSET;
+		break;
+	    }
+	}
+	printk(" (at 0x%X, pagesize=%luK)\n", port +=
+		MIXCOM_ID_OFFSET, pagesize >> 10);
+
+	if (mixmem_addrs[i])
+	{
+	    phys_address = mixmem_addrs[i];
+	    virt_address = phys_to_virt(phys_address);
+	}
+	else
+	{
+	    printk(KERN_ERR "Mixmem: no flash chip found\n");
+	    return recursive_shutdown(1);
+	}
+
+	mixmem_map.size = 16 * 1024 * 1024;	// max flash size
+    }
+
+    force = strstr(mode, "force") ? 1 : 0;
+    mem_ro = (strstr(mode, "ro") || mem_ro) ? 1 : 0;
+
+    if (!request_mem_region(phys_address, pagesize * 2, cardtype->name) && !force)
+    {
+	printk(KERN_ERR "Mixmem: memory address conflict at %08lX\n", phys_address);
+	return recursive_shutdown(1);
+    }
+
+    iomapaddr = (unsigned long) ioremap_nocache(phys_address, pagesize * 2);
+    if (!iomapaddr)
+    {
+	printk(KERN_ERR "Mixmem: failed to ioremap memory region\n");
+	return recursive_shutdown(3);
+    }
+
+    outb(0, port + 1);	// We must initialize the page register
+    outb(0, port + 2);
+
+    if (!(mixmem_mtd = do_map_probe("jedec", &mixmem_map)))
+    {
+	printk(KERN_ERR "Mixmem: no flash chip found\n");
+	return recursive_shutdown(7);
+    }
+
+    printk("Mixmem: %s memory address=0x%lX, flash size=%uK\n",
+	cardtype->name, phys_address, mixmem_mtd->size >> 10);
+
+    if (add_mtd_device(mixmem_mtd))
+    {
+	map_destroy(mixmem_mtd);
+	recursive_shutdown(7);
+	return -ENOLCK;
+    }
+    readonly = mem_ro;
+    return 0;
+}
+
+module_init(init_mixmem);
+module_exit(cleanup_mixmem);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Pásztor Szilárd <don@itc.hu>");
+MODULE_DESCRIPTION("MTD map driver for FlashCOM and MixMEM boards");
diff -NurpabB linux-2.4.27/drivers/net/wan/comx.c linux-2.4.27-multigate/drivers/net/wan/comx.c
--- linux-2.4.27/drivers/net/wan/comx.c	2002-08-03 02:39:44.000000000 +0200
+++ linux-2.4.27-multigate/drivers/net/wan/comx.c	2004-08-17 14:34:31.000000000 +0200
@@ -60,6 +60,7 @@
 #include <linux/types.h>
 #include <linux/sched.h>
 #include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
 #include <linux/proc_fs.h>
 #include <asm/uaccess.h>
 #include <linux/ctype.h>
@@ -113,7 +114,8 @@ static struct dentry_operations comx_den
 
 static struct proc_dir_entry * comx_root_dir;
 
-struct comx_debugflags_struct	comx_debugflags[] = {
+struct comx_debugflags_struct	comx_debugflags[] =
+{
 	{ "comx_rx",		DEBUG_COMX_RX		},
 	{ "comx_tx", 		DEBUG_COMX_TX		},
 	{ "hw_tx",		DEBUG_HW_TX		},
@@ -614,6 +616,7 @@ static int comx_write_proc(struct file *
 	struct comx_protocol *line = comx_lines;
 	char str[30];
 	int ret=0;
+	spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 
 	if (count > PAGE_SIZE) {
 		printk(KERN_ERR "count is %lu > %d!!!\n", count, (int)PAGE_SIZE);
@@ -644,14 +647,14 @@ static int comx_write_proc(struct file *
 		if ((i = simple_strtoul(page, NULL, 10)) != 0) {
 			unsigned long flags;
 
-			save_flags(flags); cli();
+			spin_lock_irqsave(&mister_lock, flags);
 			if (ch->debug_area) kfree(ch->debug_area);
 			if ((ch->debug_area = kmalloc(ch->debug_size = i, 
 				GFP_KERNEL)) == NULL) {
 				ret = -ENOMEM;
 			}
 			ch->debug_start = ch->debug_end = 0;
-			restore_flags(flags);
+			spin_unlock_irqrestore(&mister_lock, flags);
 			free_page((unsigned long)page);
 			return ret ? ret : count;
 		}
@@ -829,9 +832,15 @@ static int comx_mkdir(struct inode *dir,
 	strcpy(dev->name, (char *)new_dir->name);
 	dev->init = comx_init_dev;
 
-	if (register_netdevice(dev)) {
+	{
+	    int ret2;
+	    rtnl_lock();
+	    ret2 = register_netdevice(dev);
+	    rtnl_unlock();
+	    if (ret2)
 		goto cleanup_filename_debug;
 	}
+
 	ch=dev->priv;
 	if((ch->if_ptr = (void *)kmalloc(sizeof(struct ppp_device), 
 				 GFP_KERNEL)) == NULL) {
diff -NurpabB linux-2.4.27/drivers/net/wan/comx-hw-comx.c linux-2.4.27-multigate/drivers/net/wan/comx-hw-comx.c
--- linux-2.4.27/drivers/net/wan/comx-hw-comx.c	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.27-multigate/drivers/net/wan/comx-hw-comx.c	2004-08-17 14:34:31.000000000 +0200
@@ -1,11 +1,12 @@
 /*
  * Hardware-level driver for the COMX and HICOMX cards
- * for Linux kernel 2.2.X
+ * for Linux kernel 2.4.X
  *
  * Original authors:  Arpad Bakay <bakay.arpad@synergon.hu>,
  *                    Peter Bajan <bajan.peter@synergon.hu>,
  * Rewritten by: Tivadar Szemethy <tiv@itc.hu>
- * Currently maintained by: Gergely Madarasz <gorgo@itc.hu>
+ * Previous maintainer: Gergely Madarasz <gorgo@itc.hu>
+ * Currently maintained by: Szilard Pasztor <don@itc.hu>
  *
  * Copyright (C) 1995-2000 ITConsult-Pro Co. <info@itc.hu>
  *
@@ -61,28 +62,31 @@
 #include "comx.h"
 #include "comxhw.h"
 
-MODULE_AUTHOR("Gergely Madarasz <gorgo@itc.hu>, Tivadar Szemethy <tiv@itc.hu>, Arpad Bakay");
+MODULE_AUTHOR
+    ("Gergely Madarasz <gorgo@itc.hu>, Tivadar Szemethy <tiv@itc.hu>, Arpad Bakay");
 MODULE_DESCRIPTION("Hardware-level driver for the COMX and HICOMX adapters\n");
 MODULE_LICENSE("GPL");
 
-#define	COMX_readw(dev, offset)	(readw(dev->mem_start + offset + \
+#define	COMX_readw(dev, offset)	(readw(phys_to_virt(dev->mem_start + offset + \
 	(unsigned int)(((struct comx_privdata *)\
 	((struct comx_channel *)dev->priv)->HW_privdata)->channel) \
-	* COMX_CHANNEL_OFFSET))
+	* COMX_CHANNEL_OFFSET)))
 
-#define COMX_WRITE(dev, offset, value)	(writew(value, dev->mem_start + offset \
+#define COMX_WRITE(dev, offset, value)	(writew(value, phys_to_virt(dev->mem_start + offset \
 	+ (unsigned int)(((struct comx_privdata *) \
 	((struct comx_channel *)dev->priv)->HW_privdata)->channel) \
-	* COMX_CHANNEL_OFFSET))
+	* COMX_CHANNEL_OFFSET)))
 
 #define COMX_CMD(dev, cmd)	(COMX_WRITE(dev, OFF_A_L2_CMD, cmd))
 
-struct comx_firmware {
+struct comx_firmware
+{
 	int	len;
 	unsigned char *data;
 };
 
-struct comx_privdata {
+struct comx_privdata
+{
 	struct comx_firmware *firmware;
 	u16	clock;
 	char	channel;		// channel no.
@@ -100,26 +104,30 @@ static void COMX_interrupt(int irq, void
 
 static void COMX_board_on(struct net_device *dev)
 {
-	outb_p( (byte) (((dev->mem_start & 0xf0000) >> 16) | 
-	    COMX_ENABLE_BOARD_IT | COMX_ENABLE_BOARD_MEM), dev->base_addr);
+    outb_p((byte)
+	   (((dev->
+	      mem_start & 0xf0000) >> 16) | COMX_ENABLE_BOARD_IT |
+	    COMX_ENABLE_BOARD_MEM), dev->base_addr);
 }
 
 static void COMX_board_off(struct net_device *dev)
 {
-	outb_p( (byte) (((dev->mem_start & 0xf0000) >> 16) | 
-	   COMX_ENABLE_BOARD_IT), dev->base_addr);
+    outb_p((byte) (((dev->mem_start & 0xf0000) >> 16) | COMX_ENABLE_BOARD_IT),
+	   dev->base_addr);
 }
 
 static void HICOMX_board_on(struct net_device *dev)
 {
-	outb_p( (byte) (((dev->mem_start & 0xf0000) >> 12) | 
-	   HICOMX_ENABLE_BOARD_MEM), dev->base_addr);
+    outb_p((byte)
+	   (((dev->mem_start & 0xf0000) >> 12) | HICOMX_ENABLE_BOARD_MEM),
+	   dev->base_addr);
 }
 
 static void HICOMX_board_off(struct net_device *dev)
 {
-	outb_p( (byte) (((dev->mem_start & 0xf0000) >> 12) | 
-	   HICOMX_DISABLE_BOARD_MEM), dev->base_addr);
+    outb_p((byte)
+	   (((dev->mem_start & 0xf0000) >> 12) | HICOMX_DISABLE_BOARD_MEM),
+	   dev->base_addr);
 }
 
 static void COMX_set_clock(struct net_device *dev)
@@ -134,48 +142,56 @@ static struct net_device *COMX_access_bo
 {
 	struct comx_channel *ch = dev->priv;
 	struct net_device *ret;
-	int mempos = (dev->mem_start - COMX_MEM_MIN) >> 16;
+    unsigned long mempos =
+	(unsigned long)phys_to_virt((dev->mem_start - COMX_MEM_MIN) >> 16);
 	unsigned long flags;
+    spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 
-
-	save_flags(flags); cli();
-	
+    spin_lock_irqsave(&mister_lock, flags);
 	ret = memory_used[mempos];
 
-	if(ret == dev) {
+    if (ret == dev)
+    {
 		goto out;
 	}
 
 	memory_used[mempos] = dev;
 
-	if (!ch->twin || ret != ch->twin) {
-		if (ret) ((struct comx_channel *)ret->priv)->HW_board_off(ret);
+    if (!ch->twin || ret != ch->twin)
+    {
+	if (ret)
+	    ((struct comx_channel *)ret->priv)->HW_board_off(ret);
 		ch->HW_board_on(dev);
 	}
-out:
-	restore_flags(flags);
+  out:
+    spin_unlock_irqrestore(&mister_lock, flags);
 	return ret;
 }
 
 static void COMX_release_board(struct net_device *dev, struct net_device *savep)
 {
 	unsigned long flags;
-	int mempos = (dev->mem_start - COMX_MEM_MIN) >> 16;
+    unsigned long mempos =
+	(unsigned long)phys_to_virt((dev->mem_start - COMX_MEM_MIN) >> 16);
 	struct comx_channel *ch = dev->priv;
+    spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 
-	save_flags(flags); cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
-	if (memory_used[mempos] == savep) {
+    if (memory_used[mempos] == savep)
+    {
 		goto out;
 	}
 
 	memory_used[mempos] = savep;
-	if (!ch->twin || ch->twin != savep) {
+    if (!ch->twin || ch->twin != savep)
+    {
 		ch->HW_board_off(dev);
-		if (savep) ((struct comx_channel*)savep->priv)->HW_board_on(savep);
+	if (savep)
+	    ((struct comx_channel *)savep->priv)->HW_board_on(savep);
 	}
-out:
-	restore_flags(flags);
+  out:
+    spin_unlock_irqrestore(&mister_lock, flags);
 }
 
 static int COMX_txe(struct net_device *dev) 
@@ -185,13 +201,13 @@ static int COMX_txe(struct net_device *d
 	int rc = 0;
 
 	savep = ch->HW_access_board(dev);
-	if (COMX_readw(dev,OFF_A_L2_LINKUP) == LINKUP_READY) {
-		rc = COMX_readw(dev,OFF_A_L2_TxEMPTY);
-	} 
-	ch->HW_release_board(dev,savep);
-	if(rc==0xffff) {
-		printk(KERN_ERR "%s, OFF_A_L2_TxEMPTY is %d\n",dev->name, rc);
+    if (COMX_readw(dev, OFF_A_L2_LINKUP) == LINKUP_READY)
+    {
+	rc = COMX_readw(dev, OFF_A_L2_TxEMPTY);
 	}
+    ch->HW_release_board(dev, savep);
+    if (rc == 0xffff)
+	printk(KERN_ERR "%s, OFF_A_L2_TxEMPTY is %d\n", dev->name, rc);
 	return rc;
 }
 
@@ -205,50 +221,58 @@ static int COMX_send_packet(struct net_d
 
 	savep = ch->HW_access_board(dev);	
 
-	if (ch->debug_flags & DEBUG_HW_TX) {
-		comx_debug_bytes(dev, skb->data, skb->len,"COMX_send packet");
-	}
+    if (ch->debug_flags & DEBUG_HW_TX)
+	comx_debug_bytes(dev, skb->data, skb->len, "COMX_send packet");
 
-	if (skb->len > COMX_MAX_TX_SIZE) {
-		ret=FRAME_DROPPED;
+    if (skb->len > COMX_MAX_TX_SIZE)
+    {
+	ret = FRAME_DROPPED;
 		goto out;
 	}
 
-	tmp=COMX_readw(dev, OFF_A_L2_TxEMPTY);
-	if ((ch->line_status & LINE_UP) && tmp==1) {
+    tmp = COMX_readw(dev, OFF_A_L2_TxEMPTY);
+    if ((ch->line_status & LINE_UP) && tmp == 1)
+    {
 		int lensave = skb->len;
 		int dest = COMX_readw(dev, OFF_A_L2_TxBUFP);
-		word *data = (word *)skb->data;
+	word *data = (word *) skb->data;
 
-		if(dest==0xffff) {
+	if (dest == 0xffff)
+	{
 			printk(KERN_ERR "%s: OFF_A_L2_TxBUFP is %d\n", dev->name, dest);
-			ret=FRAME_DROPPED;
+	    ret = FRAME_DROPPED;
 			goto out;
 		}
 					
-		writew((unsigned short)skb->len, dev->mem_start + dest);
+	writew((unsigned short)skb->len, phys_to_virt(dev->mem_start + dest));
+	dest += 2;
+	while (skb->len > 1)
+	{
+	    writew(*data++, phys_to_virt(dev->mem_start + dest));
 		dest += 2;
-		while (skb->len > 1) {
-			writew(*data++, dev->mem_start + dest);
-			dest += 2; skb->len -= 2;
+	    skb->len -= 2;
 		}
-		if (skb->len == 1) {
-			writew(*((byte *)data), dev->mem_start + dest);
+	if (skb->len == 1)
+	{
+	    writew(*((byte *) data), phys_to_virt(dev->mem_start + dest));
 		}
-		writew(0, dev->mem_start + (int)hw->channel * 
-		   COMX_CHANNEL_OFFSET + OFF_A_L2_TxEMPTY);
+	writew(0,
+	       dev->mem_start +
+	       phys_to_virt((int)hw->channel * COMX_CHANNEL_OFFSET +
+			    OFF_A_L2_TxEMPTY));
 		ch->stats.tx_packets++;	
 		ch->stats.tx_bytes += lensave; 
 		ret = FRAME_ACCEPTED;
-	} else {
-		ch->stats.tx_dropped++;
-		printk(KERN_INFO "%s: frame dropped\n",dev->name);
-		if(tmp) {
-			printk(KERN_ERR "%s: OFF_A_L2_TxEMPTY is %d\n",dev->name,tmp);
 		}
+    else
+    {
+	ch->stats.tx_dropped++;
+	printk(KERN_INFO "%s: frame dropped\n", dev->name);
+	if (tmp)
+	    printk(KERN_ERR "%s: OFF_A_L2_TxEMPTY is %d\n", dev->name, tmp);
 	}
 	
-out:
+  out:
 	ch->HW_release_board(dev, savep);
 	dev_kfree_skb(skb);
 	return ret;
@@ -260,21 +284,24 @@ static inline int comx_read_buffer(struc
 	word rbuf_offs;
 	struct sk_buff *skb;
 	word len;
-	int i=0;
+    int i = 0;
 	word *writeptr;
 
 	i = 0;
 	rbuf_offs = COMX_readw(dev, OFF_A_L2_RxBUFP);
-	if(rbuf_offs == 0xffff) {
-		printk(KERN_ERR "%s: OFF_A_L2_RxBUFP is %d\n",dev->name,rbuf_offs);
+    if (rbuf_offs == 0xffff)
+    {
+	printk(KERN_ERR "%s: OFF_A_L2_RxBUFP is %d\n", dev->name, rbuf_offs);
 		return 0;
 	}
-	len = readw(dev->mem_start + rbuf_offs);
-	if(len > COMX_MAX_RX_SIZE) {
-		printk(KERN_ERR "%s: packet length is %d\n",dev->name,len);
+    len = readw(phys_to_virt(dev->mem_start + rbuf_offs));
+    if (len > COMX_MAX_RX_SIZE)
+    {
+	printk(KERN_ERR "%s: packet length is %d\n", dev->name, len);
 		return 0;
 	}
-	if ((skb = dev_alloc_skb(len + 16)) == NULL) {
+    if ((skb = dev_alloc_skb(len + 16)) == NULL)
+    {
 		ch->stats.rx_dropped++;
 		COMX_WRITE(dev, OFF_A_L2_DAV, 0);
 		return 0;
@@ -283,49 +310,58 @@ static inline int comx_read_buffer(struc
 	skb_reserve(skb, 16);
 	skb_put(skb, len);
 	skb->dev = dev;
-	writeptr = (word *)skb->data;
-	while (i < len) {
-		*writeptr++ = readw(dev->mem_start + rbuf_offs);
+    writeptr = (word *) skb->data;
+    while (i < len)
+    {
+	*writeptr++ = readw(phys_to_virt(dev->mem_start + rbuf_offs));
 		rbuf_offs += 2; 
 		i += 2;
 	}
 	COMX_WRITE(dev, OFF_A_L2_DAV, 0);
 	ch->stats.rx_packets++;
 	ch->stats.rx_bytes += len;
-	if (ch->debug_flags & DEBUG_HW_RX) {
+    if (ch->debug_flags & DEBUG_HW_RX)
 		comx_debug_skb(dev, skb, "COMX_interrupt receiving");
-	}
 	ch->LINE_rx(dev, skb);
 	return 1;
 }
 
 static inline char comx_line_change(struct net_device *dev, char linestat)
 {
-	struct comx_channel *ch=dev->priv;
-	char idle=1;
-	
+    struct comx_channel *ch = dev->priv;
+    char idle = 1;
 	
-	if (linestat & LINE_UP) { /* Vonal fol */
-		if (ch->lineup_delay) {
-			if (!test_and_set_bit(0, &ch->lineup_pending)) {
+    if (linestat & LINE_UP)
+    {				/* Vonal fol */
+	if (ch->lineup_delay)
+	{
+	    if (!test_and_set_bit(0, &ch->lineup_pending))
+	    {
 				ch->lineup_timer.function = comx_lineup_func;
 				ch->lineup_timer.data = (unsigned long)dev;
-				ch->lineup_timer.expires = jiffies +
-					HZ*ch->lineup_delay;
+		ch->lineup_timer.expires = jiffies + HZ * ch->lineup_delay;
 				add_timer(&ch->lineup_timer);
-				idle=0;
+		idle = 0;
 			}
-		} else {
-			idle=0;
+			}
+	else
+	{
+	    idle = 0;
 			ch->LINE_status(dev, ch->line_status |= LINE_UP);
 		}
-	} else { /* Vonal le */
-		idle=0;
-		if (test_and_clear_bit(0, &ch->lineup_pending)) {
+    }
+    else
+    {				/* Vonal le */
+	idle = 0;
+	if (test_and_clear_bit(0, &ch->lineup_pending))
+	{
 			del_timer(&ch->lineup_timer);
-		} else {
+	}
+	else
+	{
 			ch->line_status &= ~LINE_UP;
-			if (ch->LINE_status) {
+	    if (ch->LINE_status)
+	    {
 				ch->LINE_status(dev, ch->line_status);
 			}
 		}
@@ -346,7 +382,8 @@ static void COMX_interrupt(int irq, void
 	int count = 0;
 	word tmp;
 
-	if (dev == NULL) {
+    if (dev == NULL)
+    {
 		printk(KERN_ERR "COMX_interrupt: irq %d for unknown device\n", irq);
 		return;
 	}
@@ -355,84 +392,109 @@ static void COMX_interrupt(int irq, void
 
 	interrupted = ch->HW_access_board(dev);
 
-	while (!idle && count < 5000) {
+    while (!idle && count < 5000)
+    {
 		char channel = 0;
+
 		idle = 1;
 
-		while (channel < 2) {
+	while (channel < 2)
+	{
 			char linestat = 0;
 			char buffers_emptied = 0;
 
-			if (channel == 1) {
-				if (ch->twin) {
+	    if (channel == 1)
+	    {
+		if (ch->twin)
+		{
 					dev = ch->twin;
 					ch = dev->priv;
 					hw = ch->HW_privdata;
-				} else {
+		}
+		else
+		{
 					break;
 				}
-			} else {
+	    }
+	    else
+	    {
 				COMX_WRITE(dev, OFF_A_L1_REPENA, 
 				    COMX_readw(dev, OFF_A_L1_REPENA) & 0xFF00);
 			}
 			channel++;
 
 			if ((ch->init_status & (HW_OPEN | LINE_OPEN)) != 
-			   (HW_OPEN | LINE_OPEN)) {
+		(HW_OPEN | LINE_OPEN))
+	    {
 				continue;
 			}
 	
 			/* Collect stats */
 			tmp = COMX_readw(dev, OFF_A_L1_ABOREC);
 			COMX_WRITE(dev, OFF_A_L1_ABOREC, 0);
-			if(tmp==0xffff) {
-				printk(KERN_ERR "%s: OFF_A_L1_ABOREC is %d\n",dev->name,tmp);
+	    if (tmp == 0xffff)
+	    {
+		printk(KERN_ERR "%s: OFF_A_L1_ABOREC is %d\n", dev->name, tmp);
 				break;
-			} else {
+	    }
+	    else
+	    {
 				ch->stats.rx_missed_errors += (tmp >> 8) & 0xff;
 				ch->stats.rx_over_errors += tmp & 0xff;
 			}
 			tmp = COMX_readw(dev, OFF_A_L1_CRCREC);
 			COMX_WRITE(dev, OFF_A_L1_CRCREC, 0);
-			if(tmp==0xffff) {
-				printk(KERN_ERR "%s: OFF_A_L1_CRCREC is %d\n",dev->name,tmp);
+	    if (tmp == 0xffff)
+	    {
+		printk(KERN_ERR "%s: OFF_A_L1_CRCREC is %d\n", dev->name, tmp);
 				break;
-			} else {
+	    }
+	    else
+	    {
 				ch->stats.rx_crc_errors += (tmp >> 8) & 0xff;
 				ch->stats.rx_missed_errors += tmp & 0xff;
 			}
 			
-			if ((ch->line_status & LINE_UP) && ch->LINE_rx) {
-				tmp=COMX_readw(dev, OFF_A_L2_DAV); 
-				while (tmp==1) {
-					idle=0;
-					buffers_emptied+=comx_read_buffer(dev);
-					tmp=COMX_readw(dev, OFF_A_L2_DAV); 
+	    if ((ch->line_status & LINE_UP) && ch->LINE_rx)
+	    {
+		tmp = COMX_readw(dev, OFF_A_L2_DAV);
+		while (tmp == 1)
+		{
+		    idle = 0;
+		    buffers_emptied += comx_read_buffer(dev);
+		    tmp = COMX_readw(dev, OFF_A_L2_DAV);
 				}
-				if(tmp) {
+		if (tmp)
+		{
 					printk(KERN_ERR "%s: OFF_A_L2_DAV is %d\n", dev->name, tmp);
 					break;
 				}
 			}
 
-			tmp=COMX_readw(dev, OFF_A_L2_TxEMPTY);
-			if (tmp==1 && ch->LINE_tx) {
+	    tmp = COMX_readw(dev, OFF_A_L2_TxEMPTY);
+	    if (tmp == 1 && ch->LINE_tx)
+	    {
 				ch->LINE_tx(dev);
 			} 
-			if(tmp==0xffff) {
+	    if (tmp == 0xffff)
+	    {
 				printk(KERN_ERR "%s: OFF_A_L2_TxEMPTY is %d\n", dev->name, tmp);
 				break;
 			}
 
-			if (COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8) {
+	    if (COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8)
+	    {
 				linestat &= ~LINE_UP;
-			} else {
+	    }
+	    else
+	    {
 				linestat |= LINE_UP;
 			}
 
-			if ((linestat & LINE_UP) != (ch->line_status & LINE_UP)) {
+	    if ((linestat & LINE_UP) != (ch->line_status & LINE_UP))
+	    {
 				ch->stats.tx_carrier_errors++;
-				idle &= comx_line_change(dev,linestat);
+		idle &= comx_line_change(dev, linestat);
 			}
 				
 			hw->histogram[(int)buffers_emptied]++;
@@ -440,8 +502,9 @@ static void COMX_interrupt(int irq, void
 		count++;
 	}
 
-	if(count==5000) {
-		printk(KERN_WARNING "%s: interrupt stuck\n",dev->name);
+    if (count == 5000)
+    {
+	printk(KERN_WARNING "%s: interrupt stuck\n", dev->name);
 	}
 
 	ch->HW_release_board(dev, interrupted);
@@ -453,32 +516,35 @@ static int COMX_open(struct net_device *
 	struct comx_privdata *hw = ch->HW_privdata;
 	struct proc_dir_entry *procfile = ch->procdir->subdir;
 	unsigned long jiffs;
-	int twin_open=0;
+    int twin_open = 0;
 	int retval;
 	struct net_device *savep;
 
-	if (!dev->base_addr || !dev->irq || !dev->mem_start) {
+    if (!dev->base_addr || !dev->irq || !dev->mem_start)
 		return -ENODEV;
-	}
 
-	if (ch->twin && (((struct comx_channel *)(ch->twin->priv))->init_status & HW_OPEN)) {
-		twin_open=1;
-	}
+    if (ch->twin &&
+	(((struct comx_channel *)(ch->twin->priv))->init_status & HW_OPEN))
+	twin_open = 1;
 
-	if (!twin_open) {
-		if (!request_region(dev->base_addr, hw->io_extent, dev->name)) {
+    if (!twin_open)
+    {
+	if (check_region(dev->base_addr, hw->io_extent))
+	{
 			return -EAGAIN;
 		}
-		if (request_irq(dev->irq, COMX_interrupt, 0, dev->name, 
-		   (void *)dev)) {
-			printk(KERN_ERR "comx-hw-comx: unable to obtain irq %d\n", dev->irq);
-			release_region(dev->base_addr, hw->io_extent);
+	if (request_irq(dev->irq, COMX_interrupt, 0, dev->name, (void *)dev))
+	{
+	    printk(KERN_ERR "comx-hw-comx: unable to obtain irq %d\n",
+		   dev->irq);
 			return -EAGAIN;
 		}
 		ch->init_status |= IRQ_ALLOCATED;
-		if (!ch->HW_load_board || ch->HW_load_board(dev)) {
+		request_region(dev->base_addr, hw->io_extent, dev->name);
+	if (!ch->HW_load_board || ch->HW_load_board(dev))
+	{
 			ch->init_status &= ~IRQ_ALLOCATED;
-			retval=-ENODEV;
+	    retval = -ENODEV;
 			goto error;
 		}
 	}
@@ -486,69 +552,72 @@ static int COMX_open(struct net_device *
 	savep = ch->HW_access_board(dev);
 	COMX_WRITE(dev, OFF_A_L2_LINKUP, 0);
 
-	if (ch->HW_set_clock) {
+    if (ch->HW_set_clock)
 		ch->HW_set_clock(dev);
-	}
 
 	COMX_CMD(dev, COMX_CMD_INIT); 
 	jiffs = jiffies;
-	while (COMX_readw(dev, OFF_A_L2_LINKUP) != 1 && jiffies < jiffs + HZ) {
+    while (COMX_readw(dev, OFF_A_L2_LINKUP) != 1 && jiffies < jiffs + HZ)
 		schedule_timeout(1);
-	}
 	
-	if (jiffies >= jiffs + HZ) {
+    if (jiffies >= jiffs + HZ)
+    {
 		printk(KERN_ERR "%s: board timeout on INIT command\n", dev->name);
 		ch->HW_release_board(dev, savep);
-		retval=-EIO;
+	retval = -EIO;
 		goto error;
 	}
-	udelay(1000);
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout(1);
 
 	COMX_CMD(dev, COMX_CMD_OPEN);
 
 	jiffs = jiffies;
-	while (COMX_readw(dev, OFF_A_L2_LINKUP) != 3 && jiffies < jiffs + HZ) {
+    while (COMX_readw(dev, OFF_A_L2_LINKUP) != 3 && jiffies < jiffs + HZ)
 		schedule_timeout(1);
-	}
 	
-	if (jiffies >= jiffs + HZ) {
+    if (jiffies >= jiffs + HZ)
+    {
 		printk(KERN_ERR "%s: board timeout on OPEN command\n", dev->name);
 		ch->HW_release_board(dev, savep);
-		retval=-EIO;
+	retval = -EIO;
 		goto error;
 	}
 	
 	ch->init_status |= HW_OPEN;
 	
 	/* Ez eleg ciki, de ilyen a rendszer */
-	if (COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8) {
+    if (COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8)
+    {
 		ch->line_status &= ~LINE_UP;
-	} else {
+    }
+    else
+    {
 		ch->line_status |= LINE_UP;
 	}
 	
-	if (ch->LINE_status) {
+    if (ch->LINE_status)
+    {
 		ch->LINE_status(dev, ch->line_status);
 	}
 
 	ch->HW_release_board(dev, savep);
 
-	for ( ; procfile ; procfile = procfile->next) {
-		if (strcmp(procfile->name, FILENAME_IRQ) == 0 
-		    || strcmp(procfile->name, FILENAME_IO) == 0
-		    || strcmp(procfile->name, FILENAME_MEMADDR) == 0
-		    || strcmp(procfile->name, FILENAME_CHANNEL) == 0
-		    || strcmp(procfile->name, FILENAME_FIRMWARE) == 0
-		    || strcmp(procfile->name, FILENAME_CLOCK) == 0) {
+    for (; procfile; procfile = procfile->next)
+    {
+	if (strcmp(procfile->name, FILENAME_IRQ) == 0 ||
+	    strcmp(procfile->name, FILENAME_IO) == 0 ||
+	    strcmp(procfile->name, FILENAME_MEMADDR) == 0 ||
+	    strcmp(procfile->name, FILENAME_CHANNEL) == 0 ||
+	    strcmp(procfile->name, FILENAME_FIRMWARE) == 0 ||
+	    strcmp(procfile->name, FILENAME_CLOCK) == 0)
 			procfile->mode = S_IFREG | 0444;
-		
 		}
-	}	
-	
 	return 0;	
 
-error:
-	if(!twin_open) {
+  error:
+    if (!twin_open)
+    {
 		release_region(dev->base_addr, hw->io_extent);
 		free_irq(dev->irq, (void *)dev);
 	}
@@ -567,33 +636,37 @@ static int COMX_close(struct net_device 
 	savep = ch->HW_access_board(dev);
 
 	COMX_CMD(dev, COMX_CMD_CLOSE);
-	udelay(1000);
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout(1);
 	COMX_CMD(dev, COMX_CMD_EXIT);
 
 	ch->HW_release_board(dev, savep);
 
-	if (ch->init_status & IRQ_ALLOCATED) {
+    if (ch->init_status & IRQ_ALLOCATED)
+    {
 		free_irq(dev->irq, (void *)dev);
 		ch->init_status &= ~IRQ_ALLOCATED;
 	}
 	release_region(dev->base_addr, hw->io_extent);
 
 	if (ch->twin && (twin_ch = ch->twin->priv) && 
-	    (twin_ch->init_status & HW_OPEN)) {
+	(twin_ch->init_status & HW_OPEN))
+    {
 		/* Pass the irq to the twin */
 		if (request_irq(dev->irq, COMX_interrupt, 0, ch->twin->name, 
-		   (void *)ch->twin) == 0) {
+	     (void *)ch->twin) == 0)
 			twin_ch->init_status |= IRQ_ALLOCATED;
 		}
-	}
 
-	for ( ; procfile ; procfile = procfile->next) {
-		if (strcmp(procfile->name, FILENAME_IRQ) == 0 
-		    || strcmp(procfile->name, FILENAME_IO) == 0
-		    || strcmp(procfile->name, FILENAME_MEMADDR) == 0
-		    || strcmp(procfile->name, FILENAME_CHANNEL) == 0
-		    || strcmp(procfile->name, FILENAME_FIRMWARE) == 0
-		    || strcmp(procfile->name, FILENAME_CLOCK) == 0) {
+    for (; procfile; procfile = procfile->next)
+    {
+	if (strcmp(procfile->name, FILENAME_IRQ) == 0 ||
+	    strcmp(procfile->name, FILENAME_IO) == 0 ||
+	    strcmp(procfile->name, FILENAME_MEMADDR) == 0 ||
+	    strcmp(procfile->name, FILENAME_CHANNEL) == 0 ||
+	    strcmp(procfile->name, FILENAME_FIRMWARE) == 0 ||
+	    strcmp(procfile->name, FILENAME_CLOCK) == 0)
+	{
 			procfile->mode = S_IFREG | 0644;
 		}
 	}
@@ -611,7 +684,8 @@ static int COMX_statistics(struct net_de
 
 	savep = ch->HW_access_board(dev);
 
-	len += sprintf(page + len, "Board data: %s %s %s %s\nPBUFOVR: %02x, "
+    len += sprintf(page + len,
+		"Board data: %s %s %s %s\nPBUFOVR: %02x, "
 		"MODSTAT: %02x, LINKUP: %02x, DAV: %02x\nRxBUFP: %02x, "
 		"TxEMPTY: %02x, TxBUFP: %02x\n",
 		(ch->init_status & HW_OPEN) ? "HW_OPEN" : "",
@@ -619,16 +693,18 @@ static int COMX_statistics(struct net_de
 		(ch->init_status & FW_LOADED) ? "FW_LOADED" : "",
 		(ch->init_status & IRQ_ALLOCATED) ? "IRQ_ALLOCATED" : "",
 		COMX_readw(dev, OFF_A_L1_PBUFOVR) & 0xff,
-		(COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8) & 0xff,
-		COMX_readw(dev, OFF_A_L2_LINKUP) & 0xff,
-		COMX_readw(dev, OFF_A_L2_DAV) & 0xff,
-		COMX_readw(dev, OFF_A_L2_RxBUFP) & 0xff,
-		COMX_readw(dev, OFF_A_L2_TxEMPTY) & 0xff,
+		(COMX_readw(dev, OFF_A_L1_PBUFOVR) >> 8) & 0xff, COMX_readw(dev,
+									    OFF_A_L2_LINKUP)
+		& 0xff, COMX_readw(dev, OFF_A_L2_DAV) & 0xff, COMX_readw(dev,
+									 OFF_A_L2_RxBUFP)
+		& 0xff, COMX_readw(dev, OFF_A_L2_TxEMPTY) & 0xff,
 		COMX_readw(dev, OFF_A_L2_TxBUFP) & 0xff);
 
-	len += sprintf(page + len, "hist[0]: %8lu hist[1]: %8lu hist[2]: %8lu\n"
-		"hist[3]: %8lu hist[4]: %8lu\n",hw->histogram[0],hw->histogram[1],
-		hw->histogram[2],hw->histogram[3],hw->histogram[4]);
+    len += sprintf(page + len,
+		"hist[0]: %8lu hist[1]: %8lu hist[2]: %8lu\n"
+		"hist[3]: %8lu hist[4]: %8lu\n", hw->histogram[0],
+		hw->histogram[1], hw->histogram[2], hw->histogram[3],
+		hw->histogram[4]);
 
 	ch->HW_release_board(dev, savep);
 
@@ -641,7 +717,9 @@ static int COMX_load_board(struct net_de
 	struct comx_privdata *hw = ch->HW_privdata;
 	struct comx_firmware *fw = hw->firmware;
 	word board_segment = dev->mem_start >> 16;
-	int mempos = (dev->mem_start - COMX_MEM_MIN) >> 16;
+    unsigned long mempos =
+	(unsigned long)phys_to_virt((dev->mem_start - COMX_MEM_MIN) >> 16);
+    spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 	unsigned long flags;
 	unsigned char id1, id2;
 	struct net_device *saved;
@@ -650,25 +728,24 @@ static int COMX_load_board(struct net_de
 	int len;
 	byte *COMX_address;
 
-	if (!fw || !fw->len) {
+    if (!fw || !fw->len)
+    {
 		struct comx_channel *twin_ch = ch->twin ? ch->twin->priv : NULL;
 		struct comx_privdata *twin_hw;
 
-		if (!twin_ch || !(twin_hw = twin_ch->HW_privdata)) {
+	if (!twin_ch || !(twin_hw = twin_ch->HW_privdata))
 			return -EAGAIN;
-		}
 
-		if (!(fw = twin_hw->firmware) || !fw->len) {
+	if (!(fw = twin_hw->firmware) || !fw->len)
 			return -EAGAIN;
 		}
-	}
 
 	id1 = fw->data[OFF_FW_L1_ID]; 
 	id2 = fw->data[OFF_FW_L1_ID + 1];
 
-	if (id1 != FW_L1_ID_1 || id2 != FW_L1_ID_2_COMX) {
-		printk(KERN_ERR "%s: incorrect firmware, load aborted\n", 
-			dev->name);
+    if (id1 != FW_L1_ID_1 || id2 != FW_L1_ID_2_COMX)
+    {
+	printk(KERN_ERR "%s: incorrect firmware, load aborted\n", dev->name);
 		return -EAGAIN;
 	}
 
@@ -677,84 +754,97 @@ static int COMX_load_board(struct net_de
 
 	id1 = fw->data[OFF_FW_L2_ID]; 
 	id2 = fw->data[OFF_FW_L2_ID + 1];
-	if (id1 == FW_L2_ID_1 && (id2 == 0xc0 || id2 == 0xc1 || id2 == 0xc2)) {
+    if (id1 == FW_L2_ID_1 && (id2 == 0xc0 || id2 == 0xc1 || id2 == 0xc2))
 		printk(KERN_INFO "with Layer 2 code %s\n", 
 			(char *)(fw->data + OFF_FW_L2_ID + 2));
-	}
 
 	outb_p(board_segment | COMX_BOARD_RESET, dev->base_addr);
 	/* 10 usec should be enough here */
-	udelay(100);
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout(1);
 
-	save_flags(flags); cli();
-	saved=memory_used[mempos];
-	if(saved) {
+    spin_lock_irqsave(&mister_lock, flags);
+    saved = memory_used[mempos];
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_off(saved);
-	}
-	memory_used[mempos]=dev;
+    memory_used[mempos] = dev;
 
 	outb_p(board_segment | COMX_ENABLE_BOARD_MEM, dev->base_addr);
 
-	writeb(0, dev->mem_start + COMX_JAIL_OFFSET);	
+    writeb(0, phys_to_virt(dev->mem_start + COMX_JAIL_OFFSET));
 
-	loopcount=0;
-	while(loopcount++ < 10000 && 
-	    readb(dev->mem_start + COMX_JAIL_OFFSET) != COMX_JAIL_VALUE) {
-		udelay(100);
+    loopcount = 0;
+    while (loopcount++ < 100 &&
+	   readb(phys_to_virt(dev->mem_start + COMX_JAIL_OFFSET)) !=
+	   COMX_JAIL_VALUE)
+    {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
 	}	
 	
-	if (readb(dev->mem_start + COMX_JAIL_OFFSET) != COMX_JAIL_VALUE) {
+    if (readb(phys_to_virt(dev->mem_start + COMX_JAIL_OFFSET)) !=
+	COMX_JAIL_VALUE)
+    {
 		printk(KERN_ERR "%s: Can't reset board, JAIL value is %02x\n",
-			dev->name, readb(dev->mem_start + COMX_JAIL_OFFSET));
-		retval=-ENODEV;
+	       dev->name,
+	       readb(phys_to_virt(dev->mem_start + COMX_JAIL_OFFSET)));
+	retval = -ENODEV;
 		goto out;
 	}
 
-	writeb(0x55, dev->mem_start + 0x18ff);
+    writeb(0x55, phys_to_virt(dev->mem_start + 0x18ff));
 	
-	loopcount=0;
-	while(loopcount++ < 10000 && readb(dev->mem_start + 0x18ff) != 0) {
-		udelay(100);
+    loopcount = 0;
+    while (loopcount++ < 100 &&
+	   readb(phys_to_virt(dev->mem_start + 0x18ff)) != 0)
+    {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
 	}
 
-	if(readb(dev->mem_start + 0x18ff) != 0) {
-		printk(KERN_ERR "%s: Can't reset board, reset timeout\n",
-			dev->name);
-		retval=-ENODEV;
+    if (readb(phys_to_virt(dev->mem_start + 0x18ff)) != 0)
+    {
+	printk(KERN_ERR "%s: Can't reset board, reset timeout\n", dev->name);
+	retval = -ENODEV;
 		goto out;
 	}		
 
 	len = 0;
-	COMX_address = (byte *)dev->mem_start;
-	while (fw->len > len) {
-		writeb(fw->data[len++], COMX_address++);
-	}
+    COMX_address = (byte *) dev->mem_start;
+    while (fw->len > len)
+	writeb(fw->data[len++], phys_to_virt((unsigned long)(COMX_address++)));
 
 	len = 0;
-	COMX_address = (byte *)dev->mem_start;
-	while (len != fw->len && readb(COMX_address++) == fw->data[len]) {
+    COMX_address = (byte *) dev->mem_start;
+    while (len != fw->len &&
+	   readb(phys_to_virt((unsigned long)(COMX_address++))) ==
+	   fw->data[len])
 		len++;
-	}
 
-	if (len != fw->len) {
+    if (len != fw->len)
+    {
 		printk(KERN_ERR "%s: error loading firmware: [%d] is 0x%02x "
 			"instead of 0x%02x\n", dev->name, len, 
-			readb(COMX_address - 1), fw->data[len]);
-		retval=-EAGAIN;
+	       readb(phys_to_virt((unsigned long)(COMX_address - 1))),
+	       fw->data[len]);
+	retval = -EAGAIN;
 		goto out;
 	}
 
-	writeb(0, dev->mem_start + COMX_JAIL_OFFSET);
+    writeb(0, phys_to_virt(dev->mem_start + COMX_JAIL_OFFSET));
 
 	loopcount = 0;
-	while ( loopcount++ < 10000 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1 ) {
-		udelay(100);
+    while (loopcount++ < 1000 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
 	}
 
-	if (COMX_readw(dev, OFF_A_L2_LINKUP) != 1) {
+    if (COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
 		printk(KERN_ERR "%s: error starting firmware, linkup word is %04x\n",
 			dev->name, COMX_readw(dev, OFF_A_L2_LINKUP));
-		retval=-EAGAIN;
+	retval = -EAGAIN;
 		goto out;
 	}
 
@@ -758,17 +848,15 @@ static int COMX_load_board(struct net_de
 		goto out;
 	}
 
-
 	ch->init_status |= FW_LOADED;
-	retval=0;
+    retval = 0;
 
-out: 
+  out:
 	outb_p(board_segment | COMX_DISABLE_ALL, dev->base_addr);
-	if(saved) {
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_on(saved);
-	}
-	memory_used[mempos]=saved;
-	restore_flags(flags);
+    memory_used[mempos] = saved;
+    spin_unlock_irqrestore(&mister_lock, flags);
 	return retval;
 }
 
@@ -778,33 +866,35 @@ static int CMX_load_board(struct net_dev
 	struct comx_privdata *hw = ch->HW_privdata;
 	struct comx_firmware *fw = hw->firmware;
 	word board_segment = dev->mem_start >> 16;
-	int mempos = (dev->mem_start - COMX_MEM_MIN) >> 16;
-	#if 0
+    unsigned long mempos =
+	(unsigned long)phys_to_virt((dev->mem_start - COMX_MEM_MIN) >> 16);
+#if 0
 	unsigned char id1, id2;
-	#endif
+#endif
 	struct net_device *saved;
 	unsigned long flags;
 	int retval;
 	int loopcount;
 	int len;
 	byte *COMX_address;
+    spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 
-	if (!fw || !fw->len) {
+    if (!fw || !fw->len)
+    {
 		struct comx_channel *twin_ch = ch->twin ? ch->twin->priv : NULL;
 		struct comx_privdata *twin_hw;
 
-		if (!twin_ch || !(twin_hw = twin_ch->HW_privdata)) {
+	if (!twin_ch || !(twin_hw = twin_ch->HW_privdata))
 			return -EAGAIN;
-		}
 
-		if (!(fw = twin_hw->firmware) || !fw->len) {
+	if (!(fw = twin_hw->firmware) || !fw->len)
 			return -EAGAIN;
 		}
-	}
 
 	/* Ide kell olyat tenni, hogy ellenorizze az ID-t */
 
-	if (inb_p(dev->base_addr) != CMX_ID_BYTE) {
+    if (inb_p(dev->base_addr) != CMX_ID_BYTE)
+    {
 		printk(KERN_ERR "%s: CMX id byte is invalid(%02x)\n", dev->name,
 			inb_p(dev->base_addr));
 		return -ENODEV;
@@ -813,60 +903,63 @@ static int CMX_load_board(struct net_dev
 	printk(KERN_INFO "%s: Loading CMX Layer 1 firmware %s\n", dev->name, 
 		(char *)(fw->data + OFF_FW_L1_ID + 2));
 
-	save_flags(flags); cli();
-	saved=memory_used[mempos];
-	if(saved) {
+    spin_lock_irqsave(&mister_lock, flags);
+    saved = memory_used[mempos];
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_off(saved);
-	}
-	memory_used[mempos]=dev;
+    memory_used[mempos] = dev;
 	
 	outb_p(board_segment | COMX_ENABLE_BOARD_MEM | COMX_BOARD_RESET, 
 		dev->base_addr);
 
 	len = 0;
-	COMX_address = (byte *)dev->mem_start;
-	while (fw->len > len) {
-		writeb(fw->data[len++], COMX_address++);
-	}
+    COMX_address = (byte *) dev->mem_start;
+    while (fw->len > len)
+	writeb(fw->data[len++], phys_to_virt((unsigned long)(COMX_address++)));
 
 	len = 0;
-	COMX_address = (byte *)dev->mem_start;
-	while (len != fw->len && readb(COMX_address++) == fw->data[len]) {
+    COMX_address = (byte *) dev->mem_start;
+    while (len != fw->len &&
+	   readb(phys_to_virt((unsigned long)(COMX_address++))) ==
+	   fw->data[len])
 		len++;
-	}
 
 	outb_p(board_segment | COMX_ENABLE_BOARD_MEM, dev->base_addr);
 
-	if (len != fw->len) {
+    if (len != fw->len)
+    {
 		printk(KERN_ERR "%s: error loading firmware: [%d] is 0x%02x "
 			"instead of 0x%02x\n", dev->name, len, 
-			readb(COMX_address - 1), fw->data[len]);
-		retval=-EAGAIN;
+	       readb(phys_to_virt((unsigned long)(COMX_address - 1))),
+	       fw->data[len]);
+	retval = -EAGAIN;
 		goto out;
 	}
 
-	loopcount=0;
-	while( loopcount++ < 10000 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1 ) {
-		udelay(100);
+    loopcount = 0;
+    while (loopcount++ < 100 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
 	}
 
-	if (COMX_readw(dev, OFF_A_L2_LINKUP) != 1) {
+    if (COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
 		printk(KERN_ERR "%s: error starting firmware, linkup word is %04x\n",
 			dev->name, COMX_readw(dev, OFF_A_L2_LINKUP));
-		retval=-EAGAIN;
+	retval = -EAGAIN;
 		goto out;
 	}
 
 	ch->init_status |= FW_LOADED;
-	retval=0;
+    retval = 0;
 
-out: 
+  out:
 	outb_p(board_segment | COMX_DISABLE_ALL, dev->base_addr);
-	if(saved) {
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_on(saved);
-	}
-	memory_used[mempos]=saved;
-	restore_flags(flags);
+    memory_used[mempos] = saved;
+    spin_lock_irqsave(&mister_lock, flags);
 	return retval;
 }
 
@@ -876,36 +969,35 @@ static int HICOMX_load_board(struct net_
 	struct comx_privdata *hw = ch->HW_privdata;
 	struct comx_firmware *fw = hw->firmware;
 	word board_segment = dev->mem_start >> 12;
-	int mempos = (dev->mem_start - COMX_MEM_MIN) >> 16;
+    unsigned long mempos =
+	(unsigned long)phys_to_virt((dev->mem_start - COMX_MEM_MIN) >> 16);
 	struct net_device *saved;
 	unsigned char id1, id2;
 	unsigned long flags;
+    spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
 	int retval;
 	int loopcount;
 	int len;
 	word *HICOMX_address;
 	char id = 1;
 
-	if (!fw || !fw->len) {
+    if (!fw || !fw->len)
+    {
 		struct comx_channel *twin_ch = ch->twin ? ch->twin->priv : NULL;
 		struct comx_privdata *twin_hw;
 
-		if (!twin_ch || !(twin_hw = twin_ch->HW_privdata)) {
+	if (!twin_ch || !(twin_hw = twin_ch->HW_privdata))
 			return -EAGAIN;
-		}
 
-		if (!(fw = twin_hw->firmware) || !fw->len) {
+	if (!(fw = twin_hw->firmware) || !fw->len)
 			return -EAGAIN;
 		}
-	}
 
-	while (id != 4) {
-		if (inb_p(dev->base_addr + id++) != HICOMX_ID_BYTE) {
-			break;
-		}
-	}
+    while (id != 4)
+	if (inb_p(dev->base_addr + id++) != HICOMX_ID_BYTE) break;
 
-	if (id != 4) {
+    if (id != 4)
+    {
 		printk(KERN_ERR "%s: can't find HICOMX at 0x%04x, id[%d] = %02x\n",
 			dev->name, (unsigned int)dev->base_addr, id - 1,
 			inb_p(dev->base_addr + id - 1));
@@ -914,7 +1006,8 @@ static int HICOMX_load_board(struct net_
 
 	id1 = fw->data[OFF_FW_L1_ID]; 
 	id2 = fw->data[OFF_FW_L1_ID + 1];
-	if (id1 != FW_L1_ID_1 || id2 != FW_L1_ID_2_HICOMX) {
+    if (id1 != FW_L1_ID_1 || id2 != FW_L1_ID_2_HICOMX)
+    {
 		printk(KERN_ERR "%s: incorrect firmware, load aborted\n", dev->name);
 		return -EAGAIN;
 	}
@@ -924,7 +1017,8 @@ static int HICOMX_load_board(struct net_
 
 	id1 = fw->data[OFF_FW_L2_ID]; 
 	id2 = fw->data[OFF_FW_L2_ID + 1];
-	if (id1 == FW_L2_ID_1 && (id2 == 0xc0 || id2 == 0xc1 || id2 == 0xc2)) {
+    if (id1 == FW_L2_ID_1 && (id2 == 0xc0 || id2 == 0xc1 || id2 == 0xc2))
+    {
 		printk(KERN_INFO "with Layer 2 code %s\n", 
 			(char *)(fw->data + OFF_FW_L2_ID + 2));
 	}
@@ -932,33 +1026,37 @@ static int HICOMX_load_board(struct net_
 	outb_p(board_segment | HICOMX_BOARD_RESET, dev->base_addr);
 	udelay(10);	
 
-	save_flags(flags); cli();
-	saved=memory_used[mempos];
-	if(saved) {
+    spin_lock_irqsave(&mister_lock, flags);
+    saved = memory_used[mempos];
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_off(saved);
-	}
-	memory_used[mempos]=dev;
+    memory_used[mempos] = dev;
 
 	outb_p(board_segment | HICOMX_ENABLE_BOARD_MEM, dev->base_addr);
 	outb_p(HICOMX_PRG_MEM, dev->base_addr + 1);
 
 	len = 0;
-	HICOMX_address = (word *)dev->mem_start;
-	while (fw->len > len) {
-		writeb(fw->data[len++], HICOMX_address++);
+    HICOMX_address = (word *) dev->mem_start;
+    while (fw->len > len)
+    {
+	writeb(fw->data[len++],
+	       phys_to_virt((unsigned long)(HICOMX_address++)));
 	}
 
 	len = 0;
-	HICOMX_address = (word *)dev->mem_start;
-	while (len != fw->len && (readw(HICOMX_address++) & 0xff) == fw->data[len]) {
+    HICOMX_address = (word *) dev->mem_start;
+    while (len != fw->len &&
+	   (readw(phys_to_virt((unsigned long)(HICOMX_address++))) & 0xff) ==
+	   fw->data[len])
 		len++;
-	}
 
-	if (len != fw->len) {
+    if (len != fw->len)
+    {
 		printk(KERN_ERR "%s: error loading firmware: [%d] is 0x%02x "
 			"instead of 0x%02x\n", dev->name, len, 
-			readw(HICOMX_address - 1) & 0xff, fw->data[len]);
-		retval=-EAGAIN;
+	       readw(phys_to_virt((unsigned long)(HICOMX_address - 1))) & 0xff,
+	       fw->data[len]);
+	retval = -EAGAIN;
 		goto out;
 	}
 
@@ -967,30 +1065,32 @@ static int HICOMX_load_board(struct net_
 
 	outb_p(board_segment | HICOMX_ENABLE_BOARD_MEM, dev->base_addr);
 
-	loopcount=0;
-	while(loopcount++ < 10000 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1) {
-		udelay(100);
+    loopcount = 0;
+    while (loopcount++ < 100 && COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
 	}
 
-	if ( COMX_readw(dev, OFF_A_L2_LINKUP) != 1 ) {
+    if (COMX_readw(dev, OFF_A_L2_LINKUP) != 1)
+    {
 		printk(KERN_ERR "%s: error starting firmware, linkup word is %04x\n",
 			dev->name, COMX_readw(dev, OFF_A_L2_LINKUP));
-		retval=-EAGAIN;
+	retval = -EAGAIN;
 		goto out;
 	}
 
 	ch->init_status |= FW_LOADED;
-	retval=0;
+    retval = 0;
 
-out:
+  out:
 	outb_p(board_segment | HICOMX_DISABLE_ALL, dev->base_addr);
 	outb_p(HICOMX_DATA_MEM, dev->base_addr + 1);
 
-	if(saved) {
+    if (saved)
 		((struct comx_channel *)saved->priv)->HW_board_on(saved);
-	}
-	memory_used[mempos]=saved;
-	restore_flags(flags);
+    memory_used[mempos] = saved;
+    spin_unlock_irqrestore(&mister_lock, flags);
 	return retval;
 }
 
@@ -1004,26 +1104,23 @@ static struct net_device *comx_twin_chec
 	struct comx_channel *ch_twin;
 	struct comx_privdata *hw_twin;
 
+    for (; procfile; procfile = procfile->next)
+    {
 
-	for ( ; procfile ; procfile = procfile->next) {
-	
-		if(!S_ISDIR(procfile->mode)) {
+	if (!S_ISDIR(procfile->mode))
 			continue;
-		}
-	
-		twin=procfile->data;
-		ch_twin=twin->priv;
-		hw_twin=ch_twin->HW_privdata;
 
+	twin = procfile->data;
+	ch_twin = twin->priv;
+	hw_twin = ch_twin->HW_privdata;
 
 		if (twin != dev && dev->irq && dev->base_addr && dev->mem_start &&
 		   dev->irq == twin->irq && dev->base_addr == twin->base_addr &&
 	  	   dev->mem_start == twin->mem_start &&
 		   hw->channel == (1 - hw_twin->channel) &&
-		   ch->hardware == ch_twin->hardware) {
+	    ch->hardware == ch_twin->hardware)
 		   	return twin;
 		}
-	}
 	return NULL;
 }
 
@@ -1036,51 +1133,62 @@ static int comxhw_write_proc(struct file
 	struct comx_privdata *hw = ch->HW_privdata;
 	char *page;
 
-
-	if(ch->init_status & HW_OPEN) {
+    if (ch->init_status & HW_OPEN)
+    {
 		return -EAGAIN;	
 	}
 	
-	if (strcmp(FILENAME_FIRMWARE, entry->name) != 0) {
-		if (!(page = (char *)__get_free_page(GFP_KERNEL))) {
+    if (strcmp(FILENAME_FIRMWARE, entry->name) != 0)
+    {
+	if (!(page = (char *)__get_free_page(GFP_KERNEL)))
+	{
 			return -ENOMEM;
 		}
-		if(copy_from_user(page, buffer, count = (min_t(int, count, PAGE_SIZE))))
+	if (copy_from_user
+	    (page, buffer, count = (min_t(int, count, PAGE_SIZE))))
 		{
 			count = -EFAULT;
 			goto out;
 		}
-		if (page[count-1] == '\n')
-			page[count-1] = '\0';
+	if (page[count - 1] == '\n')
+	    page[count - 1] = '\0';
 		else if (count < PAGE_SIZE)
 			page[count] = '\0';
-		else if (page[count]) {
+	else if (page[count])
+	{
  			count = -EINVAL;
 			goto out;
 		}
-		page[count]=0;	/* Null terminate */
-	} else {
+	page[count] = 0;	/* Null terminate */
+    }
+    else
+    {
 		byte *tmp;
 
-		if (!hw->firmware) {
-			if ((hw->firmware = kmalloc(sizeof(struct comx_firmware), 
-			    GFP_KERNEL)) == NULL) {
+	if (!hw->firmware)
+	{
+	    if ((hw->firmware =
+		 kmalloc(sizeof(struct comx_firmware), GFP_KERNEL)) == NULL)
+	    {
 			    	return -ENOMEM;
 			}
 			hw->firmware->len = 0;
 			hw->firmware->data = NULL;
 		}
 		
-		if ((tmp = kmalloc(count + file->f_pos, GFP_KERNEL)) == NULL) {
+	if ((tmp = kmalloc(count + file->f_pos, GFP_KERNEL)) == NULL)
+	{
 			return -ENOMEM;
 		}
 		
 		/* Ha nem 0 a fpos, akkor meglevo file-t irunk. Gyenge trukk. */
-		if (hw->firmware && hw->firmware->len && file->f_pos 
-		    && hw->firmware->len < count + file->f_pos) {
+	if (hw->firmware && hw->firmware->len && file->f_pos &&
+	    hw->firmware->len < count + file->f_pos)
+	{
 			memcpy(tmp, hw->firmware->data, hw->firmware->len);
 		}
-		if (hw->firmware->data) {
+	if (hw->firmware->data)
+	{
 			kfree(hw->firmware->data);
 		}
 		copy_from_user(tmp + file->f_pos, buffer, count);
@@ -1090,68 +1198,92 @@ static int comxhw_write_proc(struct file
 		return count;
 	}
 
-	if (strcmp(entry->name, FILENAME_CHANNEL) == 0) {
+    if (strcmp(entry->name, FILENAME_CHANNEL) == 0)
+    {
 		hw->channel = simple_strtoul(page, NULL, 0);
-		if (hw->channel >= MAX_CHANNELNO) {
+	if (hw->channel >= MAX_CHANNELNO)
+	{
 			printk(KERN_ERR "Invalid channel number\n");
 			hw->channel = 0;
 		}
-		if ((ch->twin = comx_twin_check(dev)) != NULL) {
+	if ((ch->twin = comx_twin_check(dev)) != NULL)
+	{
 			struct comx_channel *twin_ch = ch->twin->priv;
+
 			twin_ch->twin = dev;
 		}
-	} else if (strcmp(entry->name, FILENAME_IRQ) == 0) {
+    }
+    else if (strcmp(entry->name, FILENAME_IRQ) == 0)
+    {
 		dev->irq = simple_strtoul(page, NULL, 0);
-		if (dev->irq == 2) {
+	if (dev->irq == 2)
+	{
 			dev->irq = 9;
 		}
-		if (dev->irq < 3 || dev->irq > 15) {
+	if (dev->irq < 3 || dev->irq > 15)
+	{
 			printk(KERN_ERR "comxhw: Invalid irq number\n");
 			dev->irq = 0;
 		}
-		if ((ch->twin = comx_twin_check(dev)) != NULL) {
+	if ((ch->twin = comx_twin_check(dev)) != NULL)
+	{
 			struct comx_channel *twin_ch = ch->twin->priv;
+
 			twin_ch->twin = dev;
 		}
-	} else if (strcmp(entry->name, FILENAME_IO) == 0) {
+    }
+    else if (strcmp(entry->name, FILENAME_IO) == 0)
+    {
 		dev->base_addr = simple_strtoul(page, NULL, 0);
-		if ((dev->base_addr & 3) != 0 || dev->base_addr < 0x300 
-		   || dev->base_addr > 0x3fc) {
+	if ((dev->base_addr & 3) != 0 || dev->base_addr < 0x300 ||
+	    dev->base_addr > 0x3fc)
+	{
 			printk(KERN_ERR "Invalid io value\n");
 			dev->base_addr = 0;
 		}
-		if ((ch->twin = comx_twin_check(dev)) != NULL) {
+	if ((ch->twin = comx_twin_check(dev)) != NULL)
+	{
 			struct comx_channel *twin_ch = ch->twin->priv;
 
 			twin_ch->twin = dev;
 		}
-	} else if (strcmp(entry->name, FILENAME_MEMADDR) == 0) {
+    }
+    else if (strcmp(entry->name, FILENAME_MEMADDR) == 0)
+    {
 		dev->mem_start = simple_strtoul(page, NULL, 0);
-		if (dev->mem_start <= 0xf000 && dev->mem_start >= 0xa000) {
+	if (dev->mem_start <= 0xf000 && dev->mem_start >= 0xa000)
+	{
 			dev->mem_start *= 16;
 		}
-		if ((dev->mem_start & 0xfff) != 0 || dev->mem_start < COMX_MEM_MIN
-		    || dev->mem_start + hw->memory_size > COMX_MEM_MAX) {
+	if ((dev->mem_start & 0xfff) != 0 || dev->mem_start < COMX_MEM_MIN ||
+	    dev->mem_start + hw->memory_size > COMX_MEM_MAX)
+	{
 			printk(KERN_ERR "Invalid memory page\n");
 			dev->mem_start = 0;
 		}
 		dev->mem_end = dev->mem_start + hw->memory_size;
-		if ((ch->twin = comx_twin_check(dev)) != NULL) {
+	if ((ch->twin = comx_twin_check(dev)) != NULL)
+	{
 			struct comx_channel *twin_ch = ch->twin->priv;
 
 			twin_ch->twin = dev;
 		}
-	} else if (strcmp(entry->name, FILENAME_CLOCK) == 0) {
-		if (strncmp("ext", page, 3) == 0) {
+    }
+    else if (strcmp(entry->name, FILENAME_CLOCK) == 0)
+    {
+	if (strncmp("ext", page, 3) == 0)
+	{
 			hw->clock = 0;
-		} else {
+	}
+	else
+	{
 			int kbps;
 
 			kbps = simple_strtoul(page, NULL, 0);
-			hw->clock = kbps ? COMX_CLOCK_CONST/kbps : 0;
+	    hw->clock = kbps ? COMX_CLOCK_CONST / kbps : 0;
 		}
 	}
-out:
+  out:
 	free_page((unsigned long)page);
 	return count;
 }
@@ -1165,45 +1297,64 @@ static int comxhw_read_proc(char *page, 
 	struct comx_privdata *hw = ch->HW_privdata;
 	int len = 0;
 
-
-	if (strcmp(file->name, FILENAME_IO) == 0) {
+    if (strcmp(file->name, FILENAME_IO) == 0)
+    {
 		len = sprintf(page, "0x%03x\n", (unsigned int)dev->base_addr);
-	} else if (strcmp(file->name, FILENAME_IRQ) == 0) {
+    }
+    else if (strcmp(file->name, FILENAME_IRQ) == 0)
+    {
 		len = sprintf(page, "0x%02x\n", dev->irq == 9 ? 2 : dev->irq);
-	} else if (strcmp(file->name, FILENAME_CHANNEL) == 0) {
+    }
+    else if (strcmp(file->name, FILENAME_CHANNEL) == 0)
+    {
 		len = sprintf(page, "%01d\n", hw->channel);
-	} else if (strcmp(file->name, FILENAME_MEMADDR) == 0) {
+    }
+    else if (strcmp(file->name, FILENAME_MEMADDR) == 0)
+    {
 		len = sprintf(page, "0x%05x\n", (unsigned int)dev->mem_start);
-	} else if (strcmp(file->name, FILENAME_TWIN) == 0) {
+    }
+    else if (strcmp(file->name, FILENAME_TWIN) == 0)
+    {
 		len = sprintf(page, "%s\n", ch->twin ? ch->twin->name : "none");
-	} else if (strcmp(file->name, FILENAME_CLOCK) == 0) {
-		if (hw->clock) {
-			len = sprintf(page, "%-8d\n", COMX_CLOCK_CONST/hw->clock);
-		} else {
+    }
+    else if (strcmp(file->name, FILENAME_CLOCK) == 0)
+    {
+	if (hw->clock)
+	{
+	    len = sprintf(page, "%-8d\n", COMX_CLOCK_CONST / hw->clock);
+	}
+	else
+	{
 			len = sprintf(page, "external\n");
 		}
-	} else if (strcmp(file->name, FILENAME_FIRMWARE) == 0) {
-		len = min_t(int, FILE_PAGESIZE,
+    }
+    else if (strcmp(file->name, FILENAME_FIRMWARE) == 0)
+    {
+	len =
+	    min_t(int, FILE_PAGESIZE,
 			  min_t(int, count, 
-			      hw->firmware ?
-			      (hw->firmware->len - off) : 0));
-		if (len < 0) {
+			hw->firmware ? (hw->firmware->len - off) : 0));
+	if (len < 0)
+	{
 			len = 0;
 		}
 		*start = hw->firmware ? (hw->firmware->data + off) : NULL;
-		if (off + len >= (hw->firmware ? hw->firmware->len : 0) || len == 0) {
+	if (off + len >= (hw->firmware ? hw->firmware->len : 0) || len == 0)
+	{
 			*eof = 1;
 		}
 		return len;
 	}	
 
-	if (off >= len) {
+    if (off >= len)
+    {
 		*eof = 1;
 		return 0;
 	}
 
 	*start = page + off;
-	if (count >= len - off) {
+    if (count >= len - off)
+    {
 		*eof = 1;
 	}
 	return min_t(int, count, len - off);
@@ -1216,32 +1367,40 @@ static int COMX_init(struct net_device *
 	struct comx_privdata *hw;
 	struct proc_dir_entry *new_file;
 
-	if ((ch->HW_privdata = kmalloc(sizeof(struct comx_privdata), 
-	    GFP_KERNEL)) == NULL) {
+    if ((ch->HW_privdata =
+	 kmalloc(sizeof(struct comx_privdata), GFP_KERNEL)) == NULL)
+    {
 	    	return -ENOMEM;
 	}
 	memset(hw = ch->HW_privdata, 0, sizeof(struct comx_privdata));
 
-	if (ch->hardware == &comx_hw || ch->hardware == &cmx_hw) {
+    if (ch->hardware == &comx_hw || ch->hardware == &cmx_hw)
+    {
 		hw->memory_size = COMX_MEMORY_SIZE;
 		hw->io_extent = COMX_IO_EXTENT;
 		dev->base_addr = COMX_DEFAULT_IO;
 		dev->irq = COMX_DEFAULT_IRQ;
 		dev->mem_start = COMX_DEFAULT_MEMADDR;
 		dev->mem_end = COMX_DEFAULT_MEMADDR + COMX_MEMORY_SIZE;
-	} else if (ch->hardware == &hicomx_hw) {
+    }
+    else if (ch->hardware == &hicomx_hw)
+    {
 		hw->memory_size = HICOMX_MEMORY_SIZE;
 		hw->io_extent = HICOMX_IO_EXTENT;
 		dev->base_addr = HICOMX_DEFAULT_IO;
 		dev->irq = HICOMX_DEFAULT_IRQ;
 		dev->mem_start = HICOMX_DEFAULT_MEMADDR;
 		dev->mem_end = HICOMX_DEFAULT_MEMADDR + HICOMX_MEMORY_SIZE;
-	} else {
-		printk(KERN_ERR "SERIOUS INTERNAL ERROR in %s, line %d\n", __FILE__, __LINE__);
+    }
+    else
+    {
+	printk(KERN_ERR "SERIOUS INTERNAL ERROR in %s, line %d\n", __FILE__,
+	       __LINE__);
 	}
 
-	if ((new_file = create_proc_entry(FILENAME_IO, S_IFREG | 0644, ch->procdir))
-	    == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_IO, S_IFREG | 0644, ch->procdir)) == NULL)
+    {
 	    goto cleanup_HW_privdata;
 	}
 	new_file->data = (void *)new_file;
@@ -1250,8 +1409,9 @@ static int COMX_init(struct net_device *
 	new_file->size = 6;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_IRQ, S_IFREG | 0644, ch->procdir))
-	    == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_IRQ, S_IFREG | 0644, ch->procdir)) == NULL)
+    {
 	    goto cleanup_filename_io;
 	}
 	new_file->data = (void *)new_file;
@@ -1260,8 +1420,10 @@ static int COMX_init(struct net_device *
 	new_file->size = 5;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_CHANNEL, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_CHANNEL, S_IFREG | 0644,
+			   ch->procdir)) == NULL)
+    {
 	    goto cleanup_filename_irq;
 	}
 	new_file->data = (void *)new_file;
@@ -1270,9 +1432,12 @@ static int COMX_init(struct net_device *
 	new_file->size = 2;		// Ezt tudjuk
 	new_file->nlink = 1;
 
-	if (ch->hardware == &hicomx_hw || ch->hardware == &cmx_hw) {
-		if ((new_file = create_proc_entry(FILENAME_CLOCK, S_IFREG | 0644, 
-		   ch->procdir)) == NULL) {
+    if (ch->hardware == &hicomx_hw || ch->hardware == &cmx_hw)
+    {
+	if ((new_file =
+	     create_proc_entry(FILENAME_CLOCK, S_IFREG | 0644,
+			       ch->procdir)) == NULL)
+	{
 		    goto cleanup_filename_channel;
 		}
 		new_file->data = (void *)new_file;
@@ -1282,8 +1447,10 @@ static int COMX_init(struct net_device *
 		new_file->nlink = 1;
 	}
 
-	if ((new_file = create_proc_entry(FILENAME_MEMADDR, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_MEMADDR, S_IFREG | 0644,
+			   ch->procdir)) == NULL)
+    {
 		    goto cleanup_filename_clock;
 	}
 	new_file->data = (void *)new_file;
@@ -1292,8 +1459,9 @@ static int COMX_init(struct net_device *
 	new_file->size = 8;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_TWIN, S_IFREG | 0444, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_TWIN, S_IFREG | 0444, ch->procdir)) == NULL)
+    {
 		    goto cleanup_filename_memaddr;
 	}
 	new_file->data = (void *)new_file;
@@ -1301,8 +1469,10 @@ static int COMX_init(struct net_device *
 	new_file->write_proc = NULL;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_FIRMWARE, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_FIRMWARE, S_IFREG | 0644,
+			   ch->procdir)) == NULL)
+    {
 		    goto cleanup_filename_twin;
 	}
 	new_file->data = (void *)new_file;
@@ -1310,22 +1480,30 @@ static int COMX_init(struct net_device *
 	new_file->write_proc = &comxhw_write_proc;
 	new_file->nlink = 1;
 
-	if (ch->hardware == &comx_hw) {
+    if (ch->hardware == &comx_hw)
+    {
 		ch->HW_board_on = COMX_board_on;
 		ch->HW_board_off = COMX_board_off;
 		ch->HW_load_board = COMX_load_board;
-	} else if (ch->hardware == &cmx_hw) {
+    }
+    else if (ch->hardware == &cmx_hw)
+    {
 		ch->HW_board_on = COMX_board_on;
 		ch->HW_board_off = COMX_board_off;
 		ch->HW_load_board = CMX_load_board;
 		ch->HW_set_clock = COMX_set_clock;
-	} else if (ch->hardware == &hicomx_hw) {
+    }
+    else if (ch->hardware == &hicomx_hw)
+    {
 		ch->HW_board_on = HICOMX_board_on;
 		ch->HW_board_off = HICOMX_board_off;
 		ch->HW_load_board = HICOMX_load_board;
 		ch->HW_set_clock = COMX_set_clock;
-	} else {
-		printk(KERN_ERR "SERIOUS INTERNAL ERROR in %s, line %d\n", __FILE__, __LINE__);
+    }
+    else
+    {
+	printk(KERN_ERR "SERIOUS INTERNAL ERROR in %s, line %d\n", __FILE__,
+	       __LINE__);
 	}
 
 	ch->HW_access_board = COMX_access_board;
@@ -1336,7 +1514,8 @@ static int COMX_init(struct net_device *
 	ch->HW_send_packet = COMX_send_packet;
 	ch->HW_statistics = COMX_statistics;
 
-	if ((ch->twin = comx_twin_check(dev)) != NULL) {
+    if ((ch->twin = comx_twin_check(dev)) != NULL)
+    {
 		struct comx_channel *twin_ch = ch->twin->priv;
 
 		twin_ch->twin = dev;
@@ -1345,20 +1524,20 @@ static int COMX_init(struct net_device *
 	MOD_INC_USE_COUNT;
 	return 0;
 
-cleanup_filename_twin:
+  cleanup_filename_twin:
 	remove_proc_entry(FILENAME_TWIN, ch->procdir);
-cleanup_filename_memaddr:
+  cleanup_filename_memaddr:
 	remove_proc_entry(FILENAME_MEMADDR, ch->procdir);
-cleanup_filename_clock:
+  cleanup_filename_clock:
 	if (ch->hardware == &hicomx_hw || ch->hardware == &cmx_hw)
 		remove_proc_entry(FILENAME_CLOCK, ch->procdir);
-cleanup_filename_channel:
+  cleanup_filename_channel:
 	remove_proc_entry(FILENAME_CHANNEL, ch->procdir);
-cleanup_filename_irq:
+  cleanup_filename_irq:
 	remove_proc_entry(FILENAME_IRQ, ch->procdir);
-cleanup_filename_io:
+  cleanup_filename_io:
 	remove_proc_entry(FILENAME_IO, ch->procdir);
-cleanup_HW_privdata:
+  cleanup_HW_privdata:
 	kfree(ch->HW_privdata);
 	return -EIO;
 }
@@ -1369,10 +1548,14 @@ static int COMX_exit(struct net_device *
 	struct comx_channel *ch = dev->priv;
 	struct comx_privdata *hw = ch->HW_privdata;
 
-	if (hw->firmware) {
-		if (hw->firmware->data) kfree(hw->firmware->data);
+    if (hw->firmware)
+    {
+	if (hw->firmware->data)
+	    kfree(hw->firmware->data);
 		kfree(hw->firmware);
-	} if (ch->twin) {
+    }
+    if (ch->twin)
+    {
 		struct comx_channel *twin_ch = ch->twin->priv;
 
 		twin_ch->twin = NULL;
@@ -1385,7 +1568,8 @@ static int COMX_exit(struct net_device *
 	remove_proc_entry(FILENAME_MEMADDR, ch->procdir);
 	remove_proc_entry(FILENAME_FIRMWARE, ch->procdir);
 	remove_proc_entry(FILENAME_TWIN, ch->procdir);
-	if (ch->hardware == &hicomx_hw || ch->hardware == &cmx_hw) {
+    if (ch->hardware == &hicomx_hw || ch->hardware == &cmx_hw)
+    {
 		remove_proc_entry(FILENAME_CLOCK, ch->procdir);
 	}
 
@@ -1399,7 +1583,8 @@ static int COMX_dump(struct net_device *
 	return 0;
 }
 
-static struct comx_hardware comx_hw = {
+static struct comx_hardware comx_hw =
+{
 	"comx",
 	VERSION,
 	COMX_init,
@@ -1408,7 +1593,8 @@ static struct comx_hardware comx_hw = {
 	NULL
 };
 
-static struct comx_hardware cmx_hw = {
+static struct comx_hardware cmx_hw =
+{
 	"cmx",
 	VERSION,
 	COMX_init,
@@ -1417,7 +1603,8 @@ static struct comx_hardware cmx_hw = {
 	NULL
 };
 
-static struct comx_hardware hicomx_hw = {
+static struct comx_hardware hicomx_hw =
+{
 	"hicomx",
 	VERSION,
 	COMX_init,
diff -NurpabB linux-2.4.27/drivers/net/wan/comx-hw-locomx.c linux-2.4.27-multigate/drivers/net/wan/comx-hw-locomx.c
--- linux-2.4.27/drivers/net/wan/comx-hw-locomx.c	2002-08-03 02:39:44.000000000 +0200
+++ linux-2.4.27-multigate/drivers/net/wan/comx-hw-locomx.c	2004-08-17 14:34:31.000000000 +0200
@@ -63,13 +63,17 @@ MODULE_LICENSE("GPL");
 #define LOCOMX_DEFAULT_IO 0x368
 #define LOCOMX_DEFAULT_IRQ 7
 
-u8 z8530_locomx[] = {
+u8 z8530_locomx[] =
+{
 	11,     TCRTxCP,
 	14,     DTRREQ,
 	255
 };
 
-struct locomx_data {
+static spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
+
+struct locomx_data
+{
 	int	io_extent;
 	struct	z8530_dev board;
 	struct timer_list status_timer;
@@ -83,16 +87,15 @@ static int LOCOMX_txe(struct net_device 
 	return (!hw->board.chanA.tx_next_skb);
 }
 
-
 static void locomx_rx(struct z8530_channel *c, struct sk_buff *skb)
 {
-	struct net_device *dev=c->netdevice;
-	struct comx_channel *ch=dev->priv;
+    struct net_device *dev = c->netdevice;
+    struct comx_channel *ch = dev->priv;
 	
-	if (ch->debug_flags & DEBUG_HW_RX) {
+    if (ch->debug_flags & DEBUG_HW_RX)
 		comx_debug_skb(dev, skb, "locomx_rx receiving");
-	}
-	ch->LINE_rx(dev,skb);
+
+    ch->LINE_rx(dev, skb);
 }
 
 static int LOCOMX_send_packet(struct net_device *dev, struct sk_buff *skb) 
@@ -100,48 +103,37 @@ static int LOCOMX_send_packet(struct net
 	struct comx_channel *ch = (struct comx_channel *)dev->priv;
 	struct locomx_data *hw = ch->HW_privdata;
 
-	if (ch->debug_flags & DEBUG_HW_TX) {
+    if (ch->debug_flags & DEBUG_HW_TX)
 		comx_debug_bytes(dev, skb->data, skb->len, "LOCOMX_send_packet");
-	}
 
-	if (!(ch->line_status & LINE_UP)) {
+    if (!(ch->line_status & LINE_UP))
 		return FRAME_DROPPED;
-	}
 
-	if(z8530_queue_xmit(&hw->board.chanA,skb)) {
-		printk(KERN_WARNING "%s: FRAME_DROPPED\n",dev->name);
+    if (z8530_queue_xmit(&hw->board.chanA, skb))
+    {
+	printk(KERN_WARNING "%s: FRAME_DROPPED\n", dev->name);
 		return FRAME_DROPPED;
 	}
 
-	if (ch->debug_flags & DEBUG_HW_TX) {
+    if (ch->debug_flags & DEBUG_HW_TX)
 		comx_debug(dev, "%s: LOCOMX_send_packet was successful\n\n", dev->name);
-	}
 
-	if(!hw->board.chanA.tx_next_skb) {
-		return FRAME_QUEUED;
-	} else {
-		return FRAME_ACCEPTED;
-	}
+    return hw->board.chanA.tx_next_skb ? FRAME_ACCEPTED : FRAME_QUEUED;
 }
 
 static void locomx_status_timerfun(unsigned long d)
 {
-	struct net_device *dev=(struct net_device *)d;
-	struct comx_channel *ch=dev->priv;
-	struct locomx_data *hw=ch->HW_privdata;
+    struct net_device *dev = (struct net_device *)d;
+    struct comx_channel *ch = dev->priv;
+    struct locomx_data *hw = ch->HW_privdata;
 
-	if(!(ch->line_status & LINE_UP) &&
-	    (hw->board.chanA.status & CTS)) {
+    if (!(ch->line_status & LINE_UP) && (hw->board.chanA.status & CTS))
 		ch->LINE_status(dev, ch->line_status | LINE_UP);
-	}
-	if((ch->line_status & LINE_UP) &&
-	    !(hw->board.chanA.status & CTS)) {
+    if ((ch->line_status & LINE_UP) && !(hw->board.chanA.status & CTS))
 		ch->LINE_status(dev, ch->line_status & ~LINE_UP);
-	}
-	mod_timer(&hw->status_timer,jiffies + ch->lineup_delay * HZ);
+    mod_timer(&hw->status_timer, jiffies + ch->lineup_delay * HZ);
 }
 
-
 static int LOCOMX_open(struct net_device *dev)
 {
 	struct comx_channel *ch = dev->priv;
@@ -150,58 +142,57 @@ static int LOCOMX_open(struct net_device
 	unsigned long flags;
 	int ret;
 
-	if (!dev->base_addr || !dev->irq) {
+    if (!dev->base_addr || !dev->irq)
 		return -ENODEV;
-	}
 
-	if (!request_region(dev->base_addr, hw->io_extent, dev->name)) {
+    if (!request_region(dev->base_addr, hw->io_extent, dev->name))
 		return -EAGAIN;
-	}
 
-	hw->board.chanA.ctrlio=dev->base_addr + 5;
-	hw->board.chanA.dataio=dev->base_addr + 7;
+    hw->board.chanA.ctrlio = dev->base_addr + 5;
+    hw->board.chanA.dataio = dev->base_addr + 7;
 	
-	hw->board.irq=dev->irq;
-	hw->board.chanA.netdevice=dev;
-	hw->board.chanA.dev=&hw->board;
-	hw->board.name=dev->name;
-	hw->board.chanA.txdma=TX_DMA;
-	hw->board.chanA.rxdma=RX_DMA;
-	hw->board.chanA.irqs=&z8530_nop;
-	hw->board.chanB.irqs=&z8530_nop;
-
-	if(request_irq(dev->irq, z8530_interrupt, SA_INTERRUPT, 
-	    dev->name, &hw->board)) {
-		printk(KERN_ERR "%s: unable to obtain irq %d\n", dev->name, 
-			dev->irq);
-		ret=-EAGAIN;
+    hw->board.irq = dev->irq;
+    hw->board.chanA.netdevice = dev;
+    hw->board.chanA.dev = &hw->board;
+    hw->board.name = dev->name;
+    hw->board.chanA.txdma = TX_DMA;
+    hw->board.chanA.rxdma = RX_DMA;
+    hw->board.chanA.irqs = &z8530_nop;
+    hw->board.chanB.irqs = &z8530_nop;
+
+    if (request_irq
+	(dev->irq, z8530_interrupt, SA_INTERRUPT, dev->name, &hw->board))
+    {
+	printk(KERN_ERR "%s: unable to obtain irq %d\n", dev->name, dev->irq);
+	ret = -EAGAIN;
 		goto irq_fail;
 	}
-	if(request_dma(TX_DMA,"LoCOMX (TX)")) {
+    if (request_dma(TX_DMA, "LoCOMX (TX)"))
+    {
 		printk(KERN_ERR "%s: unable to obtain TX DMA (DMA channel %d)\n", 
 			dev->name, TX_DMA);
-		ret=-EAGAIN;
+	ret = -EAGAIN;
 		goto dma1_fail;
 	}
 
-	if(request_dma(RX_DMA,"LoCOMX (RX)")) {
+    if (request_dma(RX_DMA, "LoCOMX (RX)"))
+    {
 		printk(KERN_ERR "%s: unable to obtain RX DMA (DMA channel %d)\n", 
 			dev->name, RX_DMA);
-		ret=-EAGAIN;
+	ret = -EAGAIN;
 		goto dma2_fail;
 	}
 	
-	save_flags(flags); 
-	cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
-	if(z8530_init(&hw->board)!=0)
+    if (z8530_init(&hw->board))
 	{
-		printk(KERN_ERR "%s: Z8530 device not found.\n",dev->name);
-		ret=-ENODEV;
+	printk(KERN_ERR "%s: Z8530 device not found.\n", dev->name);
+	ret = -ENODEV;
 		goto z8530_fail;
 	}
 
-	hw->board.chanA.dcdcheck=CTS;
+    hw->board.chanA.dcdcheck = CTS;
 
 	z8530_channel_load(&hw->board.chanA, z8530_hdlc_kilostream_85230);
 	z8530_channel_load(&hw->board.chanA, z8530_locomx);
@@ -209,47 +200,43 @@ static int LOCOMX_open(struct net_device
 
 	z8530_describe(&hw->board, "I/O", dev->base_addr);
 
-	if((ret=z8530_sync_dma_open(dev, &hw->board.chanA))!=0) {
+    if ((ret = z8530_sync_dma_open(dev, &hw->board.chanA)))
 		goto z8530_fail;
-	}
 
-	restore_flags(flags);
+    spin_unlock_irqrestore(&mister_lock, flags);
 
-
-	hw->board.active=1;
-	hw->board.chanA.rx_function=locomx_rx;
+    hw->board.active = 1;
+    hw->board.chanA.rx_function = locomx_rx;
 
 	ch->init_status |= HW_OPEN;
-	if (hw->board.chanA.status & DCD) {
+    if (hw->board.chanA.status & DCD)
 		ch->line_status |= LINE_UP;
-	} else {
+    else
 		ch->line_status &= ~LINE_UP;
-	}
 
 	comx_status(dev, ch->line_status);
 
 	init_timer(&hw->status_timer);
-	hw->status_timer.function=locomx_status_timerfun;
-	hw->status_timer.data=(unsigned long)dev;
-	hw->status_timer.expires=jiffies + ch->lineup_delay * HZ;
+    hw->status_timer.function = locomx_status_timerfun;
+    hw->status_timer.data = (unsigned long)dev;
+    hw->status_timer.expires = jiffies + ch->lineup_delay * HZ;
 	add_timer(&hw->status_timer);
 
-	for (; procfile ; procfile = procfile->next) {
-		if (strcmp(procfile->name, FILENAME_IO) == 0 ||
-		     strcmp(procfile->name, FILENAME_IRQ) == 0) {
+    for (; procfile; procfile = procfile->next)
+	if (!strcmp(procfile->name, FILENAME_IO) ||
+	    !strcmp(procfile->name, FILENAME_IRQ))
 			procfile->mode = S_IFREG |  0444;
-		}
-	}
+
 	return 0;
 
-z8530_fail:
-	restore_flags(flags);
+  z8530_fail:
+    spin_unlock_irqrestore(&mister_lock, flags);
 	free_dma(RX_DMA);
-dma2_fail:
+  dma2_fail:
 	free_dma(TX_DMA);
-dma1_fail:
+  dma1_fail:
 	free_irq(dev->irq, &hw->board);
-irq_fail:
+  irq_fail:
 	release_region(dev->base_addr, hw->io_extent);
 	return ret;
 }
@@ -260,7 +247,7 @@ static int LOCOMX_close(struct net_devic
 	struct locomx_data *hw = ch->HW_privdata;
 	struct proc_dir_entry *procfile = ch->procdir->subdir;
 
-	hw->board.chanA.rx_function=z8530_null_rx;
+    hw->board.chanA.rx_function = z8530_null_rx;
 	netif_stop_queue(dev);
 	z8530_sync_dma_close(dev, &hw->board.chanA);
 
@@ -269,21 +256,22 @@ static int LOCOMX_close(struct net_devic
 	del_timer(&hw->status_timer);
 	free_dma(RX_DMA);
 	free_dma(TX_DMA);
-	free_irq(dev->irq,&hw->board);
-	release_region(dev->base_addr,8);
+    free_irq(dev->irq, &hw->board);
+    release_region(dev->base_addr, 8);
 
-	for (; procfile ; procfile = procfile->next) {
-		if (strcmp(procfile->name, FILENAME_IO) == 0 ||
-		    strcmp(procfile->name, FILENAME_IRQ) == 0) {
+    while (procfile)
+    {
+	if (!strcmp(procfile->name, FILENAME_IO) ||
+	    !strcmp(procfile->name, FILENAME_IRQ))
 			procfile->mode = S_IFREG |  0644;
-		}
+	procfile = procfile->next;
 	}
 
 	ch->init_status &= ~HW_OPEN;
 	return 0;
 }
 
-static int LOCOMX_statistics(struct net_device *dev,char *page)
+static int LOCOMX_statistics(struct net_device *dev, char *page)
 {
 	int len = 0;
 
@@ -292,9 +280,10 @@ static int LOCOMX_statistics(struct net_
 	return len;
 }
 
-static int LOCOMX_dump(struct net_device *dev) {
+static int LOCOMX_dump(struct net_device *dev)
+{
 	printk(KERN_INFO "LOCOMX_dump called\n");
-	return(-1);
+    return -1;
 }
 
 static int locomx_read_proc(char *page, char **start, off_t off, int count,
@@ -304,25 +293,26 @@ static int locomx_read_proc(char *page, 
 	struct net_device *dev = file->parent->data;
 	int len = 0;
 
-	if (strcmp(file->name, FILENAME_IO) == 0) {
+    if (!strcmp(file->name, FILENAME_IO))
 		len = sprintf(page, "0x%x\n", (unsigned int)dev->base_addr);
-	} else if (strcmp(file->name, FILENAME_IRQ) == 0) {
+    else if (!strcmp(file->name, FILENAME_IRQ))
 		len = sprintf(page, "%d\n", (unsigned int)dev->irq);
-	} else {
+    else
+    {
 		printk(KERN_ERR "hw_read_proc: internal error, filename %s\n", 
 			file->name);
 		return -EBADF;
 	}
 
-	if (off >= len) {
+    if (off >= len)
+    {
 		*eof = 1;
 		return 0;
 	}
 
 	*start = page + off;
-	if (count >= len - off) {
-		*eof = 1;
-	}
+    if (count >= len - off) *eof = 1;
+
 	return min_t(int, count, len - off);
 }
 
@@ -334,31 +324,34 @@ static int locomx_write_proc(struct file
 	int val;
 	char *page;
 
-	if (!(page = (char *)__get_free_page(GFP_KERNEL))) {
+    if (!(page = (char *)__get_free_page(GFP_KERNEL)))
 		return -ENOMEM;
-	}
 
-	copy_from_user(page, buffer, count = min_t(unsigned long, count, PAGE_SIZE));
-	if (*(page + count - 1) == '\n') {
+    copy_from_user(page, buffer, count =
+		   min_t(unsigned long, count, PAGE_SIZE));
+
+    if (*(page + count - 1) == '\n')
 		*(page + count - 1) = 0;
-	}
 
-	if (strcmp(entry->name, FILENAME_IO) == 0) {
+    if (!strcmp(entry->name, FILENAME_IO))
+    {
 		val = simple_strtoul(page, NULL, 0);
-		if (val != 0x360 && val != 0x368 && val != 0x370 && 
-		   val != 0x378) {
+	if (val != 0x360 && val != 0x368 && val != 0x370 && val != 0x378)
 			printk(KERN_ERR "LoCOMX: incorrect io address!\n");	
-		} else {
+	else
 			dev->base_addr = val;
 		}
-	} else if (strcmp(entry->name, FILENAME_IRQ) == 0) {
+    else if (!strcmp(entry->name, FILENAME_IRQ))
+    {
 		val = simple_strtoul(page, NULL, 0);
-		if (val != 3 && val != 4 && val != 5 && val != 6 && val != 7) {
+//      if (val != 3 && val != 4 && val != 5 && val != 6 && val != 7)
+	if (val < 3 || val > 7)
 			printk(KERN_ERR "LoCOMX: incorrect irq value!\n");
-		} else {
+	else
 			dev->irq = val;
 		}	
-	} else {
+    else
+    {
 		printk(KERN_ERR "locomx_write_proc: internal error, filename %s\n", 
 			entry->name);
 		free_page((unsigned long)page);
@@ -377,45 +370,45 @@ static int LOCOMX_init(struct net_device
 	struct locomx_data *hw;
 	struct proc_dir_entry *new_file;
 
-	/* Alloc data for private structure */
-	if ((ch->HW_privdata = kmalloc(sizeof(struct locomx_data), 
-	   GFP_KERNEL)) == NULL) {
+    /*
+     * Alloc data for private structure 
+     */
+    if (!(ch->HW_privdata = kmalloc(sizeof(struct locomx_data), GFP_KERNEL)))
 	   	return -ENOMEM;
-	}
 
 	memset(hw = ch->HW_privdata, 0, sizeof(struct locomx_data));
 	hw->io_extent = LOCOMX_IO_EXTENT;
 
-	/* Register /proc files */
-	if ((new_file = create_proc_entry(FILENAME_IO, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    /*
+     * Register /proc files 
+     */
+    if (!(new_file =
+	 create_proc_entry(FILENAME_IO, S_IFREG | 0644, ch->procdir)))
 		goto cleanup_HW_privdata;
-	}
+
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &locomx_read_proc;
 	new_file->write_proc = &locomx_write_proc;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_IRQ, S_IFREG | 0644, 
-	    ch->procdir)) == NULL)  {
+    if (!(new_file =
+	 create_proc_entry(FILENAME_IRQ, S_IFREG | 0644, ch->procdir)))
 		goto cleanup_filename_io;
-	}
-	new_file->data = (void *)new_file;
-	new_file->read_proc = &locomx_read_proc;
-	new_file->write_proc = &locomx_write_proc;
-	new_file->nlink = 1;
 
-/* 	No clock yet */
-/*
-	if ((new_file = create_proc_entry(FILENAME_CLOCK, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
-		return -EIO;
-	}
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &locomx_read_proc;
 	new_file->write_proc = &locomx_write_proc;
 	new_file->nlink = 1;
-*/
+
+    /*
+     * No clock yet 
+     */
+    /*
+     * if ((new_file = create_proc_entry(FILENAME_CLOCK, S_IFREG | 0644,
+     * ch->procdir)) == NULL) { return -EIO; } new_file->data = (void
+     * *)new_file; new_file->read_proc = &locomx_read_proc;
+     * new_file->write_proc = &locomx_write_proc; new_file->nlink = 1; 
+     */
 
 	ch->HW_access_board = NULL;
 	ch->HW_release_board = NULL;
@@ -432,13 +425,14 @@ static int LOCOMX_init(struct net_device
 	dev->base_addr = LOCOMX_DEFAULT_IO;
 	dev->irq = LOCOMX_DEFAULT_IRQ;
 	
-	
-	/* O.K. Count one more user on this module */
+    /*
+     * O.K. Count one more user on this module 
+     */
 	MOD_INC_USE_COUNT;
 	return 0;
-cleanup_filename_io:
+  cleanup_filename_io:
 	remove_proc_entry(FILENAME_IO, ch->procdir);
-cleanup_HW_privdata:
+  cleanup_HW_privdata:
 	kfree(ch->HW_privdata);
 	return -EIO;
 }
@@ -463,13 +457,14 @@ static int LOCOMX_exit(struct net_device
 
 	remove_proc_entry(FILENAME_IO, ch->procdir);
 	remove_proc_entry(FILENAME_IRQ, ch->procdir);
-//	remove_proc_entry(FILENAME_CLOCK, ch->procdir);
+    // remove_proc_entry(FILENAME_CLOCK, ch->procdir);
 
 	MOD_DEC_USE_COUNT;
 	return 0;
 }
 
-static struct comx_hardware locomx_hw = {
+static struct comx_hardware locomx_hw =
+{
 	"locomx",
 	VERSION,
 	LOCOMX_init, 
diff -NurpabB linux-2.4.27/drivers/net/wan/comx-hw-mixcom.c linux-2.4.27-multigate/drivers/net/wan/comx-hw-mixcom.c
--- linux-2.4.27/drivers/net/wan/comx-hw-mixcom.c	2003-06-13 16:51:35.000000000 +0200
+++ linux-2.4.27-multigate/drivers/net/wan/comx-hw-mixcom.c	2004-08-17 14:34:31.000000000 +0200
@@ -57,7 +57,8 @@
 #include "hscx.h"
 
 MODULE_AUTHOR("Gergely Madarasz <gorgo@itc.hu>");
-MODULE_DESCRIPTION("Hardware-level driver for the serial port of the MixCom board");
+MODULE_DESCRIPTION
+    ("Hardware-level driver for the serial port of the MixCom board");
 MODULE_LICENSE("GPL");
 
 #define MIXCOM_DATA(d) ((struct mixcom_privdata *)(COMX_CHANNEL(d)-> \
@@ -69,12 +70,20 @@ MODULE_LICENSE("GPL");
 #define MIXCOM_DEV_BASE(port,channel) (port + MIXCOM_SERIAL_OFFSET + \
 	(1 - channel) * MIXCOM_CHANNEL_OFFSET)
 
+#define mixcom_kfree_skb(ptr) (in_irq()?dev_kfree_skb_irq(ptr):dev_kfree_skb(ptr))
+
 /* Values used to set the IRQ line */
-static unsigned char mixcom_set_irq[]={0xFF, 0xFF, 0xFF, 0x0, 0xFF, 0x2, 0x4, 0x6, 0xFF, 0xFF, 0x8, 0xA, 0xC, 0xFF, 0xE, 0xFF};
+static unsigned char mixcom_set_irq[] = {
+    0xFF, 0xFF, 0xFF, 0x0, 0xFF, 0x2, 0x4, 0x6,
+    0xFF, 0xFF, 0x8, 0xA, 0xC, 0xFF, 0xE, 0xFF
+};
 
-static unsigned char* hscx_versions[]={"A1", NULL, "A2", NULL, "A3", "2.1"};
+static unsigned char *hscx_versions[] = {
+    "A1", NULL, "A2", NULL, "A3", "2.1"
+};
 
-struct mixcom_privdata {
+struct mixcom_privdata
+{
 	u16	clock;
 	char	channel;
 	long	txbusy;
@@ -86,6 +95,8 @@ struct mixcom_privdata {
 	char	card_has_status;
 };
 
+static spinlock_t mister_lock = SPIN_LOCK_UNLOCKED;
+
 static inline void wr_hscx(struct net_device *dev, int reg, unsigned char val) 
 {
 	outb(val, dev->base_addr + reg);
@@ -102,16 +113,17 @@ static inline void hscx_cmd(struct net_d
 	unsigned char cec;
 	unsigned delay = 0;
 
-	while ((cec = (rd_hscx(dev, HSCX_STAR) & HSCX_CEC)) != 0 && 
-	    (jiffs + HZ > jiffies)) {
+    while ((cec = (rd_hscx(dev, HSCX_STAR) & HSCX_CEC)) != 0
+	   && (jiffs + HZ > jiffies))
+    {
 		udelay(1);
-		if (++delay > (100000 / HZ)) break;
+	if (++delay > (100000 / HZ))
+	    break;
 	}
-	if (cec) {
-		printk(KERN_WARNING "%s: CEC stuck, probably no clock!\n",dev->name);
-	} else {
+    if (cec)
+	printk(KERN_WARNING "%s: CEC stuck, probably no clock!\n", dev->name);
+    else
 		wr_hscx(dev, HSCX_CMDR, cmd);
-	}
 }
 
 static inline void hscx_fill_fifo(struct net_device *dev)
@@ -120,15 +132,17 @@ static inline void hscx_fill_fifo(struct
 	struct mixcom_privdata *hw = ch->HW_privdata;
 	register word to_send = hw->sending->len - hw->tx_ptr;
 
-
-	outsb(dev->base_addr + HSCX_FIFO,
-        	&(hw->sending->data[hw->tx_ptr]), min_t(unsigned int, to_send, 32));
-	if (to_send <= 32) {
+    outsb(dev->base_addr + HSCX_FIFO, &(hw->sending->data[hw->tx_ptr]),
+	  min_t(unsigned int, to_send, 32));
+    if (to_send <= 32)
+    {
         	hscx_cmd(dev, HSCX_XTF | HSCX_XME);
-	        kfree_skb(hw->sending);
+	mixcom_kfree_skb(hw->sending);
         	hw->sending = NULL; 
         	hw->tx_ptr = 0;
-        } else {
+    }
+    else
+    {
 	        hscx_cmd(dev, HSCX_XTF);
         	hw->tx_ptr += 32;
         }
@@ -139,23 +153,28 @@ static inline void hscx_empty_fifo(struc
 	struct comx_channel *ch = dev->priv;
 	struct mixcom_privdata *hw = ch->HW_privdata;
 
-	if (hw->recving == NULL) {
-        	if (!(hw->recving = dev_alloc_skb(HSCX_MTU + 16))) {
+    if (hw->recving == NULL)
+    {
+	if (!(hw->recving = dev_alloc_skb(HSCX_MTU + 16)))
+	{
 	                ch->stats.rx_dropped++;
         	        hscx_cmd(dev, HSCX_RHR);
-                } else {
+	}
+	else
+	{
 	                skb_reserve(hw->recving, 16);
         	        skb_put(hw->recving, HSCX_MTU);
                 }
 	        hw->rx_ptr = 0;
         }
-	if (cnt > 32 || !cnt || hw->recving == NULL) {
-        	printk(KERN_ERR "hscx_empty_fifo: cnt is %d, hw->recving %p\n",
-		        cnt, (void *)hw->recving);
+    if (cnt > 32 || !cnt || hw->recving == NULL)
+    {
+	printk(KERN_ERR "hscx_empty_fifo: cnt is %d, hw->recving %p\n", cnt,
+	       (void *)hw->recving);
 	        return;
         }
         
-	insb(dev->base_addr + HSCX_FIFO, &(hw->recving->data[hw->rx_ptr]),cnt);
+    insb(dev->base_addr + HSCX_FIFO, &(hw->recving->data[hw->rx_ptr]), cnt);
 	hw->rx_ptr += cnt;
 	hscx_cmd(dev, HSCX_RMC);
 }
@@ -172,51 +191,44 @@ static int MIXCOM_txe(struct net_device 
 static int mixcom_probe(struct net_device *dev)
 {
 	unsigned long flags;
-	int id, vstr, ret=0;
+    int id, vstr, ret = 0;
 
-	save_flags(flags); cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
-	id=inb_p(MIXCOM_BOARD_BASE(dev) + MIXCOM_ID_OFFSET) & 0x7f;
+    id = inb_p(MIXCOM_BOARD_BASE(dev) + MIXCOM_ID_OFFSET) & 0x7f;
 
- 	if (id != MIXCOM_ID ) {
-		ret=-ENODEV;
-		printk(KERN_WARNING "%s: no MixCOM board found at 0x%04lx\n",dev->name, dev->base_addr);
+    if (id != MIXCOM_ID)
+    {
+	ret = -ENODEV;
+	printk(KERN_WARNING "%s: no MixCOM board found at 0x%04lx\n",
+	       dev->name, dev->base_addr);
 		goto out;
 	}
 
-	vstr=inb_p(dev->base_addr + HSCX_VSTR) & 0x0f;
-	if(vstr>=sizeof(hscx_versions)/sizeof(char*) || 
-	    hscx_versions[vstr]==NULL) {
-		printk(KERN_WARNING "%s: board found but no HSCX chip detected at 0x%4lx (vstr = 0x%1x)\n",dev->name,dev->base_addr,vstr);
+    vstr = inb_p(dev->base_addr + HSCX_VSTR) & 0x0f;
+    if (vstr >= sizeof(hscx_versions) / sizeof(char *)
+	|| hscx_versions[vstr] == NULL)
+    {
+	printk(KERN_WARNING
+	       "%s: board found but no HSCX chip detected at 0x%4lx (vstr = 0x%1x)\n",
+	       dev->name, dev->base_addr, vstr);
 		ret = -ENODEV;
-	} else {
-		printk(KERN_INFO "%s: HSCX chip version %s\n",dev->name,hscx_versions[vstr]);
+    }
+    else
+    {
+	printk(KERN_INFO "%s: HSCX chip version %s\n", dev->name,
+	       hscx_versions[vstr]);
 		ret = 0;
 	}
 
-out:
-
-	restore_flags(flags);
+  out:
+    spin_unlock_irqrestore(&mister_lock, flags);
 	return ret;
 }
 
-#if 0
-static void MIXCOM_set_clock(struct net_device *dev)
-{
-	struct comx_channel *ch = dev->priv;
-	struct mixcom_privdata *hw = ch->HW_privdata;
-
-	if (hw->clock) {
-		;
-	} else {
-		;
-	}
-}
-#endif
-
 static void mixcom_board_on(struct net_device *dev)
 {
-	outb_p(MIXCOM_OFF , MIXCOM_BOARD_BASE(dev) + MIXCOM_IT_OFFSET);
+    outb_p(MIXCOM_OFF, MIXCOM_BOARD_BASE(dev) + MIXCOM_IT_OFFSET);
 	udelay(1000);
 	outb_p(mixcom_set_irq[dev->irq] | MIXCOM_ON, 
 		MIXCOM_BOARD_BASE(dev) + MIXCOM_IT_OFFSET);
@@ -225,7 +237,7 @@ static void mixcom_board_on(struct net_d
 
 static void mixcom_board_off(struct net_device *dev)
 {
-	outb_p(MIXCOM_OFF , MIXCOM_BOARD_BASE(dev) + MIXCOM_IT_OFFSET);
+    outb_p(MIXCOM_OFF, MIXCOM_BOARD_BASE(dev) + MIXCOM_IT_OFFSET);
 	udelay(1000);
 }
 
@@ -240,12 +252,13 @@ static void mixcom_on(struct net_device 
 
 	wr_hscx(dev, HSCX_CCR1, HSCX_PU | HSCX_ODS | HSCX_ITF); // power up, push-pull
 	wr_hscx(dev, HSCX_CCR2, HSCX_CIE /* | HSCX_RIE */ );
-	wr_hscx(dev, HSCX_MODE, HSCX_TRANS | HSCX_ADM8 | HSCX_RAC | HSCX_RTS );
+    wr_hscx(dev, HSCX_MODE, HSCX_TRANS | HSCX_ADM8 | HSCX_RAC | HSCX_RTS);
 	wr_hscx(dev, HSCX_RLCR, HSCX_RC | 47); // 1504 bytes
-	wr_hscx(dev, HSCX_MASK, HSCX_RSC | HSCX_TIN );
+    wr_hscx(dev, HSCX_MASK, HSCX_RSC | HSCX_TIN);
 	hscx_cmd(dev, HSCX_XRES | HSCX_RHR);
 
-	if (ch->HW_set_clock) ch->HW_set_clock(dev);
+    if (ch->HW_set_clock)
+	ch->HW_set_clock(dev);
 
 }
 
@@ -255,24 +268,26 @@ static int MIXCOM_send_packet(struct net
 	struct mixcom_privdata *hw = ch->HW_privdata;
 	unsigned long flags;
 
-	if (ch->debug_flags & DEBUG_HW_TX) {
+    if (ch->debug_flags & DEBUG_HW_TX)
 		comx_debug_bytes(dev, skb->data, skb->len, "MIXCOM_send_packet");
-	}
 
-	if (!(ch->line_status & LINE_UP)) {
+    if (!(ch->line_status & LINE_UP))
 		return FRAME_DROPPED;
-	}
 
-	if (skb->len > HSCX_MTU) {
+    if (skb->len > HSCX_MTU)
+    {
 		ch->stats.tx_errors++;	
 		return FRAME_ERROR;
 	}
 
-	save_flags(flags); cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
-	if (test_and_set_bit(0, &hw->txbusy)) {
-		printk(KERN_ERR "%s: transmitter called while busy... dropping frame (length %d)\n", dev->name, skb->len);
-		restore_flags(flags);
+    if (test_and_set_bit(0, &hw->txbusy))
+    {
+	printk(KERN_ERR
+	       "%s: transmitter called while busy... dropping frame (length %d)\n",
+	       dev->name, skb->len);
+	spin_unlock_irqrestore(&mister_lock, flags);
 		return FRAME_DROPPED;
 	}
 
@@ -282,63 +297,54 @@ static int MIXCOM_send_packet(struct net
 	hw->txbusy = 1;
 //	atomic_inc(&skb->users);	// save it
 	hscx_fill_fifo(dev);
-	restore_flags(flags);
+    spin_unlock_irqrestore(&mister_lock, flags);
 
 	ch->stats.tx_packets++;
 	ch->stats.tx_bytes += skb->len; 
 
-	if (ch->debug_flags & DEBUG_HW_TX) {
+    if (ch->debug_flags & DEBUG_HW_TX)
 		comx_debug(dev, "MIXCOM_send_packet was successful\n\n");
-	}
 
 	return FRAME_ACCEPTED;
 }
 
 static inline void mixcom_receive_frame(struct net_device *dev) 
 {
-	struct comx_channel *ch=dev->priv;
-	struct mixcom_privdata *hw=ch->HW_privdata;
+    struct comx_channel *ch = dev->priv;
+    struct mixcom_privdata *hw = ch->HW_privdata;
 	register byte rsta;
 	register word length;
 
-	rsta = rd_hscx(dev, HSCX_RSTA) & (HSCX_VFR | HSCX_RDO | 
-		HSCX_CRC | HSCX_RAB);
-	length = ((rd_hscx(dev, HSCX_RBCH) & 0x0f) << 8) | 
-		rd_hscx(dev, HSCX_RBCL);
+    rsta =
+	rd_hscx(dev, HSCX_RSTA) & (HSCX_VFR | HSCX_RDO | HSCX_CRC | HSCX_RAB);
+    length =
+	((rd_hscx(dev, HSCX_RBCH) & 0x0f) << 8) | rd_hscx(dev, HSCX_RBCL);
 
-	if ( length > hw->rx_ptr ) {
+    if (length > hw->rx_ptr)
 		hscx_empty_fifo(dev, length - hw->rx_ptr);
-	}
 	
-	if (!(rsta & HSCX_VFR)) {
+    if (!(rsta & HSCX_VFR))
 		ch->stats.rx_length_errors++;
-	}
-	if (rsta & HSCX_RDO) {
+    if (rsta & HSCX_RDO)
 		ch->stats.rx_over_errors++;
-	}
-	if (!(rsta & HSCX_CRC)) {
+    if (!(rsta & HSCX_CRC))
 		ch->stats.rx_crc_errors++;
-	}
-	if (rsta & HSCX_RAB) {
+    if (rsta & HSCX_RAB)
 		ch->stats.rx_frame_errors++;
-	}
 	ch->stats.rx_packets++; 
 	ch->stats.rx_bytes += length;
 
-	if (rsta == (HSCX_VFR | HSCX_CRC) && hw->recving) {
+    if (rsta == (HSCX_VFR | HSCX_CRC) && hw->recving)
+    {
 		skb_trim(hw->recving, hw->rx_ptr - 1);
-		if (ch->debug_flags & DEBUG_HW_RX) {
-			comx_debug_skb(dev, hw->recving,
-				"MIXCOM_interrupt receiving");
-		}
+	if (ch->debug_flags & DEBUG_HW_RX)
+	    comx_debug_skb(dev, hw->recving, "MIXCOM_interrupt receiving");
 		hw->recving->dev = dev;
-		if (ch->LINE_rx) {
+	if (ch->LINE_rx)
 			ch->LINE_rx(dev, hw->recving);
 		}
-	}
-	else if(hw->recving) {
-		kfree_skb(hw->recving);
-	}
+    else if (hw->recving)
+	mixcom_kfree_skb(hw->recving);
 	hw->recving = NULL; 
 	hw->rx_ptr = 0;
 }
@@ -343,67 +349,72 @@ static inline void mixcom_receive_frame(
 	hw->rx_ptr = 0;
 }
 
-
 static inline void mixcom_extended_interrupt(struct net_device *dev) 
 {
-	struct comx_channel *ch=dev->priv;
-	struct mixcom_privdata *hw=ch->HW_privdata;
+    struct comx_channel *ch = dev->priv;
+    struct mixcom_privdata *hw = ch->HW_privdata;
 	register byte exir;
 
-	exir = rd_hscx(dev, HSCX_EXIR) & (HSCX_XDU | HSCX_RFO | HSCX_CSC );
+    exir = rd_hscx(dev, HSCX_EXIR) & (HSCX_XDU | HSCX_RFO | HSCX_CSC);
 
-	if (exir & HSCX_RFO) {
+    if (exir & HSCX_RFO)
+    {
 		ch->stats.rx_over_errors++;
-		if (hw->rx_ptr) {
-			kfree_skb(hw->recving);
-			hw->recving = NULL; hw->rx_ptr = 0;
+	if (hw->rx_ptr)
+	{
+	    mixcom_kfree_skb(hw->recving);
+	    hw->recving = NULL;
+	    hw->rx_ptr = 0;
 		}
 		printk(KERN_ERR "MIXCOM: rx overrun\n");
 		hscx_cmd(dev, HSCX_RHR);
 	}
 
-	if (exir & HSCX_XDU) { // xmit underrun
+    if (exir & HSCX_XDU)
+    {				// xmit underrun
 		ch->stats.tx_errors++;
 		ch->stats.tx_aborted_errors++;
-		if (hw->tx_ptr) {
-			kfree_skb(hw->sending);
+	if (hw->tx_ptr)
+	{
+	    mixcom_kfree_skb(hw->sending);
 			hw->sending = NULL; 
 			hw->tx_ptr = 0;
 		}
 		hscx_cmd(dev, HSCX_XRES);
 		clear_bit(0, &hw->txbusy);
-		if (ch->LINE_tx) {
+	if (ch->LINE_tx)
 			ch->LINE_tx(dev);
-		}
 		printk(KERN_ERR "MIXCOM: tx underrun\n");
 	}
 
-	if (exir & HSCX_CSC) {        
+    if (exir & HSCX_CSC)
+    {
 		ch->stats.tx_carrier_errors++;
-		if ((rd_hscx(dev, HSCX_STAR) & HSCX_CTS) == 0) { // Vonal le
-			if (test_and_clear_bit(0, &ch->lineup_pending)) {
+	if ((rd_hscx(dev, HSCX_STAR) & HSCX_CTS) == 0)
+	{			// Vonal le
+	    if (test_and_clear_bit(0, &ch->lineup_pending))
                			del_timer(&ch->lineup_timer);
-			} else if (ch->line_status & LINE_UP) {
+	    else if (ch->line_status & LINE_UP)
+	    {
         		       	ch->line_status &= ~LINE_UP;
-                		if (ch->LINE_status) {
-                      			ch->LINE_status(dev,ch->line_status);
-                      		}
+		if (ch->LINE_status)
+		    ch->LINE_status(dev, ch->line_status);
 		      	}
 		}
-		if (!(ch->line_status & LINE_UP) && (rd_hscx(dev, HSCX_STAR) & 
-		    HSCX_CTS)) { // Vonal fol
-			if (!test_and_set_bit(0,&ch->lineup_pending)) {
+	if (!(ch->line_status & LINE_UP)
+	    && (rd_hscx(dev, HSCX_STAR) & HSCX_CTS))
+	{			// Vonal fol
+	    if (!test_and_set_bit(0, &ch->lineup_pending))
+	    {
 				ch->lineup_timer.function = comx_lineup_func;
 	        	        ch->lineup_timer.data = (unsigned long)dev;
-        	        	ch->lineup_timer.expires = jiffies + HZ * 
-        	        		ch->lineup_delay;
+		ch->lineup_timer.expires = jiffies + HZ * ch->lineup_delay;
 	                	add_timer(&ch->lineup_timer);
 		                hscx_cmd(dev, HSCX_XRES);
         		        clear_bit(0, &hw->txbusy);
-                		if (hw->sending) {
-					kfree_skb(hw->sending);
-				}
-				hw->sending=NULL;
+		if (hw->sending)
+		    mixcom_kfree_skb(hw->sending);
+		hw->sending = NULL;
 				hw->tx_ptr = 0;
 			}
 		}
@@ -419,58 +430,62 @@ static void MIXCOM_interrupt(int irq, vo
 	struct mixcom_privdata *hw, *twin_hw;
 	register unsigned char ista;
 
-	if (dev==NULL) {
-		printk(KERN_ERR "comx_interrupt: irq %d for unknown device\n",irq);
+    if (dev == NULL)
+    {
+	printk(KERN_ERR "comx_interrupt: irq %d for unknown device\n", irq);
 		return;
 	}
 
 	ch = dev->priv; 
 	hw = ch->HW_privdata;
 
-	save_flags(flags); cli(); 
+    spin_lock_irqsave(&mister_lock, flags);
 
-	while((ista = (rd_hscx(dev, HSCX_ISTA) & (HSCX_RME | HSCX_RPF | 
-	    HSCX_XPR | HSCX_EXB | HSCX_EXA | HSCX_ICA)))) {
+    while ((ista =
+	    (rd_hscx(dev, HSCX_ISTA) &
+	     (HSCX_RME | HSCX_RPF | HSCX_XPR | HSCX_EXB | HSCX_EXA |
+	      HSCX_ICA))))
+    {
 		register byte ista2 = 0;
 
-		if (ista & HSCX_RME) {
+	if (ista & HSCX_RME)
 			mixcom_receive_frame(dev);
-		}
-		if (ista & HSCX_RPF) {
+	if (ista & HSCX_RPF)
 			hscx_empty_fifo(dev, 32);
-		}
-		if (ista & HSCX_XPR) {
-			if (hw->tx_ptr) {
+	if (ista & HSCX_XPR)
+	{
+	    if (hw->tx_ptr)
 				hscx_fill_fifo(dev);
-			} else {
+	    else
+	    {
 				clear_bit(0, &hw->txbusy);
                			ch->LINE_tx(dev);
 			}
 		}
 		
-		if (ista & HSCX_EXB) {
+	if (ista & HSCX_EXB)
 			mixcom_extended_interrupt(dev);
-		}
 		
-		if ((ista & HSCX_EXA) && ch->twin)  {
+	if ((ista & HSCX_EXA) && ch->twin)
 			mixcom_extended_interrupt(ch->twin);
-		}
 	
-		if ((ista & HSCX_ICA) && ch->twin &&
-		    (ista2 = rd_hscx(ch->twin, HSCX_ISTA) &
-		    (HSCX_RME | HSCX_RPF | HSCX_XPR ))) {
-			if (ista2 & HSCX_RME) {
+	if ((ista & HSCX_ICA) && ch->twin
+	    && (ista2 =
+		rd_hscx(ch->twin,
+			HSCX_ISTA) & (HSCX_RME | HSCX_RPF | HSCX_XPR)))
+	{
+	    if (ista2 & HSCX_RME)
 				mixcom_receive_frame(ch->twin);
-			}
-			if (ista2 & HSCX_RPF) {
+	    if (ista2 & HSCX_RPF)
 				hscx_empty_fifo(ch->twin, 32);
-			}
-			if (ista2 & HSCX_XPR) {
-				twin_ch=ch->twin->priv;
-				twin_hw=twin_ch->HW_privdata;
-				if (twin_hw->tx_ptr) {
+	    if (ista2 & HSCX_XPR)
+	    {
+		twin_ch = ch->twin->priv;
+		twin_hw = twin_ch->HW_privdata;
+		if (twin_hw->tx_ptr)
 					hscx_fill_fifo(ch->twin);
-				} else {
+		else
+		{
 					clear_bit(0, &twin_hw->txbusy);
 					ch->LINE_tx(ch->twin);
 				}
@@ -478,7 +493,7 @@ static void MIXCOM_interrupt(int irq, vo
 		}
 	}
 
-	restore_flags(flags);
+    spin_unlock_irqrestore(&mister_lock, flags);
 	return;
 }
 
@@ -493,11 +508,12 @@ static int MIXCOM_open(struct net_device
 	if (!dev->base_addr || !dev->irq)
 		goto err_ret;
 
-
-	if(hw->channel==1) {
-		if(!TWIN(dev) || !(COMX_CHANNEL(TWIN(dev))->init_status & 
-		    IRQ_ALLOCATED)) {
-			printk(KERN_ERR "%s: channel 0 not yet initialized\n",dev->name);
+    if (hw->channel == 1)
+    {
+	if (!TWIN(dev)
+	    || !(COMX_CHANNEL(TWIN(dev))->init_status & IRQ_ALLOCATED))
+	{
+	    printk(KERN_ERR "%s: channel 0 not yet initialized\n", dev->name);
 			ret = -EAGAIN;
 			goto err_ret;
 		}
@@ -503,72 +519,76 @@ static int MIXCOM_open(struct net_device
 		}
 	}
 
-
 	/* Is our hw present at all ? Not checking for channel 0 if it is already 
 	   open */
-	if(hw->channel!=0 || !(ch->init_status & IRQ_ALLOCATED)) {
-		if (!request_region(dev->base_addr, MIXCOM_IO_EXTENT, dev->name)) {
+    if (hw->channel != 0 || !(ch->init_status & IRQ_ALLOCATED))
+    {
+	if (!request_region(dev->base_addr, MIXCOM_IO_EXTENT, dev->name))
+	{
 			ret = -EAGAIN;
 			goto err_ret;
 		}
-		if (mixcom_probe(dev)) {
+	if (mixcom_probe(dev))
+	{
 			ret = -ENODEV;
 			goto err_release_region;
 		}
 	}
 
-	if(hw->channel==0 && !(ch->init_status & IRQ_ALLOCATED)) {
-		if (request_irq(dev->irq, MIXCOM_interrupt, 0, 
-		    dev->name, (void *)dev)) {
+    if (hw->channel == 0 && !(ch->init_status & IRQ_ALLOCATED))
+    {
+	if (request_irq
+	    (dev->irq, MIXCOM_interrupt, 0, dev->name, (void *)dev))
+	{
 			printk(KERN_ERR "MIXCOM: unable to obtain irq %d\n", dev->irq);
 			ret = -EAGAIN;
 			goto err_release_region;
 		}
 	}
 
-	save_flags(flags); cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
-	if(hw->channel==0 && !(ch->init_status & IRQ_ALLOCATED)) {
-		ch->init_status|=IRQ_ALLOCATED;
+    if (hw->channel == 0 && !(ch->init_status & IRQ_ALLOCATED))
+    {
+	ch->init_status |= IRQ_ALLOCATED;
 		mixcom_board_on(dev);
 	}
 
 	mixcom_on(dev);
 
-
-	hw->status=inb(MIXCOM_BOARD_BASE(dev) + MIXCOM_STATUS_OFFSET);
-	if(hw->status != 0xff) {
+    hw->status = inb(MIXCOM_BOARD_BASE(dev) + MIXCOM_STATUS_OFFSET);
+    if (hw->status != 0xff)
+    {
 		printk(KERN_DEBUG "%s: board has status register, good\n", dev->name);
-		hw->card_has_status=1;
+	hw->card_has_status = 1;
 	}
 
 	hw->txbusy = 0;
 	ch->init_status |= HW_OPEN;
 	
-	if (rd_hscx(dev, HSCX_STAR) & HSCX_CTS) {
+    if (rd_hscx(dev, HSCX_STAR) & HSCX_CTS)
 		ch->line_status |= LINE_UP;
-	} else {
+    else
 		ch->line_status &= ~LINE_UP;
-	}
 
-	restore_flags(flags);
+    spin_unlock_irqrestore(&mister_lock, flags);
 
 	ch->LINE_status(dev, ch->line_status);
 
-	for (; procfile ; procfile = procfile->next) {
-		if (strcmp(procfile->name, FILENAME_IO) == 0 ||
-		    strcmp(procfile->name, FILENAME_CHANNEL) == 0 ||
-		    strcmp(procfile->name, FILENAME_CLOCK) == 0 ||
-		    strcmp(procfile->name, FILENAME_IRQ) == 0) {
+    for (; procfile; procfile = procfile->next)
+    {
+	if (strcmp(procfile->name, FILENAME_IO) == 0
+	    || strcmp(procfile->name, FILENAME_CHANNEL) == 0
+	    || strcmp(procfile->name, FILENAME_CLOCK) == 0
+	    || strcmp(procfile->name, FILENAME_IRQ) == 0)
 			procfile->mode = S_IFREG |  0444;
 		}
-	}
 
 	return 0;
 	
-err_release_region:
+  err_release_region:
 	release_region(dev->base_addr, MIXCOM_IO_EXTENT);
-err_ret:
+  err_ret:
 	return ret;
 }
 
@@ -579,14 +599,15 @@ static int MIXCOM_close(struct net_devic
 	struct proc_dir_entry *procfile = ch->procdir->subdir;
 	unsigned long flags;
 
-
-	save_flags(flags); cli();
+    spin_lock_irqsave(&mister_lock, flags);
 
 	mixcom_off(dev);
 
 	/* This is channel 0, twin is not open, we can safely turn off everything */
-	if(hw->channel==0 && (!(TWIN(dev)) || 
-	    !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN))) {
+    if (hw->channel == 0
+	&& (!(TWIN(dev))
+	    || !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN)))
+    {
 		mixcom_board_off(dev);
 		free_irq(dev->irq, dev);
 		release_region(dev->base_addr, MIXCOM_IO_EXTENT);
@@ -595,8 +616,10 @@ static int MIXCOM_close(struct net_devic
 
 	/* This is channel 1, channel 0 has already been shutdown, we can release
 	   this one too */
-	if(hw->channel==1 && !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN)) {
-		if(COMX_CHANNEL(TWIN(dev))->init_status & IRQ_ALLOCATED) {
+    if (hw->channel == 1 && !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN))
+    {
+	if (COMX_CHANNEL(TWIN(dev))->init_status & IRQ_ALLOCATED)
+	{
 			mixcom_board_off(TWIN(dev));
 			free_irq(TWIN(dev)->irq, TWIN(dev));
 			release_region(TWIN(dev)->base_addr, MIXCOM_IO_EXTENT);
@@ -605,46 +628,48 @@ static int MIXCOM_close(struct net_devic
 	}
 
 	/* the ioports for channel 1 can be safely released */
-	if(hw->channel==1) {
+    if (hw->channel == 1)
 		release_region(dev->base_addr, MIXCOM_IO_EXTENT);
-	}
 
-	restore_flags(flags);
+    spin_unlock_irqrestore(&mister_lock, flags);
 
 	/* If we don't hold any hardware open */
-	if(!(ch->init_status & IRQ_ALLOCATED)) {
-		for (; procfile ; procfile = procfile->next) {
-			if (strcmp(procfile->name, FILENAME_IO) == 0 ||
-			    strcmp(procfile->name, FILENAME_CHANNEL) == 0 ||
-			    strcmp(procfile->name, FILENAME_CLOCK) == 0 ||
-			    strcmp(procfile->name, FILENAME_IRQ) == 0) {
+    if (!(ch->init_status & IRQ_ALLOCATED))
+    {
+	for (; procfile; procfile = procfile->next)
+	{
+	    if (strcmp(procfile->name, FILENAME_IO) == 0
+		|| strcmp(procfile->name, FILENAME_CHANNEL) == 0
+		|| strcmp(procfile->name, FILENAME_CLOCK) == 0
+		|| strcmp(procfile->name, FILENAME_IRQ) == 0)
 				procfile->mode = S_IFREG |  0644;
 			}
 		}
-	}
 
 	/* channel 0 was only waiting for us to close channel 1 
 	   close it completely */
    
-	if(hw->channel==1 && !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN)) {
-		for (procfile=COMX_CHANNEL(TWIN(dev))->procdir->subdir; 
-		    procfile ; procfile = procfile->next) {
-			if (strcmp(procfile->name, FILENAME_IO) == 0 ||
-			    strcmp(procfile->name, FILENAME_CHANNEL) == 0 ||
-			    strcmp(procfile->name, FILENAME_CLOCK) == 0 ||
-			    strcmp(procfile->name, FILENAME_IRQ) == 0) {
+    if (hw->channel == 1 && !(COMX_CHANNEL(TWIN(dev))->init_status & HW_OPEN))
+    {
+	for (procfile = COMX_CHANNEL(TWIN(dev))->procdir->subdir; procfile;
+	     procfile = procfile->next)
+	{
+	    if (strcmp(procfile->name, FILENAME_IO) == 0
+		|| strcmp(procfile->name, FILENAME_CHANNEL) == 0
+		|| strcmp(procfile->name, FILENAME_CLOCK) == 0
+		|| strcmp(procfile->name, FILENAME_IRQ) == 0)
 				procfile->mode = S_IFREG |  0644;
 			}
 		}
-	}
 	
 	ch->init_status &= ~HW_OPEN;
 	return 0;
 }
 
-static int MIXCOM_statistics(struct net_device *dev,char *page)
+static int MIXCOM_statistics(struct net_device *dev, char *page)
 {
 	struct comx_channel *ch = dev->priv;
+
 	// struct mixcom_privdata *hw = ch->HW_privdata;
 	int len = 0;
 
@@ -648,14 +673,14 @@ static int MIXCOM_statistics(struct net_
 	// struct mixcom_privdata *hw = ch->HW_privdata;
 	int len = 0;
 
-	if(ch->init_status && IRQ_ALLOCATED) {
+    if (ch->init_status && IRQ_ALLOCATED)
 		len += sprintf(page + len, "Mixcom board: hardware open\n");
-	}
 
 	return len;
 }
 
-static int MIXCOM_dump(struct net_device *dev) {
+static int MIXCOM_dump(struct net_device *dev)
+{
 	return 0;
 }
 
@@ -668,33 +693,41 @@ static int mixcom_read_proc(char *page, 
 	struct mixcom_privdata *hw = ch->HW_privdata;
 	int len = 0;
 
-	if (strcmp(file->name, FILENAME_IO) == 0) {
-		len = sprintf(page, "0x%x\n", 
-			(unsigned int)MIXCOM_BOARD_BASE(dev));
-	} else if (strcmp(file->name, FILENAME_IRQ) == 0) {
+    if (strcmp(file->name, FILENAME_IO) == 0)
+	len = sprintf(page, "0x%x\n", (unsigned int)MIXCOM_BOARD_BASE(dev));
+    else if (strcmp(file->name, FILENAME_IRQ) == 0)
 		len = sprintf(page, "%d\n", (unsigned int)dev->irq);
-	} else if (strcmp(file->name, FILENAME_CLOCK) == 0) {
-		if (hw->clock) len = sprintf(page, "%d\n", hw->clock);
-			else len = sprintf(page, "external\n");
-	} else if (strcmp(file->name, FILENAME_CHANNEL) == 0) {
+    else if (strcmp(file->name, FILENAME_CLOCK) == 0)
+    {
+	if (hw->clock)
+	    len = sprintf(page, "%d\n", hw->clock);
+	else
+	    len = sprintf(page, "external\n");
+    }
+    else if (strcmp(file->name, FILENAME_CHANNEL) == 0)
 		len = sprintf(page, "%01d\n", hw->channel);
-	} else if (strcmp(file->name, FILENAME_TWIN) == 0) {
-		if (ch->twin) {
-			len = sprintf(page, "%s\n",ch->twin->name);
-		} else {
+    else if (strcmp(file->name, FILENAME_TWIN) == 0)
+    {
+	if (ch->twin)
+	    len = sprintf(page, "%s\n", ch->twin->name);
+	else
 			len = sprintf(page, "none\n");
 		}
-	} else {
-		printk(KERN_ERR "mixcom_read_proc: internal error, filename %s\n", file->name);
+    else
+    {
+	printk(KERN_ERR "mixcom_read_proc: internal error, filename %s\n",
+	       file->name);
 		return -EBADF;
 	}
 
-	if (off >= len) {
+    if (off >= len)
+    {
 		*eof = 1;
 		return 0;
 	}
 	*start = page + off;
-	if (count >= len - off) *eof = 1;
+    if (count >= len - off)
+	*eof = 1;
 	return min_t(int, count, len - off);
 }
 
@@ -709,42 +742,37 @@ static struct net_device *mixcom_twin_ch
 	struct comx_channel *ch_twin;
 	struct mixcom_privdata *hw_twin;
 
-
-	for ( ; procfile ; procfile = procfile->next) {
-		if(!S_ISDIR(procfile->mode)) continue;
+    for (; procfile; procfile = procfile->next)
+    {
+	if (!S_ISDIR(procfile->mode))
+	    continue;
                 
         	twin = procfile->data;
 	        ch_twin = twin->priv;
         	hw_twin = ch_twin->HW_privdata;
 
-
-	        if (twin != dev && dev->irq && dev->base_addr && 
-        	    dev->irq == twin->irq && 
-        	    ch->hardware == ch_twin->hardware &&
-		    dev->base_addr == twin->base_addr + 
-		    (1-2*hw->channel)*MIXCOM_CHANNEL_OFFSET &&
-		    hw->channel == (1 - hw_twin->channel)) {
-	        	if  (!TWIN(twin) || TWIN(twin)==dev) {
+	if (twin != dev && dev->irq && dev->base_addr && dev->irq == twin->irq
+	    && ch->hardware == ch_twin->hardware
+	    && dev->base_addr ==
+	    twin->base_addr + (1 - 2 * hw->channel) * MIXCOM_CHANNEL_OFFSET
+	    && hw->channel == (1 - hw_twin->channel))
+	    if (!TWIN(twin) || TWIN(twin) == dev)
 	        		return twin;
 	        	}
-		}
-        }
 	return NULL;
 }
 
-
-static void setup_twin(struct net_device* dev) 
+static void setup_twin(struct net_device *dev)
 {
 
-	if(TWIN(dev) && TWIN(TWIN(dev))) {
-		TWIN(TWIN(dev))=NULL;
-	}
-	if ((TWIN(dev) = mixcom_twin_check(dev)) != NULL) {
-		if (TWIN(TWIN(dev)) && TWIN(TWIN(dev)) != dev) {
-			TWIN(dev)=NULL;
-		} else {
-			TWIN(TWIN(dev))=dev;
-		}
+    if (TWIN(dev) && TWIN(TWIN(dev)))
+	TWIN(TWIN(dev)) = NULL;
+    if ((TWIN(dev) = mixcom_twin_check(dev)) != NULL)
+    {
+	if (TWIN(TWIN(dev)) && TWIN(TWIN(dev)) != dev)
+	    TWIN(dev) = NULL;
+	else
+	    TWIN(TWIN(dev)) = dev;
 	}	
 }
 
@@ -758,58 +786,65 @@ static int mixcom_write_proc(struct file
 	char *page;
 	int value;
 
-	if (!(page = (char *)__get_free_page(GFP_KERNEL))) {
+    if (!(page = (char *)__get_free_page(GFP_KERNEL)))
 		return -ENOMEM;
-	}
 
-	copy_from_user(page, buffer, count = min_t(unsigned long, count, PAGE_SIZE));
-	if (*(page + count - 1) == '\n') {
+    copy_from_user(page, buffer, count =
+		   min_t(unsigned long, count, PAGE_SIZE));
+    if (*(page + count - 1) == '\n')
 		*(page + count - 1) = 0;
-	}
 
-	if (strcmp(entry->name, FILENAME_IO) == 0) {
+    if (strcmp(entry->name, FILENAME_IO) == 0)
+    {
 		value = simple_strtoul(page, NULL, 0);
-		if (value != 0x180 && value != 0x280 && value != 0x380) {
+	if (value != 0x180 && value != 0x280 && value != 0x380)
 			printk(KERN_ERR "MIXCOM: incorrect io address!\n");
-		} else {
-			dev->base_addr = MIXCOM_DEV_BASE(value,hw->channel);
+	else
+	    dev->base_addr = MIXCOM_DEV_BASE(value, hw->channel);
 		}
-	} else if (strcmp(entry->name, FILENAME_IRQ) == 0) {
+    else if (strcmp(entry->name, FILENAME_IRQ) == 0)
+    {
 		value = simple_strtoul(page, NULL, 0); 
-		if (value < 0 || value > 15 || mixcom_set_irq[value]==0xFF) {
+	if (value < 0 || value > 15 || mixcom_set_irq[value] == 0xFF)
 			printk(KERN_ERR "MIXCOM: incorrect irq value!\n");
-		} else {
+	else
 			dev->irq = value;	
 		}
-	} else if (strcmp(entry->name, FILENAME_CLOCK) == 0) {
-		if (strncmp("ext", page, 3) == 0) {
+    else if (strcmp(entry->name, FILENAME_CLOCK) == 0)
+    {
+	if (strncmp("ext", page, 3) == 0)
 			hw->clock = 0;
-		} else {
+	else
+	{
 			int kbps;
 
 			kbps = simple_strtoul(page, NULL, 0);
-			if (!kbps) {
+	    if (!kbps)
 				hw->clock = 0;
-			} else {
+	    else
 				hw->clock = kbps;
-			}
-			if (hw->clock < 32 || hw->clock > 2000) {
+	    if (hw->clock < 32 || hw->clock > 2000)
+	    {
 				hw->clock = 0;
 				printk(KERN_ERR "MIXCOM: invalid clock rate!\n");
 			}
 		}
-		if (ch->init_status & HW_OPEN && ch->HW_set_clock) {
+	if (ch->init_status & HW_OPEN && ch->HW_set_clock)
 			ch->HW_set_clock(dev);
 		}
-	} else if (strcmp(entry->name, FILENAME_CHANNEL) == 0) {
+    else if (strcmp(entry->name, FILENAME_CHANNEL) == 0)
+    {
 		value = simple_strtoul(page, NULL, 0);
-        	if (value > 2) {
+	if (value > 2)
                 	printk(KERN_ERR "Invalid channel number\n");
-	        } else {
-        		dev->base_addr+=(hw->channel - value) * MIXCOM_CHANNEL_OFFSET;
+	else
+	{
+	    dev->base_addr += (hw->channel - value) * MIXCOM_CHANNEL_OFFSET;
 	        	hw->channel = value;
 		}	        
-	} else {
+    }
+    else
+    {
 		printk(KERN_ERR "hw_read_proc: internal error, filename %s\n", 
 			entry->name);
 		return -EBADF;
@@ -821,60 +856,48 @@ static int mixcom_write_proc(struct file
 	return count;
 }
 
-static int MIXCOM_init(struct net_device *dev) {
+static int MIXCOM_init(struct net_device *dev)
+{
 	struct comx_channel *ch = dev->priv;
 	struct mixcom_privdata *hw;
 	struct proc_dir_entry *new_file;
 
-	if ((ch->HW_privdata = kmalloc(sizeof(struct mixcom_privdata), 
-	    GFP_KERNEL)) == NULL) {
+    if ((ch->HW_privdata =
+	 kmalloc(sizeof(struct mixcom_privdata), GFP_KERNEL)) == NULL)
 	    	return -ENOMEM;
-	}
 
 	memset(hw = ch->HW_privdata, 0, sizeof(struct mixcom_privdata));
 
-	if ((new_file = create_proc_entry(FILENAME_IO, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_IO, S_IFREG | 0644, ch->procdir)) == NULL)
 		goto cleanup_HW_privdata;
-	}
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &mixcom_read_proc;
 	new_file->write_proc = &mixcom_write_proc;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_IRQ, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_IRQ, S_IFREG | 0644,
+			   ch->procdir)) == NULL)
 	    	goto cleanup_filename_io;
-	}
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &mixcom_read_proc;
 	new_file->write_proc = &mixcom_write_proc;
 	new_file->nlink = 1;
 
-#if 0
-	if ((new_file = create_proc_entry(FILENAME_CLOCK, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
-	    	return -EIO;
-	}
-	new_file->data = (void *)new_file;
-	new_file->read_proc = &mixcom_read_proc;
-	new_file->write_proc = &mixcom_write_proc;
-	new_file->nlink = 1;
-#endif
-
-	if ((new_file = create_proc_entry(FILENAME_CHANNEL, S_IFREG | 0644, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_CHANNEL, S_IFREG | 0644,
+			   ch->procdir)) == NULL)
 	    	goto cleanup_filename_irq;
-	}
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &mixcom_read_proc;
 	new_file->write_proc = &mixcom_write_proc;
 	new_file->nlink = 1;
 
-	if ((new_file = create_proc_entry(FILENAME_TWIN, S_IFREG | 0444, 
-	    ch->procdir)) == NULL) {
+    if ((new_file =
+	 create_proc_entry(FILENAME_TWIN, S_IFREG | 0444,
+			   ch->procdir)) == NULL)
 	    	goto cleanup_filename_channel;
-	}
 	new_file->data = (void *)new_file;
 	new_file->read_proc = &mixcom_read_proc;
 	new_file->write_proc = &mixcom_write_proc;
@@ -892,18 +915,18 @@ static int MIXCOM_init(struct net_device
 	ch->HW_statistics = MIXCOM_statistics;
 	ch->HW_set_clock = NULL;
 
-	dev->base_addr = MIXCOM_DEV_BASE(MIXCOM_DEFAULT_IO,0);
+    dev->base_addr = MIXCOM_DEV_BASE(MIXCOM_DEFAULT_IO, 0);
 	dev->irq = MIXCOM_DEFAULT_IRQ;
 
 	MOD_INC_USE_COUNT;
 	return 0;
-cleanup_filename_channel:
+  cleanup_filename_channel:
 	remove_proc_entry(FILENAME_CHANNEL, ch->procdir);
-cleanup_filename_irq:
+  cleanup_filename_irq:
 	remove_proc_entry(FILENAME_IRQ, ch->procdir);
-cleanup_filename_io:
+  cleanup_filename_io:
 	remove_proc_entry(FILENAME_IO, ch->procdir);
-cleanup_HW_privdata:
+  cleanup_HW_privdata:
 	kfree(ch->HW_privdata);
 	return -EIO;
 }
@@ -913,13 +936,11 @@ static int MIXCOM_exit(struct net_device
 	struct comx_channel *ch = dev->priv;
 	struct mixcom_privdata *hw = ch->HW_privdata;
 
-	if(hw->channel==0 && TWIN(dev)) {
+    if (hw->channel == 0 && TWIN(dev))
 		return -EBUSY;
-	}
 
-	if(hw->channel==1 && TWIN(dev)) {
-		TWIN(TWIN(dev))=NULL;
-	}
+    if (hw->channel == 1 && TWIN(dev))
+	TWIN(TWIN(dev)) = NULL;
 
 	kfree(ch->HW_privdata);
 	remove_proc_entry(FILENAME_IO, ch->procdir);
@@ -951,12 +972,11 @@ static struct comx_hardware mixcomhw = {
 
 int __init comx_hw_mixcom_init(void)
 {
-	return(comx_register_hardware(&mixcomhw));
+    return (comx_register_hardware(&mixcomhw));
 }
 
 #ifdef MODULE
-void
-cleanup_module(void)
+void cleanup_module(void)
 {
 	comx_unregister_hardware("mixcom");
 }
diff -NurpabB linux-2.4.27/fs/proc/root.c linux-2.4.27-multigate/fs/proc/root.c
--- linux-2.4.27/fs/proc/root.c	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.27-multigate/fs/proc/root.c	2004-08-17 14:34:31.000000000 +0200
@@ -140,6 +140,7 @@ EXPORT_SYMBOL(proc_mknod);
 EXPORT_SYMBOL(proc_mkdir);
 EXPORT_SYMBOL(create_proc_entry);
 EXPORT_SYMBOL(remove_proc_entry);
+EXPORT_SYMBOL(proc_get_inode);
 EXPORT_SYMBOL(proc_root);
 EXPORT_SYMBOL(proc_root_fs);
 EXPORT_SYMBOL(proc_net);
