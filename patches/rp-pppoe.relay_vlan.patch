--- rp-pppoe-3.5.orig/src/relay.h	Mon Jul  8 16:38:24 2002
+++ rp-pppoe-3.5/src/relay.h	Thu Apr 14 17:26:30 2005
@@ -17,6 +17,15 @@
 
 #include "pppoe.h"
 
+#if defined(USE_LINUX_PACKET)
+#define SUPPORT_8021Q_VLAN
+#endif
+
+typedef struct PPPoEPacketStruct8021Q {
+	unsigned char vhdr[4];
+	PPPoEPacket packet;
+} PPPoEPacket8021Q;
+
 /* Description for each active Ethernet interface */
 typedef struct InterfaceStruct {
     char name[IFNAMSIZ+1];	/* Interface name */
@@ -24,6 +33,9 @@
     int sessionSock;		/* Socket for session frames */
     int clientOK;		/* Client requests allowed (PADI, PADR) */
     int acOK;			/* AC replies allowed (PADO, PADS) */
+#ifdef SUPPORT_8021Q_VLAN
+    int dot1q;			/* This interface is a 802.1Q trunk */
+#endif
     unsigned char mac[ETH_ALEN]; /* MAC address */
 } PPPoEInterface;
 
@@ -34,6 +46,9 @@
     struct SessionStruct *prev;	/* Free list link */
     struct SessionHashStruct *acHash; /* Hash bucket for AC MAC/Session */
     struct SessionHashStruct *clientHash; /* Hash bucket for client MAC/Session */
+#ifdef SUPPORT_8021Q_VLAN
+    UINT16_t dot1qTag;		/* 802.1Q Tag on client side if needed */
+#endif
     unsigned int epoch;		/* Epoch when last activity was seen */
     UINT16_t sesNum;		/* Session number assigned by relay */
 } PPPoESession;
@@ -53,6 +68,11 @@
 
 void relayGotSessionPacket(PPPoEInterface const *i);
 void relayGotDiscoveryPacket(PPPoEInterface const *i);
+#ifdef SUPPORT_8021Q_VLAN
+PPPoEPacket* relayUnTag8021QPacket(PPPoEPacket8021Q* packet, int* size, UINT16_t* dot1qTag);
+PPPoEPacket8021Q* relayTag8021QPacket(PPPoEPacket* packet, int* size, UINT16_t dot1qTag);
+void relayGotTrunkPacket(PPPoEInterface const *i);
+#endif
 PPPoEInterface *findInterface(int sock);
 unsigned int hash(unsigned char const *mac, UINT16_t sesNum);
 SessionHash *findSession(unsigned char const *mac, UINT16_t sesNum);
@@ -61,9 +81,10 @@
 			    PPPoEInterface const *cli,
 			    unsigned char const *acMac,
 			    unsigned char const *cliMac,
-			    UINT16_t acSes);
+			    UINT16_t acSes,
+			    UINT16_t dot1qTag);
 void freeSession(PPPoESession *ses, char const *msg);
-void addInterface(char const *ifname, int clientOK, int acOK);
+void addInterface(char const *ifname, int clientOK, int acOK, int dot1q);
 void usage(char const *progname);
 void initRelay(int nsess);
 void relayLoop(void);
@@ -71,9 +92,9 @@
 void unhash(SessionHash *sh);
 
 void relayHandlePADT(PPPoEInterface const *iface, PPPoEPacket *packet, int size);
-void relayHandlePADI(PPPoEInterface const *iface, PPPoEPacket *packet, int size);
+void relayHandlePADI(PPPoEInterface const *iface, PPPoEPacket *packet, int size, UINT16_t dot1qTag);
 void relayHandlePADO(PPPoEInterface const *iface, PPPoEPacket *packet, int size);
-void relayHandlePADR(PPPoEInterface const *iface, PPPoEPacket *packet, int size);
+void relayHandlePADR(PPPoEInterface const *iface, PPPoEPacket *packet, int size, UINT16_t dot1qTag);
 void relayHandlePADS(PPPoEInterface const *iface, PPPoEPacket *packet, int size);
 
 int addTag(PPPoEPacket *packet, PPPoETag const *tag);
@@ -86,7 +107,8 @@
 		    PPPoEInterface const *iface,
 		    unsigned char const *mac,
 		    PPPoETag const *hostUniq,
-		    char const *errMsg);
+		    char const *errMsg,
+		    UINT16_t dot1qTag);
 
 void alarmHandler(int sig);
 void cleanSessions(void);
--- rp-pppoe-3.5.orig/src/relay.c	Mon Jul  8 16:38:24 2002
+++ rp-pppoe-3.5/src/relay.c	Thu Apr 14 17:32:21 2005
@@ -47,7 +47,17 @@
 #include <unistd.h>
 #endif
 
-
+#ifdef SUPPORT_8021Q_VLAN
+/* This is stolen from /usr/include/linux/if_vlan.h */
+#define VLAN_HLEN	4
+struct vlan_ethhdr {
+   unsigned char	h_dest[ETH_ALEN];	   /* destination eth addr	*/
+   unsigned char	h_source[ETH_ALEN];	   /* source ether addr	*/
+   unsigned short       h_vlan_proto;              /* Should always be 0x8100 */
+   unsigned short       h_vlan_TCI;                /* Encapsulates priority and VLAN ID */
+   unsigned short	h_vlan_encapsulated_proto; /* packet type ID field (or len) */
+};
+#endif
 /* Interfaces (max MAX_INTERFACES) */
 PPPoEInterface Interfaces[MAX_INTERFACES];
 int NumInterfaces;
@@ -203,6 +213,9 @@
     fprintf(stderr, "   -S if_name     -- Specify interface for PPPoE Server\n");
     fprintf(stderr, "   -C if_name     -- Specify interface for PPPoE Client\n");
     fprintf(stderr, "   -B if_name     -- Specify interface for both clients and server\n");
+#ifdef SUPPORT_8021Q_VLAN
+    fprintf(stderr, "   -V if_name     -- Specify interface for PPPoE Clients over 802.1Q vlan trunk\n");
+#endif
     fprintf(stderr, "   -n nsess       -- Maxmimum number of sessions to relay\n");
     fprintf(stderr, "   -i timeout     -- Idle timeout in seconds (0 = no timeout)\n");
     fprintf(stderr, "   -F             -- Do not fork into background\n");
@@ -227,6 +240,7 @@
 * -C ifname           -- Use interface for PPPoE clients
 * -S ifname           -- Use interface for PPPoE servers
 * -B ifname           -- Use interface for both clients and servers
+* -V ifname           -- Use interface for PPPoe clients over 802.1Q trunk
 * -n sessions         -- Maximum of "n" sessions
 ***********************************************************************/
 int
@@ -238,7 +252,11 @@
     int beDaemon = 1;
     openlog("pppoe-relay", LOG_PID, LOG_DAEMON);
 
+#ifdef SUPPORT_8021Q_VLAN
+    while((opt = getopt(argc, argv, "hC:S:B:V:n:i:F")) != -1) {
+#else
     while((opt = getopt(argc, argv, "hC:S:B:n:i:F")) != -1) {
+#endif
 	switch(opt) {
 	case 'h':
 	    usage(argv[0]);
@@ -247,14 +265,19 @@
 	    beDaemon = 0;
 	    break;
 	case 'C':
-	    addInterface(optarg, 1, 0);
+	    addInterface(optarg, 1, 0, 0);
 	    break;
 	case 'S':
-	    addInterface(optarg, 0, 1);
+	    addInterface(optarg, 0, 1, 0);
 	    break;
 	case 'B':
-	    addInterface(optarg, 1, 1);
+	    addInterface(optarg, 1, 1, 0);
 	    break;
+#ifdef SUPPORT_8021Q_VLAN
+	case 'V':
+	    addInterface(optarg, 1, 0, 1);
+	    break;
+#endif
 	case 'i':
 	    if (sscanf(optarg, "%u", &IdleTimeout) != 1) {
 		fprintf(stderr, "Illegal argument to -i: should be -i timeout\n");
@@ -354,6 +377,7 @@
 * ifname -- interface name
 * clientOK -- true if this interface should relay PADI, PADR packets.
 * acOK -- true if this interface should relay PADO, PADS packets.
+* dot1q -- true if this interface handles packets in 802.1Q trunk
 *%RETURNS:
 * Nothing
 *%DESCRIPTION:
@@ -362,7 +386,8 @@
 void
 addInterface(char const *ifname,
 	     int clientOK,
-	     int acOK)
+	     int acOK,
+	     int dot1q)
 {
     PPPoEInterface *i;
     int j;
@@ -382,8 +407,17 @@
     strncpy(i->name, ifname, IFNAMSIZ);
     i->name[IFNAMSIZ] = 0;
 
-    i->discoverySock = openInterface(ifname, Eth_PPPOE_Discovery, i->mac);
-    i->sessionSock   = openInterface(ifname, Eth_PPPOE_Session,   NULL);
+#ifdef SUPPORT_8021Q_VLAN
+    if ( dot1q ) {
+	i->discoverySock = i->sessionSock = openInterface(ifname, ETH_P_8021Q, i->mac);
+    } else {
+#endif
+	i->discoverySock = openInterface(ifname, Eth_PPPOE_Discovery, i->mac);
+	i->sessionSock   = openInterface(ifname, Eth_PPPOE_Session,   NULL);
+#ifdef SUPPORT_8021Q_VLAN
+    }
+    i->dot1q = dot1q;
+#endif
     i->clientOK = clientOK;
     i->acOK = acOK;
 }
@@ -458,6 +492,7 @@
 * acMac -- Access concentrator's MAC address
 * cliMac -- Client's MAC address
 * acSess -- Access concentrator's session ID.
+* dot1qTag -- 802.1Q Tag on client side
 *%RETURNS:
 * PPPoESession structure; NULL if one could not be allocated
 *%DESCRIPTION:
@@ -468,7 +503,8 @@
 	      PPPoEInterface const *cli,
 	      unsigned char const *acMac,
 	      unsigned char const *cliMac,
-	      UINT16_t acSes)
+	      UINT16_t acSes,
+	      UINT16_t dot1qTag)
 {
     PPPoESession *sess;
     SessionHash *acHash, *cliHash;
@@ -504,6 +540,10 @@
     sess->acHash = acHash;
     sess->clientHash = cliHash;
 
+#ifdef SUPPORT_8021Q_VLAN
+    sess->dot1qTag = dot1qTag;
+#endif
+
     acHash->interface = ac;
     cliHash->interface = cli;
 
@@ -774,18 +814,35 @@
 
 	/* Handle session packets first */
 	for (i=0; i<NumInterfaces; i++) {
+#ifdef SUPPORT_8021Q_VLAN
+	    if (!Interfaces[i].dot1q && FD_ISSET(Interfaces[i].sessionSock, &readableCopy)) {
+#else
 	    if (FD_ISSET(Interfaces[i].sessionSock, &readableCopy)) {
+#endif
 		relayGotSessionPacket(&Interfaces[i]);
 	    }
 	}
 
 	/* Now handle discovery packets */
 	for (i=0; i<NumInterfaces; i++) {
+#ifdef SUPPORT_8021Q_VLAN
+	    if (!Interfaces[i].dot1q && FD_ISSET(Interfaces[i].discoverySock, &readableCopy)) {
+#else
 	    if (FD_ISSET(Interfaces[i].discoverySock, &readableCopy)) {
+#endif
 		relayGotDiscoveryPacket(&Interfaces[i]);
 	    }
 	}
 
+#ifdef SUPPORT_8021Q_VLAN
+	/* At last, handle 802.1Q trunk packets */
+	for (i=0; i<NumInterfaces; i++) {
+	    if (Interfaces[i].dot1q && FD_ISSET(Interfaces[i].discoverySock, &readableCopy)) {
+		relayGotTrunkPacket(&Interfaces[i]);
+	    }
+	}
+#endif
+
 	/* Handle the session-cleaning process */
 	if (FD_ISSET(CleanPipe[0], &readableCopy)) {
 	    char dummy;
@@ -808,48 +865,49 @@
 void
 relayGotDiscoveryPacket(PPPoEInterface const *iface)
 {
-    PPPoEPacket packet;
+    PPPoEPacket8021Q packet8021q;
+    PPPoEPacket* packet = &packet8021q.packet;
     int size;
 
-    if (receivePacket(iface->discoverySock, &packet, &size) < 0) {
+    if (receivePacket(iface->discoverySock, packet, &size) < 0) {
 	return;
     }
     /* Ignore unknown code/version */
-    if (packet.ver != 1 || packet.type != 1) {
+    if (packet->ver != 1 || packet->type != 1) {
 	return;
     }
 
     /* Validate length */
-    if (ntohs(packet.length) + HDR_SIZE > size) {
+    if (ntohs(packet->length) + HDR_SIZE > size) {
 	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
-	       (unsigned int) ntohs(packet.length));
+	       (unsigned int) ntohs(packet->length));
 	return;
     }
 
     /* Drop Ethernet frame padding */
-    if (size > ntohs(packet.length) + HDR_SIZE) {
-	size = ntohs(packet.length) + HDR_SIZE;
+    if (size > ntohs(packet->length) + HDR_SIZE) {
+	size = ntohs(packet->length) + HDR_SIZE;
     }
 
-    switch(packet.code) {
+    switch(packet->code) {
     case CODE_PADT:
-	relayHandlePADT(iface, &packet, size);
+	relayHandlePADT(iface, packet, size);
 	break;
     case CODE_PADI:
-	relayHandlePADI(iface, &packet, size);
+	relayHandlePADI(iface, packet, size, 0);
 	break;
     case CODE_PADO:
-	relayHandlePADO(iface, &packet, size);
+	relayHandlePADO(iface, packet, size);
 	break;
     case CODE_PADR:
-	relayHandlePADR(iface, &packet, size);
+	relayHandlePADR(iface, packet, size, 0);
 	break;
     case CODE_PADS:
-	relayHandlePADS(iface, &packet, size);
+	relayHandlePADS(iface, packet, size);
 	break;
     default:
 	syslog(LOG_ERR, "Discovery packet on %s with unknown code %d",
-	       iface->name, (int) packet.code);
+	       iface->name, (int) packet->code);
     }
 }
 
@@ -865,45 +923,46 @@
 void
 relayGotSessionPacket(PPPoEInterface const *iface)
 {
-    PPPoEPacket packet;
+    PPPoEPacket8021Q packet8021q;
+    PPPoEPacket* packet=&packet8021q.packet;
     int size;
     SessionHash *sh;
     PPPoESession *ses;
 
-    if (receivePacket(iface->sessionSock, &packet, &size) < 0) {
+    if (receivePacket(iface->sessionSock, packet, &size) < 0) {
 	return;
     }
 
     /* Ignore unknown code/version */
-    if (packet.ver != 1 || packet.type != 1) {
+    if (packet->ver != 1 || packet->type != 1) {
 	return;
     }
 
     /* Must be a session packet */
-    if (packet.code != CODE_SESS) {
-	syslog(LOG_ERR, "Session packet with code %d", (int) packet.code);
+    if (packet->code != CODE_SESS) {
+	syslog(LOG_ERR, "Session packet with code %d", (int) packet->code);
 	return;
     }
 
     /* Ignore session packets whose destination address isn't ours */
-    if (memcmp(packet.ethHdr.h_dest, iface->mac, ETH_ALEN)) {
+    if (memcmp(packet->ethHdr.h_dest, iface->mac, ETH_ALEN)) {
 	return;
     }
 
     /* Validate length */
-    if (ntohs(packet.length) + HDR_SIZE > size) {
+    if (ntohs(packet->length) + HDR_SIZE > size) {
 	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
-	       (unsigned int) ntohs(packet.length));
+	       (unsigned int) ntohs(packet->length));
 	return;
     }
 
     /* Drop Ethernet frame padding */
-    if (size > ntohs(packet.length) + HDR_SIZE) {
-	size = ntohs(packet.length) + HDR_SIZE;
+    if (size > ntohs(packet->length) + HDR_SIZE) {
+	size = ntohs(packet->length) + HDR_SIZE;
     }
 
     /* We're in business!  Find the hash */
-    sh = findSession(packet.ethHdr.h_source, packet.session);
+    sh = findSession(packet->ethHdr.h_source, packet->session);
     if (!sh) {
 	/* Don't log this.  Someone could be running the client and the
 	   relay on the same box. */
@@ -914,9 +973,9 @@
     ses = sh->ses;
     ses->epoch = Epoch;
     sh = sh->peer;
-    packet.session = sh->sesNum;
-    memcpy(packet.ethHdr.h_source, sh->interface->mac, ETH_ALEN);
-    memcpy(packet.ethHdr.h_dest, sh->peerMac, ETH_ALEN);
+    packet->session = sh->sesNum;
+    memcpy(packet->ethHdr.h_source, sh->interface->mac, ETH_ALEN);
+    memcpy(packet->ethHdr.h_dest, sh->peerMac, ETH_ALEN);
 #if 0
     fprintf(stderr, "Relaying %02x:%02x:%02x:%02x:%02x:%02x(%s:%d) to %02x:%02x:%02x:%02x:%02x:%02x(%s:%d)\n",
 	    sh->peer->peerMac[0], sh->peer->peerMac[1], sh->peer->peerMac[2],
@@ -926,9 +985,182 @@
 	    sh->peerMac[3], sh->peerMac[4], sh->peerMac[5],
 	    sh->interface->name, ntohs(sh->sesNum));
 #endif
-    sendPacket(NULL, sh->interface->sessionSock, &packet, size);
+#ifdef SUPPORT_8021Q_VLAN
+    if ( sh->interface->dot1q ) {
+	    packet = (PPPoEPacket*)relayTag8021QPacket(packet, &size, ses->dot1qTag);
+    }
+#endif
+    sendPacket(NULL, sh->interface->sessionSock, packet, size);
 }
 
+#ifdef SUPPORT_8021Q_VLAN
+/**********************************************************************
+*%FUNCTION relayUnTag8021QPacket
+* packet -- the received packet
+* size -- size of the packet
+*%RETURNS:
+* size -- the resulting size
+* dot1qTag -- the tag extracted from packet
+* packet -- the untagged packet
+*%DESCRIPTION
+* Extracts the tag field from a packet, and untags it
+***********************************************************************/
+PPPoEPacket*
+relayUnTag8021QPacket(PPPoEPacket8021Q* packet,
+			int* size,
+			UINT16_t* dot1qTag)
+{
+	struct vlan_ethhdr* vhdr = (struct vlan_ethhdr*)packet;
+
+	if ( vhdr->h_vlan_proto != htons(ETH_P_8021Q) ) {
+		return NULL;
+	}
+	*dot1qTag=htons(vhdr->h_vlan_TCI) & 0xfff;
+	memmove(&packet->packet,vhdr,2 * ETH_ALEN);
+	*size -= VLAN_HLEN;
+	return &packet->packet;
+}
+#endif
+
+#ifdef SUPPORT_8021Q_VLAN
+/**********************************************************************
+*%FUNCTION relayTag8021QPacket
+* packet -- the pppoe packet to be sent
+* size -- size of the packet
+* dot1qTag -- the tag to be included in the packet
+*%RETURNS:
+* ret -- the resulting size
+*%DESCRIPTION
+* Extracts the tag field from a packet, and untags it
+***********************************************************************/
+PPPoEPacket8021Q*
+relayTag8021QPacket(PPPoEPacket* packet,
+			int* size,
+			UINT16_t dot1qTag)
+{
+	struct vlan_ethhdr* vhdr = (struct vlan_ethhdr*)((char*)packet - VLAN_HLEN);
+
+	memmove(vhdr,packet,2 * ETH_ALEN);
+	vhdr->h_vlan_proto = htons(ETH_P_8021Q);
+	vhdr->h_vlan_TCI = htons(dot1qTag & 0xfff);
+
+	*size += VLAN_HLEN;
+	return (PPPoEPacket8021Q*)vhdr;
+}
+#endif
+
+#ifdef SUPPORT_8021Q_VLAN
+/**********************************************************************
+*%FUNCTION: relayGotTrunkPacket
+*%ARGUMENTS:
+* iface -- interface on which packet is waiting
+*%RETURNS:
+* Nothing
+*%DESCRIPTION:
+* Receives and processes a discovery packet.
+***********************************************************************/
+void
+relayGotTrunkPacket(PPPoEInterface const *iface)
+{
+    PPPoEPacket8021Q packet8021q;
+    PPPoEPacket *packet;
+    int size;
+    UINT16_t dot1qTag;
+    SessionHash *sh;
+    PPPoESession *ses;
+
+    if ( (size=recv(iface->discoverySock, &packet8021q, sizeof(packet8021q), 0)) < sizeof(struct vlan_ethhdr) ) {
+	    sysErr("recv (relayGotTrunkPacket)");
+	    return;
+    }
+    if ( (packet=relayUnTag8021QPacket(&packet8021q, &size, &dot1qTag)) == NULL ) {
+	    sysErr("recv (relayGotTrunkPacket)");
+	    return;
+    }
+    if ( packet->ethHdr.h_proto != htons(Eth_PPPOE_Discovery) &&
+	 packet->ethHdr.h_proto != htons(Eth_PPPOE_Session) ) {
+	    return;
+    }
+
+    /* Ignore unknown code/version */
+    if (packet->ver != 1 || packet->type != 1) {
+	return;
+    }
+
+    /* Validate length */
+    if (ntohs(packet->length) + HDR_SIZE > size) {
+	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
+	       (unsigned int) ntohs(packet->length));
+	return;
+    }
+
+    /* Drop Ethernet frame padding */
+    if (size > ntohs(packet->length) + HDR_SIZE) {
+	size = ntohs(packet->length) + HDR_SIZE;
+    }
+
+    if ( packet->ethHdr.h_proto == htons(Eth_PPPOE_Discovery) ) {
+	    switch(packet->code) {
+	    case CODE_PADT:
+		relayHandlePADT(iface, packet, size);
+		break;
+	    case CODE_PADI:
+		relayHandlePADI(iface, packet, size, dot1qTag);
+		break;
+	    case CODE_PADO:
+		relayHandlePADO(iface, packet, size);
+		break;
+	    case CODE_PADR:
+		relayHandlePADR(iface, packet, size, dot1qTag);
+		break;
+	    case CODE_PADS:
+		relayHandlePADS(iface, packet, size);
+		break;
+	    default:
+		syslog(LOG_ERR, "Discovery packet on %s with unknown code %d",
+		       iface->name, (int) packet->code);
+	    }
+    } else {
+	    /* Must be a session packet */
+	    if (packet->code != CODE_SESS) {
+		syslog(LOG_ERR, "Session packet with code %d", (int) packet->code);
+		return;
+	    }
+
+	    /* Ignore session packets whose destination address isn't ours */
+	    if (memcmp(packet->ethHdr.h_dest, iface->mac, ETH_ALEN)) {
+		return;
+	    }
+
+	    /* We're in business!  Find the hash */
+	    sh = findSession(packet->ethHdr.h_source, packet->session);
+	    if (!sh) {
+		/* Don't log this.  Someone could be running the client and the
+		   relay on the same box. */
+		return;
+	    }
+
+	    /* Relay it */
+	    ses = sh->ses;
+	    ses->epoch = Epoch;
+	    sh = sh->peer;
+	    packet->session = sh->sesNum;
+	    memcpy(packet->ethHdr.h_source, sh->interface->mac, ETH_ALEN);
+	    memcpy(packet->ethHdr.h_dest, sh->peerMac, ETH_ALEN);
+#if 0
+	    fprintf(stderr, "Relaying %02x:%02x:%02x:%02x:%02x:%02x(%s:%d) to %02x:%02x:%02x:%02x:%02x:%02x(%s:%d)\n",
+		    sh->peer->peerMac[0], sh->peer->peerMac[1], sh->peer->peerMac[2],
+		    sh->peer->peerMac[3], sh->peer->peerMac[4], sh->peer->peerMac[5],
+		    sh->peer->interface->name, ntohs(sh->peer->sesNum),
+		    sh->peerMac[0], sh->peerMac[1], sh->peerMac[2],
+		    sh->peerMac[3], sh->peerMac[4], sh->peerMac[5],
+		    sh->interface->name, ntohs(sh->sesNum));
+#endif
+	    sendPacket(NULL, sh->interface->sessionSock, packet, size);
+    }
+}
+#endif
+
 /**********************************************************************
 *%FUNCTION: relayHandlePADT
 *%ARGUMENTS:
@@ -957,6 +1189,11 @@
     packet->session = sh->sesNum;
     memcpy(packet->ethHdr.h_source, sh->interface->mac, ETH_ALEN);
     memcpy(packet->ethHdr.h_dest, sh->peerMac, ETH_ALEN);
+#ifdef SUPPORT_8021Q_VLAN
+    if ( sh->interface->dot1q ) {
+	    packet = (PPPoEPacket*)relayTag8021QPacket(packet, &size, ses->dot1qTag);
+    }
+#endif
     sendPacket(NULL, sh->interface->sessionSock, packet, size);
 
     /* Destroy the session */
@@ -968,6 +1205,7 @@
 *%ARGUMENTS:
 * iface -- interface on which packet was received
 * packet -- the PADI packet
+* dot1qTag -- the 802.1Q tag associated with packet
 *%RETURNS:
 * Nothing
 *%DESCRIPTION:
@@ -976,7 +1214,8 @@
 void
 relayHandlePADI(PPPoEInterface const *iface,
 		PPPoEPacket *packet,
-		int size)
+		int size,
+		UINT16_t dot1qTag)
 {
     PPPoETag tag;
     unsigned char *loc;
@@ -1035,6 +1274,13 @@
 	tag.length = htons(MY_RELAY_TAG_LEN);
 	memcpy(tag.payload, &ifIndex, sizeof(ifIndex));
 	memcpy(tag.payload+sizeof(ifIndex), packet->ethHdr.h_source, ETH_ALEN);
+#ifdef SUPPORT_8021Q_VLAN
+	/* only allow 802.1Q vlan IDs above 1 */
+	if ( (dot1qTag & 0xfff) > 1 ) {
+		memcpy(tag.payload+sizeof(ifIndex)+ETH_ALEN,&dot1qTag,sizeof(UINT16_t));
+		tag.length = htons(htons(tag.length) + sizeof(UINT16_t));
+	}
+#endif
 	/* Add a relay tag if there's room */
 	r = addTag(packet, &tag);
 	if (r < 0) return;
@@ -1076,6 +1322,9 @@
     unsigned char *loc;
     int ifIndex;
     int acIndex;
+#ifdef SUPPORT_8021Q_VLAN
+    UINT16_t dot1qTag;
+#endif
 
     /* Can a server legally be behind this interface? */
     if (!iface->acOK) {
@@ -1128,7 +1377,11 @@
     }
 
     /* If it's the wrong length, ignore it */
-    if (ntohs(tag.length) != MY_RELAY_TAG_LEN) {
+    if (ntohs(tag.length) != MY_RELAY_TAG_LEN
+#ifdef SUPPORT_8021Q_VLAN
+	&& ntohs(tag.length) != (MY_RELAY_TAG_LEN + sizeof(UINT16_t))
+#endif
+	) {
 	syslog(LOG_ERR,
 	       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have correct length Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
@@ -1159,6 +1412,24 @@
 	return;
     }
 
+#ifdef SUPPORT_8021Q_VLAN
+    if ( Interfaces[ifIndex].dot1q ) {
+	if (ntohs(tag.length) != (MY_RELAY_TAG_LEN + sizeof(UINT16_t))) {
+		syslog(LOG_ERR,
+		       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s has no VLAN ID in Relay-Session-Id tag",
+		       packet->ethHdr.h_source[0],
+		       packet->ethHdr.h_source[1],
+		       packet->ethHdr.h_source[2],
+		       packet->ethHdr.h_source[3],
+		       packet->ethHdr.h_source[4],
+		       packet->ethHdr.h_source[5],
+		       iface->name);
+		return;
+	}
+	memcpy(&dot1qTag,tag.payload + sizeof(ifIndex) + ETH_ALEN,sizeof(UINT16_t));
+	dot1qTag &= 0xfff;
+    }
+#endif
     /* Replace Relay-ID tag with opposite-direction tag */
     memcpy(loc+TAG_HDR_SIZE, &acIndex, sizeof(acIndex));
     memcpy(loc+TAG_HDR_SIZE+sizeof(ifIndex), packet->ethHdr.h_source, ETH_ALEN);
@@ -1170,6 +1441,11 @@
     memcpy(packet->ethHdr.h_source, Interfaces[ifIndex].mac, ETH_ALEN);
 
     /* Send the PADO to the proper client */
+#ifdef SUPPORT_8021Q_VLAN
+    if ( Interfaces[ifIndex].dot1q ) {
+	    packet = (PPPoEPacket*)relayTag8021QPacket(packet, &size, dot1qTag);
+    }
+#endif
     sendPacket(NULL, Interfaces[ifIndex].discoverySock, packet, size);
 }
 
@@ -1178,6 +1454,7 @@
 *%ARGUMENTS:
 * iface -- interface on which packet was received
 * packet -- the PADR packet
+* dot1qTag -- the 802.1Q tag associated with packet
 *%RETURNS:
 * Nothing
 *%DESCRIPTION:
@@ -1186,7 +1463,8 @@
 void
 relayHandlePADR(PPPoEInterface const *iface,
 		PPPoEPacket *packet,
-		int size)
+		int size,
+		UINT16_t dot1qTag)
 {
     PPPoETag tag;
     unsigned char *loc;
@@ -1244,7 +1522,11 @@
     }
 
     /* If it's the wrong length, ignore it */
-    if (ntohs(tag.length) != MY_RELAY_TAG_LEN) {
+    if (ntohs(tag.length) != MY_RELAY_TAG_LEN
+#ifdef SUPPORT_8021Q_VLAN
+	&& ntohs(tag.length) != (MY_RELAY_TAG_LEN + sizeof(UINT16_t))
+#endif
+		    ) {
 	syslog(LOG_ERR,
 	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have correct length Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
@@ -1279,6 +1561,8 @@
     memcpy(loc+TAG_HDR_SIZE, &cliIndex, sizeof(cliIndex));
     memcpy(loc+TAG_HDR_SIZE+sizeof(ifIndex), packet->ethHdr.h_source, ETH_ALEN);
 
+    /* We dont touch 802.1Q Vlan IDs here */
+
     /* Set destination address to MAC address in relay ID */
     memcpy(packet->ethHdr.h_dest, tag.payload + sizeof(ifIndex), ETH_ALEN);
 
@@ -1310,6 +1594,7 @@
     int acIndex;
     PPPoESession *ses = NULL;
     SessionHash *sh;
+    UINT16_t dot1qTag = 0;
 
     /* Can a server legally be behind this interface? */
     if (!iface->acOK) {
@@ -1362,7 +1647,11 @@
     }
 
     /* If it's the wrong length, ignore it */
-    if (ntohs(tag.length) != MY_RELAY_TAG_LEN) {
+    if (ntohs(tag.length) != MY_RELAY_TAG_LEN
+#ifdef SUPPORT_8021Q_VLAN
+	&& ntohs(tag.length) != (MY_RELAY_TAG_LEN + sizeof(UINT16_t))
+#endif
+	) {
 	syslog(LOG_ERR,
 	       "PADS packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have correct length Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
@@ -1393,6 +1682,25 @@
 	return;
     }
 
+#ifdef SUPPORT_8021Q_VLAN
+    if ( Interfaces[ifIndex].dot1q ) {
+	if (ntohs(tag.length) != (MY_RELAY_TAG_LEN + sizeof(UINT16_t))) {
+		syslog(LOG_ERR,
+		       "PADS packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s has no VLAN ID in Relay-Session-Id tag",
+		       packet->ethHdr.h_source[0],
+		       packet->ethHdr.h_source[1],
+		       packet->ethHdr.h_source[2],
+		       packet->ethHdr.h_source[3],
+		       packet->ethHdr.h_source[4],
+		       packet->ethHdr.h_source[5],
+		       iface->name);
+		return;
+	}
+	memcpy(&dot1qTag,tag.payload + sizeof(ifIndex) + ETH_ALEN,sizeof(UINT16_t));
+	dot1qTag &= 0xfff;
+    }
+#endif
+
     /* If session ID is zero, it's the AC respoding with an error.
        Just relay it; do not create a session */
     if (packet->session != htons(0)) {
@@ -1410,7 +1718,8 @@
 	    /* Create a new session */
 	    ses = createSession(iface, &Interfaces[ifIndex],
 				packet->ethHdr.h_source,
-				loc + TAG_HDR_SIZE + sizeof(ifIndex), packet->session);
+				loc + TAG_HDR_SIZE + sizeof(ifIndex), packet->session,
+				dot1qTag);
 	    if (!ses) {
 		/* Can't allocate session -- send error PADS to client and
 		   PADT to server */
@@ -1422,10 +1731,10 @@
 		}
 		relaySendError(CODE_PADS, htons(0), &Interfaces[ifIndex],
 			       loc + TAG_HDR_SIZE + sizeof(ifIndex),
-			       hu, "RP-PPPoE: Relay: Unable to allocate session");
+			       hu, "RP-PPPoE: Relay: Unable to allocate session", dot1qTag);
 		relaySendError(CODE_PADT, packet->session, iface,
 			       packet->ethHdr.h_source, NULL,
-			       "RP-PPPoE: Relay: Unable to allocate session");
+			       "RP-PPPoE: Relay: Unable to allocate session", 0);
 		return;
 	    }
 	}
@@ -1444,6 +1753,11 @@
     memcpy(packet->ethHdr.h_source, Interfaces[ifIndex].mac, ETH_ALEN);
 
     /* Send the PADS to the proper client */
+#ifdef SUPPORT_8021Q_VLAN
+    if ( Interfaces[ifIndex].dot1q ) {
+	    packet = (PPPoEPacket*)relayTag8021QPacket(packet, &size, dot1qTag);
+    }
+#endif
     sendPacket(NULL, Interfaces[ifIndex].discoverySock, packet, size);
 }
 
@@ -1456,6 +1770,7 @@
 * mac -- Ethernet address to which frame should be sent
 * hostUniq -- if non-NULL, a hostUniq tag to add to error frame
 * errMsg -- error message to insert into Generic-Error tag.
+* dot1qTag -- 802.1Q Vlan ID to use when sending errors
 *%RETURNS:
 * Nothing
 *%DESCRIPTION:
@@ -1468,32 +1783,40 @@
 	       PPPoEInterface const *iface,
 	       unsigned char const *mac,
 	       PPPoETag const *hostUniq,
-	       char const *errMsg)
+	       char const *errMsg,
+	       UINT16_t dot1qTag)
 {
-    PPPoEPacket packet;
+    PPPoEPacket8021Q packet8021q;
+    PPPoEPacket* packet=&packet8021q.packet;
     PPPoETag errTag;
     int size;
 
-    memcpy(packet.ethHdr.h_source, iface->mac, ETH_ALEN);
-    memcpy(packet.ethHdr.h_dest, mac, ETH_ALEN);
-    packet.ethHdr.h_proto = htons(Eth_PPPOE_Discovery);
-    packet.type = 1;
-    packet.ver = 1;
-    packet.code = code;
-    packet.session = session;
-    packet.length = htons(0);
+    memcpy(packet->ethHdr.h_source, iface->mac, ETH_ALEN);
+    memcpy(packet->ethHdr.h_dest, mac, ETH_ALEN);
+    packet->ethHdr.h_proto = htons(Eth_PPPOE_Discovery);
+    packet->type = 1;
+    packet->ver = 1;
+    packet->code = code;
+    packet->session = session;
+    packet->length = htons(0);
     if (hostUniq) {
-	if (addTag(&packet, hostUniq) < 0) return;
+	if (addTag(packet, hostUniq) < 0) return;
     }
     errTag.type = htons(TAG_GENERIC_ERROR);
     errTag.length = htons(strlen(errMsg));
     strcpy(errTag.payload, errMsg);
-    if (addTag(&packet, &errTag) < 0) return;
-    size = ntohs(packet.length) + HDR_SIZE;
+    if (addTag(packet, &errTag) < 0) return;
+    size = ntohs(packet->length) + HDR_SIZE;
+
+#ifdef SUPPORT_8021Q_VLAN
+    if ( iface->dot1q ) {
+	    packet = (PPPoEPacket*)relayTag8021QPacket(packet, &size, dot1qTag);
+    }
+#endif
     if (code == CODE_PADT) {
-	sendPacket(NULL, iface->discoverySock, &packet, size);
+	sendPacket(NULL, iface->discoverySock, packet, size);
     } else {
-	sendPacket(NULL, iface->sessionSock, &packet, size);
+	sendPacket(NULL, iface->sessionSock, packet, size);
     }
 }
 
@@ -1539,11 +1862,23 @@
 	    relaySendError(CODE_PADT, cur->acHash->sesNum,
 			   cur->acHash->interface,
 			   cur->acHash->peerMac, NULL,
-			   "RP-PPPoE: Relay: Session exceeded idle timeout");
+			   "RP-PPPoE: Relay: Session exceeded idle timeout",
+#ifdef SUPPORT_8021Q_VLAN
+			   cur->dot1qTag
+#else
+			   0
+#endif
+			   );
 	    relaySendError(CODE_PADT, cur->clientHash->sesNum,
 			   cur->clientHash->interface,
 			   cur->clientHash->peerMac, NULL,
-			   "RP-PPPoE: Relay: Session exceeded idle timeout");
+			   "RP-PPPoE: Relay: Session exceeded idle timeout",
+#ifdef SUPPORT_8021Q_VLAN
+			   cur->dot1qTag
+#else
+			   0
+#endif
+			  );
 	    freeSession(cur, "Idle Timeout");
 	}
 	cur = next;
