diff -ruNP linux-2.6.18.orig/include/linux/skbuff.h linux-2.6.18/include/linux/skbuff.h
--- linux-2.6.18.orig/include/linux/skbuff.h	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/include/linux/skbuff.h	2006-11-06 21:23:47.000000000 +0100
@@ -30,6 +30,10 @@
 #include <net/checksum.h>
 #include <linux/dmaengine.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef_struct.h>
+#endif
+
 #define HAVE_ALLOC_SKB		/* For the drivers to know */
 #define HAVE_ALIGNABLE_SKB	/* Ditto 8)		   */
 
@@ -261,6 +265,9 @@
 
 	struct  dst_entry	*dst;
 	struct	sec_path	*sp;
+#ifdef CONFIG_IP_LEF
+	struct  lef		lef;
+#endif
 
 	/*
 	 * This is the control buffer. It is free to use for every
diff -ruNP linux-2.6.18.orig/include/net/lef.h linux-2.6.18/include/net/lef.h
--- linux-2.6.18.orig/include/net/lef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.18/include/net/lef.h	2006-11-06 21:48:26.000000000 +0100
@@ -0,0 +1,64 @@
+/*
+ * Linux express forwarding code
+ *
+ * Mainly developed by krichy < krichy at cflinux dot hu >
+ *
+ * Currently it is under development, so do not expect much from it,
+ * or not anything else than a kernel panic. :)
+ *
+ * The code is subject to GPLv2 or any later one.
+ */
+
+#ifndef _NET_LEF_H
+#define _NET_LEF_H
+
+#include <asm/types.h>
+#include <asm/processor.h>
+#include <net/neighbour.h>
+#include <linux/netdevice.h>
+#include <net/neighbour.h>
+#include <net/lef_struct.h>
+
+// some trivial lef-related functions
+
+/* lef_init
+ * is called when initialising a lef structure
+ * it just zeros all elements of it
+ * @l: struct lef
+ */
+static inline void		lef_init(struct lef* l)
+{
+	memset(l, 0, sizeof(*l));
+}
+
+/* lef_init_copy
+ * inits a lef from another one (actually copying old contents
+ * and allocating references
+ * @l: new lef
+ * @o: old lef
+ */
+static inline void		lef_init_copy(struct lef* l, const struct lef* o)
+{
+	l->gateway = o->gateway;
+	if ((l->dev = o->dev))
+		dev_hold(l->dev);
+	l->mtu = o->mtu;
+	if ((l->neighbour = o->neighbour))
+		neigh_hold(l->neighbour);
+}
+
+/* lef_destroy
+ * destroys (frees) elements of a lef
+ * @l: struct lef
+ */
+static inline void		lef_destroy(struct lef* l)
+{
+	if (likely(l->neighbour))
+		neigh_release(l->neighbour);
+	if (likely(l->dev))
+		dev_put(l->dev);
+}
+
+extern int			lef_forward(struct sk_buff *);
+
+#endif /* _NET_LEF_H */
diff -ruNP linux-2.6.18.orig/include/net/lef_struct.h linux-2.6.18/include/net/lef_struct.h
--- linux-2.6.18.orig/include/net/lef_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.18/include/net/lef_struct.h	2006-11-06 21:23:37.000000000 +0100
@@ -0,0 +1,27 @@
+/*
+ * Linux express forwarding code
+ *
+ * Mainly developed by krichy < krichy at cflinux dot hu >
+ *
+ * Currently it is under development, so do not expect much from it,
+ * or not anything else than a kernel panic. :)
+ *
+ * The code is subject to GPLv2 or any later one.
+ */
+
+#ifndef _NET_LEF_STRUCT_H
+#define _NET_LEF_STRUCT_H
+
+// forward declarations
+struct net_device;
+struct neighbour;
+
+// our express forwarding structure
+struct lef {
+	__u32			gateway;	// our gateway
+	struct net_device	*dev;		// our device
+	u32			mtu;		// our mtu
+	struct neighbour	*neighbour;	// our neigbour
+};
+
+#endif /* _NET_LEF_STRUCT_H */
diff -ruNP linux-2.6.18.orig/net/core/skbuff.c linux-2.6.18/net/core/skbuff.c
--- linux-2.6.18.orig/net/core/skbuff.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/core/skbuff.c	2006-11-06 21:46:11.000000000 +0100
@@ -67,6 +67,10 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 static kmem_cache_t *skbuff_head_cache __read_mostly;
 static kmem_cache_t *skbuff_fclone_cache __read_mostly;
 
@@ -369,6 +373,9 @@
 #ifdef CONFIG_XFRM
 	secpath_put(skb->sp);
 #endif
+#ifdef CONFIG_IP_LEF
+	lef_destroy(&skb->lef);
+#endif
 	if (skb->destructor) {
 		WARN_ON(in_irq());
 		skb->destructor(skb);
@@ -457,6 +464,9 @@
 #ifdef CONFIG_INET
 	secpath_get(skb->sp);
 #endif
+#ifdef CONFIG_IP_LEF
+	lef_init_copy(&n->lef, &skb->lef);
+#endif
 	memcpy(n->cb, skb->cb, sizeof(skb->cb));
 	C(len);
 	C(data_len);
@@ -524,6 +534,9 @@
 #ifdef CONFIG_INET
 	new->sp		= secpath_get(old->sp);
 #endif
+#ifdef CONFIG_IP_LEF
+	lef_init_copy(&new->lef, &old->lef);
+#endif
 	new->h.raw	= old->h.raw + offset;
 	new->nh.raw	= old->nh.raw + offset;
 	new->mac.raw	= old->mac.raw + offset;
@@ -1974,6 +1987,9 @@
 		nskb->priority = skb->priority;
 		nskb->protocol = skb->protocol;
 		nskb->dst = dst_clone(skb->dst);
+#ifdef CONFIG_IP_LEF
+		lef_init_copy(&nskb->lef, &skb->lef);
+#endif
 		memcpy(nskb->cb, skb->cb, sizeof(skb->cb));
 		nskb->pkt_type = skb->pkt_type;
 		nskb->mac_len = skb->mac_len;
diff -ruNP linux-2.6.18.orig/net/ipv4/arp.c linux-2.6.18/net/ipv4/arp.c
--- linux-2.6.18.orig/net/ipv4/arp.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/arp.c	2006-11-06 20:15:27.000000000 +0100
@@ -127,6 +127,10 @@
 
 #include <linux/netfilter_arp.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 /*
  *	Interface to generic neighbour cache.
  */
@@ -526,6 +530,31 @@
 	return 0;
 }
 
+#ifdef CONFIG_IP_LEF
+int arp_bind_neighbour_lef(struct lef *lef)
+{
+	struct net_device *dev = lef->dev;
+	struct neighbour *n = lef->neighbour;
+
+	if (dev == NULL)
+		return -EINVAL;
+	if (n == NULL) {
+		u32 nexthop = lef->gateway;
+		if (dev->flags&(IFF_LOOPBACK|IFF_POINTOPOINT))
+			nexthop = 0;
+		n = __neigh_lookup_errno(
+#if defined(CONFIG_ATM_CLIP) || defined(CONFIG_ATM_CLIP_MODULE)
+		    dev->type == ARPHRD_ATM ? clip_tbl_hook :
+#endif
+		    &arp_tbl, &nexthop, dev);
+		if (IS_ERR(n))
+			return PTR_ERR(n);
+		lef->neighbour = n;
+	}
+	return 0;
+}
+#endif
+
 /*
  * Check if we can use proxy ARP for this path
  */
diff -ruNP linux-2.6.18.orig/net/ipv4/Kconfig linux-2.6.18/net/ipv4/Kconfig
--- linux-2.6.18.orig/net/ipv4/Kconfig	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/Kconfig	2006-11-06 23:03:04.000000000 +0100
@@ -51,6 +51,12 @@
 
 	  If unsure, say N here.
 
+config IP_LEF
+	bool "IP: Linux express forwarding"
+	depends on IP_ADVANCED_ROUTER
+	---help---
+	You should not turn this on
+
 choice 
 	prompt "Choose IP: FIB lookup algorithm (choose FIB_HASH if unsure)"
 	depends on IP_ADVANCED_ROUTER
@@ -87,7 +99,7 @@
 
 config IP_MULTIPLE_TABLES
 	bool "IP: policy routing"
-	depends on IP_ADVANCED_ROUTER
+	depends on IP_ADVANCED_ROUTER && !IP_LEF
 	---help---
 	  Normally, a router decides what to do with a received packet based
 	  solely on the packet's final destination address. If you say Y here,
@@ -105,7 +117,7 @@
 
 config IP_ROUTE_FWMARK
 	bool "IP: use netfilter MARK value as routing key"
-	depends on IP_MULTIPLE_TABLES && NETFILTER
+	depends on IP_MULTIPLE_TABLES && NETFILTER && !IP_LEF
 	help
 	  If you say Y here, you will be able to specify different routes for
 	  packets with different mark values (see iptables(8), MARK target).
@@ -124,7 +136,7 @@
 
 config IP_ROUTE_MULTIPATH_CACHED
 	bool "IP: equal cost multipath with caching support (EXPERIMENTAL)"
-	depends on IP_ROUTE_MULTIPATH
+	depends on IP_ROUTE_MULTIPATH && !IP_LEF
 	help
 	  Normally, equal cost multipath routing is not supported by the
 	  routing cache. If you say Y here, alternative routes are cached
diff -ruNP linux-2.6.18.orig/net/ipv4/Makefile linux-2.6.18/net/ipv4/Makefile
--- linux-2.6.18.orig/net/ipv4/Makefile	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/Makefile	2006-11-06 21:08:04.000000000 +0100
@@ -47,6 +47,7 @@
 obj-$(CONFIG_TCP_CONG_VENO) += tcp_veno.o
 obj-$(CONFIG_TCP_CONG_SCALABLE) += tcp_scalable.o
 obj-$(CONFIG_TCP_CONG_LP) += tcp_lp.o
+obj-$(CONFIG_IP_LEF) += lef.o
 
 obj-$(CONFIG_XFRM) += xfrm4_policy.o xfrm4_state.o xfrm4_input.o \
 		      xfrm4_output.o
--- linux-2.6.18.orig/net/ipv4/fib_frontend.c	2006-10-28 20:22:52.000000000 +0200
+++ linux-2.6.18/net/ipv4/fib_frontend.c	2006-11-07 00:01:04.000000000 +0100
@@ -184,6 +184,11 @@
 	if (in_dev == NULL)
 		goto e_inval;
 
+#ifdef CONFIG_IP_LEF
+	if (!rpf)
+		goto last_resort_norpf;
+#endif
+
 	if (fib_lookup(&fl, &res))
 		goto last_resort;
 	if (res.type != RTN_UNICAST)
@@ -220,6 +225,7 @@
 last_resort:
 	if (rpf)
 		goto e_inval;
+last_resort_norpf:
 	*spec_dst = inet_select_addr(dev, 0, RT_SCOPE_UNIVERSE);
 	*itag = 0;
 	return 0;
--- linux-2.6.18/include/net/arp.h.orig	2006-11-07 09:39:59.000000000 +0100
+++ linux-2.6.18/include/net/arp.h	2006-11-07 09:40:22.000000000 +0100
@@ -16,6 +16,9 @@
 			 struct net_device *dev, u32 src_ip, 
 			 unsigned char *dest_hw, unsigned char *src_hw, unsigned char *th);
 extern int	arp_bind_neighbour(struct dst_entry *dst);
+#ifdef CONFIG_IP_LEF
+extern int	arp_bind_neighbour_lef(struct lef *);
+#endif
 extern int	arp_mc_map(u32 addr, u8 *haddr, struct net_device *dev, int dir);
 extern void	arp_ifdown(struct net_device *dev);
 
--- linux-2.6.18.orig/net/ipv4/icmp.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/icmp.c	2006-11-11 16:34:39.000000000 +0100
@@ -439,8 +439,10 @@
 	u32 saddr;
 	u8  tos;
 
+#ifndef CONFIG_IP_LEF
 	if (!rt)
 		goto out;
+#endif
 
 	/*
 	 *	Find the original header. It is expected to be valid, of course.
@@ -461,7 +463,11 @@
 	/*
 	 *	Now check at the protocol level
 	 */
+#ifdef CONFIG_IP_LEF
+	if (rt && rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))
+#else
 	if (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))
+#endif
 		goto out;
 
 	/*
@@ -511,7 +517,11 @@
 	 */
 
 	saddr = iph->daddr;
+#ifdef CONFIG_IP_LEF
+	if (!rt || !(rt->rt_flags & RTCF_LOCAL)) {
+#else
 	if (!(rt->rt_flags & RTCF_LOCAL)) {
+#endif
 		if (sysctl_icmp_errors_use_inbound_ifaddr)
 			saddr = inet_select_addr(skb_in->dev, 0, RT_SCOPE_LINK);
 		else
--- linux-2.6.18.orig/net/ipv4/netfilter/Kconfig	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/netfilter/Kconfig	2006-11-12 15:45:00.000000000 +0100
@@ -353,7 +353,7 @@
 
 config IP_NF_TARGET_REJECT
 	tristate "REJECT target support"
-	depends on IP_NF_FILTER
+	depends on IP_NF_FILTER && !IP_LEF
 	help
 	  The REJECT target allows a filtering rule to specify that an ICMP
 	  error should be issued in response to an incoming packet, rather
@@ -433,7 +433,7 @@
 
 config IP_NF_TARGET_MASQUERADE
 	tristate "MASQUERADE target support"
-	depends on IP_NF_NAT
+	depends on IP_NF_NAT && !IP_LEF
 	help
 	  Masquerading is a special case of NAT: all outgoing connections are
 	  changed to seem to come from a particular interface's address, and
--- linux-2.6.18.orig/include/net/route.h	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/include/net/route.h	2006-11-14 12:08:57.000000000 +0100
@@ -115,6 +115,9 @@
 extern int		__ip_route_output_key(struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
+#ifdef CONFIG_IP_LEF
+extern int		ip_route_input_lef(struct sk_buff*, u32 dst, u32 src, u8 tos, struct net_device *devin, int use_lef);
+#endif
 extern int		ip_route_input(struct sk_buff*, u32 dst, u32 src, u8 tos, struct net_device *devin);
 extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
--- linux-2.6.18.orig/net/ipv4/route.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/route.c	2006-11-14 12:28:07.000000000 +0100
@@ -108,6 +108,9 @@
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
 
 #define RT_FL_TOS(oldflp) \
     ((u32)(oldflp->fl4_tos & (IPTOS_RT_MASK | RTO_ONLINK)))
@@ -252,6 +255,15 @@
 #define RT_CACHE_STAT_INC(field) \
 	(__raw_get_cpu_var(rt_cache_stat).field++)
 
+#ifdef CONFIG_IP_LEF
+static inline int rt_intern_hash(unsigned hash, struct rtable *rth,
+				struct rtable **res);
+
+static inline unsigned int rt_hash_code(u32 daddr, u32 saddr)
+{
+	return 0;
+}
+#else
 static int rt_intern_hash(unsigned hash, struct rtable *rth,
 				struct rtable **res);
 
@@ -260,6 +272,7 @@
 	return (jhash_2words(daddr, saddr, rt_hash_rnd)
 		& rt_hash_mask);
 }
+#endif
 
 #ifdef CONFIG_PROC_FS
 struct rt_cache_iter_state {
@@ -912,6 +925,23 @@
 out:	return 0;
 }
 
+#ifdef CONFIG_IP_LEF
+static inline int rt_intern_hash(unsigned hash, struct rtable *rt, struct rtable **rp)
+{
+	int err;
+
+	err = arp_bind_neighbour(&rt->u.dst);
+	if (err) {
+		rt_drop(rt);
+		return err;
+	}
+
+	rt_free(rt);
+	*rp = rt;
+
+	return 0;
+}
+#else
 static int rt_intern_hash(unsigned hash, struct rtable *rt, struct rtable **rp)
 {
 	struct rtable	*rth, **rthp;
@@ -1042,6 +1072,7 @@
 	*rp = rt;
 	return 0;
 }
+#endif
 
 void rt_bind_peer(struct rtable *rt, int create)
 {
@@ -1713,7 +1744,11 @@
 				  struct fib_result* res, 
 				  struct in_device *in_dev, 
 				  u32 daddr, u32 saddr, u32 tos, 
-				  struct rtable **result) 
+				  struct rtable **result
+#ifdef CONFIG_IP_LEF
+				  , int use_lef
+#endif
+				  )
 {
 
 	struct rtable *rth;
@@ -1760,6 +1795,20 @@
 		}
 	}
 
+#ifdef CONFIG_IP_LEF
+	if (use_lef) {
+		if (FIB_RES_GW(*res) &&
+				FIB_RES_NH(*res).nh_scope == RT_SCOPE_LINK)
+			skb->lef.gateway = FIB_RES_GW(*res);
+		else
+			skb->lef.gateway = daddr;
+		skb->lef.dev = (out_dev)->dev;
+		dev_hold(skb->lef.dev);
+		skb->lef.mtu = res->fi->fib_mtu ? res->fi->fib_mtu : skb->lef.dev->mtu;
+		err = 0;
+		goto cleanup;
+	}
+#endif
 
 	rth = dst_alloc(&ipv4_dst_ops);
 	if (!rth) {
@@ -1825,7 +1874,11 @@
 #endif
 
 	/* create a routing cache entry */
+#ifdef CONFIG_IP_LEF
+	err = __mkroute_input(skb, res, in_dev, daddr, saddr, tos, &rth, 0);
+#else
 	err = __mkroute_input(skb, res, in_dev, daddr, saddr, tos, &rth);
+#endif
 	if (err)
 		return err;
 
@@ -1901,8 +1954,13 @@
  *	2. IP spoofing attempts are filtered with 100% of guarantee.
  */
 
-static int ip_route_input_slow(struct sk_buff *skb, u32 daddr, u32 saddr,
+#ifdef CONFIG_IP_LEF
+static inline int ip_route_input_slow(struct sk_buff *skb, u32 daddr, u32 saddr,
+			       u8 tos, struct net_device *dev, int use_lef)
+#else
+static inline int ip_route_input_slow(struct sk_buff *skb, u32 daddr, u32 saddr,
 			       u8 tos, struct net_device *dev)
+#endif
 {
 	struct fib_result res;
 	struct in_device *in_dev = in_dev_get(dev);
@@ -1981,6 +2039,15 @@
 	if (res.type != RTN_UNICAST)
 		goto martian_destination;
 
+#ifdef CONFIG_IP_LEF
+	if (use_lef) {
+		err = __mkroute_input(skb, &res, in_dev, daddr, saddr, tos, NULL, 1);
+		if (unlikely(err))
+			goto done;
+		err = arp_bind_neighbour_lef(&skb->lef);
+		goto done;
+	}
+#endif
 	err = ip_mkroute_input(skb, &res, &fl, in_dev, daddr, saddr, tos);
 	if (err == -ENOBUFS)
 		goto e_nobufs;
@@ -2087,14 +2154,22 @@
 	goto e_inval;
 }
 
+#ifdef CONFIG_IP_LEF
+int ip_route_input_lef(struct sk_buff *skb, u32 daddr, u32 saddr,
+		   u8 tos, struct net_device *dev, int use_lef)
+#else
 int ip_route_input(struct sk_buff *skb, u32 daddr, u32 saddr,
 		   u8 tos, struct net_device *dev)
+#endif
 {
+#ifndef CONFIG_IP_LEF
 	struct rtable * rth;
 	unsigned	hash;
 	int iif = dev->ifindex;
+#endif
 
 	tos &= IPTOS_RT_MASK;
+#ifndef CONFIG_IP_LEF
 	hash = rt_hash_code(daddr, saddr ^ (iif << 5));
 
 	rcu_read_lock();
@@ -2119,6 +2194,7 @@
 		RT_CACHE_STAT_INC(in_hlist_search);
 	}
 	rcu_read_unlock();
+#endif /* !CONFIG_IP_LEF */
 
 	/* Multicast recognition logic is moved from route cache to here.
 	   The problem was that too many Ethernet cards have broken/missing
@@ -2151,9 +2227,22 @@
 		rcu_read_unlock();
 		return -EINVAL;
 	}
+#ifdef CONFIG_IP_LEF
+	return ip_route_input_slow(skb, daddr, saddr, tos, dev, use_lef);
+#else
 	return ip_route_input_slow(skb, daddr, saddr, tos, dev);
+#endif
 }
 
+#ifdef CONFIG_IP_LEF
+int ip_route_input(struct sk_buff *skb, u32 daddr, u32 saddr,
+		   u8 tos, struct net_device *dev)
+{
+	return ip_route_input_lef(skb, daddr, saddr, tos, dev, 0);
+}
+#endif
+
+
 static inline int __mkroute_output(struct rtable **result,
 				   struct fib_result* res, 
 				   const struct flowi *fl,
@@ -2564,6 +2653,7 @@
 
 int __ip_route_output_key(struct rtable **rp, const struct flowi *flp)
 {
+#ifndef CONFIG_IP_LEF
 	unsigned hash;
 	struct rtable *rth;
 
@@ -2603,6 +2693,7 @@
 		RT_CACHE_STAT_INC(out_hlist_search);
 	}
 	rcu_read_unlock_bh();
+#endif
 
 	return ip_route_output_slow(rp, flp);
 }
--- linux-2.6.18.orig/net/core/neighbour.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/core/neighbour.c	2006-11-14 13:33:31.000000000 +0100
@@ -34,6 +34,10 @@
 #include <linux/random.h>
 #include <linux/string.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 #define NEIGH_DEBUG 1
 
 #define NEIGH_PRINTK(x...) printk(x)
@@ -1139,7 +1143,11 @@
 	struct neighbour *neigh;
 	int rc = 0;
 
+#ifdef CONFIG_IP_LEF
+	if ((!dst || !(neigh = dst->neighbour)) && !(neigh = skb->lef.neighbour))
+#else
 	if (!dst || !(neigh = dst->neighbour))
+#endif
 		goto discard;
 
 	__skb_pull(skb, skb->nh.raw - skb->data);
@@ -1147,7 +1155,11 @@
 	if (!neigh_event_send(neigh, skb)) {
 		int err;
 		struct net_device *dev = neigh->dev;
+#ifdef CONFIG_IP_LEF
+		if (dst && dev->hard_header_cache && !dst->hh) {
+#else
 		if (dev->hard_header_cache && !dst->hh) {
+#endif
 			write_lock_bh(&neigh->lock);
 			if (!dst->hh)
 				neigh_hh_init(neigh, dst, dst->ops->protocol);
@@ -1182,8 +1194,17 @@
 {
 	int err;
 	struct dst_entry *dst = skb->dst;
-	struct neighbour *neigh = dst->neighbour;
-	struct net_device *dev = neigh->dev;
+	struct neighbour *neigh;
+	struct net_device *dev;
+
+#ifdef CONFIG_IP_LEF
+	if (!dst)
+		neigh = skb->lef.neighbour;
+	else
+#endif
+		neigh = dst->neighbour;
+
+	dev = neigh->dev;
 
 	__skb_pull(skb, skb->nh.raw - skb->data);
 
--- linux-2.6.18.orig/net/ipv4/lef.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.18/net/ipv4/lef.c	2006-11-14 13:48:09.000000000 +0100
@@ -0,0 +1,124 @@
+/*
+ * Linux express forwarding code
+ *
+ * Mainly developed by krichy < krichy at cflinux dot hu >
+ *
+ * Currently it is under development, so do not expect much from it,
+ * or not anything else than a kernel panic. :)
+ *
+ * The code is subject to GPLv2 or any later one.
+ */
+
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <net/arp.h>
+#include <net/lef.h>
+#include <net/sock.h>
+#include <net/ip.h>
+#include <net/route.h>
+#include <net/icmp.h>
+#include <linux/icmp.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_bridge.h>
+
+static inline int	lef_output_finish2(struct sk_buff *skb)
+{
+	struct net_device *dev = skb->lef.dev;
+	struct neighbour *neigh;
+	int hh_len = LL_RESERVED_SPACE(dev);
+
+	/* Be paranoid, rather than too clever. */
+	if (unlikely(skb_headroom(skb) < hh_len && dev->hard_header)) {
+		struct sk_buff *skb2;
+
+		skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));
+		if (skb2 == NULL) {
+			kfree_skb(skb);
+			return -ENOMEM;
+		}
+		if (skb->sk)
+			skb_set_owner_w(skb2, skb->sk);
+		kfree_skb(skb);
+		skb = skb2;
+	}
+
+	if (likely((neigh = skb->lef.neighbour))) {
+		return neigh->output(skb);
+	}
+
+	printk("lef_output_finish2: no neighbour found\n");
+	kfree_skb(skb);
+
+	return NET_RX_DROP;
+}
+
+static inline int	lef_output_finish(struct sk_buff *skb)
+{
+	if (skb->len > skb->lef.mtu && !skb_is_gso(skb)) {
+		// TODO: fragment
+		kfree_skb(skb);
+		return NET_RX_DROP;
+	} else {
+		return lef_output_finish2(skb);
+	}
+}
+
+static inline int	lef_output(struct sk_buff *skb)
+{
+	struct net_device *dev = skb->lef.dev;
+
+	IP_INC_STATS(IPSTATS_MIB_OUTREQUESTS);
+
+	skb->dev = dev;
+	skb->protocol = htons(ETH_P_IP);
+
+	return NF_HOOK_COND(PF_INET, NF_IP_POST_ROUTING, skb, NULL, dev,
+		            lef_output_finish,
+			    !(IPCB(skb)->flags & IPSKB_REROUTED));
+}
+
+static inline int	lef_forward_finish(struct sk_buff *skb)
+{
+	IP_INC_STATS_BH(IPSTATS_MIB_OUTFORWDATAGRAMS);
+
+	return lef_output(skb);
+}
+
+int			lef_forward(struct sk_buff *skb)
+{
+	struct iphdr *iph;	/* Our header */
+
+	if (skb->pkt_type != PACKET_HOST)
+		goto drop;
+
+	skb->ip_summed = CHECKSUM_NONE;
+	iph = skb->nh.iph;
+
+	/*
+	 *	According to the RFC, we must first decrease the TTL field. If
+	 *	that reaches zero, we must reply an ICMP control message telling
+	 *	that the packet's lifetime expired.
+	 */
+	if (iph->ttl <= 1)
+                goto too_many_hops;
+
+	/* We are about to mangle packet. Copy it! */
+	if (skb_cow(skb, LL_RESERVED_SPACE(skb->lef.dev)))
+		goto drop;
+
+	/* Decrease ttl after skb cow done */
+	ip_decrease_ttl(iph);
+
+	skb->priority = rt_tos2priority(iph->tos);
+
+	return NF_HOOK(PF_INET, NF_IP_FORWARD, skb, skb->dev, skb->lef.dev,
+		       lef_forward_finish);
+
+too_many_hops:
+        /* Tell the sender its packet died... */
+        IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
+        icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
+drop:
+	kfree_skb(skb);
+	return NET_RX_DROP;
+}
--- linux-2.6.18.orig/net/ipv4/ip_input.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/ip_input.c	2006-11-14 19:13:18.000000000 +0100
@@ -146,6 +146,10 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 /*
  *	SNMP management statistics
  */
@@ -331,14 +335,22 @@
 static inline int ip_rcv_finish(struct sk_buff *skb)
 {
 	struct iphdr *iph = skb->nh.iph;
+	int ip_has_options = iph->ihl > 5;
 
 	/*
 	 *	Initialise the virtual path cache for the packet. It describes
 	 *	how the packet travels inside Linux networking.
+	 *	Only packets without IP options can be handled by LEF, so
+	 *	give the function this information.
 	 */ 
 	if (skb->dst == NULL) {
+#ifdef CONFIG_IP_LEF
+		int err = ip_route_input_lef(skb, iph->daddr, iph->saddr, iph->tos,
+					 skb->dev, !ip_has_options);
+#else
 		int err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos,
 					 skb->dev);
+#endif
 		if (unlikely(err)) {
 			if (err == -EHOSTUNREACH)
 				IP_INC_STATS_BH(IPSTATS_MIB_INADDRERRORS);
@@ -347,6 +359,9 @@
 	}
 
 #ifdef CONFIG_NET_CLS_ROUTE
+#ifdef CONFIG_IP_LEF
+	if (skb->dst) {
+#endif
 	if (unlikely(skb->dst->tclassid)) {
 		struct ip_rt_acct *st = ip_rt_acct + 256*smp_processor_id();
 		u32 idx = skb->dst->tclassid;
@@ -355,11 +370,19 @@
 		st[(idx>>16)&0xFF].i_packets++;
 		st[(idx>>16)&0xFF].i_bytes+=skb->len;
 	}
+#ifdef CONFIG_IP_LEF
+	}
+#endif
 #endif
 
-	if (iph->ihl > 5 && ip_rcv_options(skb))
+	if (ip_has_options && ip_rcv_options(skb))
 		goto drop;
 
+#ifdef CONFIG_IP_LEF
+	if (!skb->dst)
+		return lef_forward(skb);
+	else
+#endif
 	return dst_input(skb);
 
 drop:
