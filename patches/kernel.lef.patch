diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 5992f65..de217fd 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -28,6 +28,10 @@
 #include <linux/rcupdate.h>
 #include <linux/dmaengine.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef_struct.h>
+#endif
+
 #define HAVE_ALLOC_SKB		/* For the drivers to know */
 #define HAVE_ALIGNABLE_SKB	/* Ditto 8)		   */
 
@@ -261,6 +265,9 @@ struct sk_buff {
 
 	struct  dst_entry	*dst;
 	struct	sec_path	*sp;
+#ifdef CONFIG_IP_LEF
+	struct  lef		lef;
+#endif
 
 	/*
 	 * This is the control buffer. It is free to use for every
diff --git a/include/net/arp.h b/include/net/arp.h
index f026645..92e1e8b 100644
--- a/include/net/arp.h
+++ b/include/net/arp.h
@@ -16,6 +16,9 @@ extern void     arp_send(int type, int ptype, __be32 dest_ip,
 			 struct net_device *dev, __be32 src_ip,
 			 unsigned char *dest_hw, unsigned char *src_hw, unsigned char *th);
 extern int	arp_bind_neighbour(struct dst_entry *dst);
+#ifdef CONFIG_IP_LEF
+extern int	arp_bind_neighbour_lef(struct lef *lef, __be32 nexthop);
+#endif
 extern int	arp_mc_map(__be32 addr, u8 *haddr, struct net_device *dev, int dir);
 extern void	arp_ifdown(struct net_device *dev);
 
diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h
index 36c635c..09ab0c9 100644
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@ -61,6 +61,9 @@ struct fib_nh {
 #endif
 	int			nh_oif;
 	__be32			nh_gw;
+#ifdef CONFIG_IP_LEF
+	struct neighbour	*neighbour;
+#endif
 };
 
 /*
@@ -111,6 +114,7 @@ struct fib_result {
 #ifdef CONFIG_IP_MULTIPLE_TABLES
 	struct fib_rule	*r;
 #endif
+	struct fib_nh	*nh;
 };
 
 struct fib_result_nl {
@@ -130,7 +134,11 @@ struct fib_result_nl {
 
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 
+#ifdef CONFIG_IP_LEF
+#define FIB_RES_NH(res)		(*((res).nh))
+#else
 #define FIB_RES_NH(res)		((res).fi->fib_nh[(res).nh_sel])
+#endif
 #define FIB_RES_RESET(res)	((res).nh_sel = 0)
 
 #else /* CONFIG_IP_ROUTE_MULTIPATH */
diff --git a/include/net/lef.h b/include/net/lef.h
new file mode 100644
index 0000000..2d03574
--- /dev/null
+++ b/include/net/lef.h
@@ -0,0 +1,63 @@
+/*
+ * Linux express forwarding code
+ *
+ * Mainly developed by krichy < krichy at cflinux dot hu >
+ *
+ * Currently it is under development, so do not expect much from it,
+ * or not anything else than a kernel panic. :)
+ *
+ * The code is subject to GPLv2 or any later one.
+ */
+
+#ifndef _NET_LEF_H
+#define _NET_LEF_H
+
+#include <asm/types.h>
+#include <asm/processor.h>
+#include <net/neighbour.h>
+#include <linux/netdevice.h>
+#include <net/neighbour.h>
+#include <net/lef_struct.h>
+
+// some trivial lef-related functions
+
+/* lef_init
+ * is called when initialising a lef structure
+ * it just zeros all elements of it
+ * @l: struct lef
+ */
+static inline void		lef_init(struct lef* l)
+{
+	memset(l, 0, sizeof(*l));
+}
+
+/* lef_init_copy
+ * inits a lef from another one (actually copying old contents
+ * and allocating references
+ * @l: new lef
+ * @o: old lef
+ */
+static inline void		lef_init_copy(struct lef* l, const struct lef* o)
+{
+	if ((l->dev = o->dev))
+		dev_hold(l->dev);
+	l->mtu = o->mtu;
+	if ((l->neighbour = o->neighbour))
+		neigh_hold(l->neighbour);
+}
+
+/* lef_destroy
+ * destroys (frees) elements of a lef
+ * @l: struct lef
+ */
+static inline void		lef_destroy(struct lef* l)
+{
+	if (likely(l->neighbour))
+		neigh_release(l->neighbour);
+	if (likely(l->dev))
+		dev_put(l->dev);
+}
+
+extern int			lef_forward(struct sk_buff *);
+
+#endif /* _NET_LEF_H */
diff --git a/include/net/lef_struct.h b/include/net/lef_struct.h
new file mode 100644
index 0000000..764e4fe
--- /dev/null
+++ b/include/net/lef_struct.h
@@ -0,0 +1,29 @@
+/*
+ * Linux express forwarding code
+ *
+ * Mainly developed by krichy < krichy at cflinux dot hu >
+ *
+ * Currently it is under development, so do not expect much from it,
+ * or not anything else than a kernel panic. :)
+ *
+ * The code is subject to GPLv2 or any later one.
+ */
+
+#ifndef _NET_LEF_STRUCT_H
+#define _NET_LEF_STRUCT_H
+
+// forward declarations
+struct net_device;
+struct neighbour;
+
+// our express forwarding structure
+struct lef {
+	struct net_device	*dev;		// our device
+	__u32			mtu;		// our mtu
+	struct neighbour	*neighbour;	// our neigbour
+	int			flags;		// flags
+};
+
+#define	LEF_NEED		1		// we should use lef
+
+#endif /* _NET_LEF_STRUCT_H */
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index 841e3f3..3640ea7 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -34,6 +34,10 @@
 #include <linux/random.h>
 #include <linux/string.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 #define NEIGH_DEBUG 1
 
 #define NEIGH_PRINTK(x...) printk(x)
@@ -1144,7 +1148,11 @@ int neigh_resolve_output(struct sk_buff *skb)
 	struct neighbour *neigh;
 	int rc = 0;
 
+#ifdef CONFIG_IP_LEF
+	if ((!dst || !(neigh = dst->neighbour)) && !(neigh = skb->lef.neighbour))
+#else
 	if (!dst || !(neigh = dst->neighbour))
+#endif
 		goto discard;
 
 	__skb_pull(skb, skb->nh.raw - skb->data);
@@ -1152,7 +1160,11 @@ int neigh_resolve_output(struct sk_buff *skb)
 	if (!neigh_event_send(neigh, skb)) {
 		int err;
 		struct net_device *dev = neigh->dev;
+#ifdef CONFIG_IP_LEF
+		if (dst && dev->hard_header_cache && !dst->hh) {
+#else
 		if (dev->hard_header_cache && !dst->hh) {
+#endif
 			write_lock_bh(&neigh->lock);
 			if (!dst->hh)
 				neigh_hh_init(neigh, dst, dst->ops->protocol);
@@ -1187,8 +1199,17 @@ int neigh_connected_output(struct sk_buff *skb)
 {
 	int err;
 	struct dst_entry *dst = skb->dst;
-	struct neighbour *neigh = dst->neighbour;
-	struct net_device *dev = neigh->dev;
+	struct neighbour *neigh;
+	struct net_device *dev;
+
+#ifdef CONFIG_IP_LEF
+	if (!dst)
+		neigh = skb->lef.neighbour;
+	else
+#endif
+		neigh = dst->neighbour;
+
+	dev = neigh->dev;
 
 	__skb_pull(skb, skb->nh.raw - skb->data);
 
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 336958f..5e10ada 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -65,6 +65,10 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 #include "kmap_skb.h"
 
 static struct kmem_cache *skbuff_head_cache __read_mostly;
@@ -317,6 +321,9 @@ void __kfree_skb(struct sk_buff *skb)
 #ifdef CONFIG_XFRM
 	secpath_put(skb->sp);
 #endif
+#ifdef CONFIG_IP_LEF
+	lef_destroy(&skb->lef);
+#endif
 	if (skb->destructor) {
 		WARN_ON(in_irq());
 		skb->destructor(skb);
@@ -405,6 +412,9 @@ struct sk_buff *skb_clone(struct sk_buff *skb, gfp_t gfp_mask)
 #ifdef CONFIG_INET
 	secpath_get(skb->sp);
 #endif
+#ifdef CONFIG_IP_LEF
+	lef_init_copy(&n->lef, &skb->lef);
+#endif
 	memcpy(n->cb, skb->cb, sizeof(skb->cb));
 	C(len);
 	C(data_len);
@@ -473,6 +483,9 @@ static void copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
 #ifdef CONFIG_INET
 	new->sp		= secpath_get(old->sp);
 #endif
+#ifdef CONFIG_IP_LEF
+	lef_init_copy(&new->lef, &old->lef);
+#endif
 	new->h.raw	= old->h.raw + offset;
 	new->nh.raw	= old->nh.raw + offset;
 	new->mac.raw	= old->mac.raw + offset;
@@ -1923,6 +1936,9 @@ struct sk_buff *skb_segment(struct sk_buff *skb, int features)
 		nskb->priority = skb->priority;
 		nskb->protocol = skb->protocol;
 		nskb->dst = dst_clone(skb->dst);
+#ifdef CONFIG_IP_LEF
+		lef_init_copy(&nskb->lef, &skb->lef);
+#endif
 		memcpy(nskb->cb, skb->cb, sizeof(skb->cb));
 		nskb->pkt_type = skb->pkt_type;
 		nskb->mac_len = skb->mac_len;
diff --git a/net/ipv4/Kconfig b/net/ipv4/Kconfig
index 5fc4a05..6469de4 100644
--- a/net/ipv4/Kconfig
+++ b/net/ipv4/Kconfig
@@ -51,6 +51,12 @@ config IP_ADVANCED_ROUTER
 
 	  If unsure, say N here.
 
+config IP_LEF
+	bool "IP: Linux express forwarding"
+	depends on IP_ADVANCED_ROUTER && !SMP && PREEMPT_NONE
+	---help---
+	You should not turn this on
+
 choice 
 	prompt "Choose IP: FIB lookup algorithm (choose FIB_HASH if unsure)"
 	depends on IP_ADVANCED_ROUTER
@@ -118,7 +124,7 @@ config IP_ROUTE_MULTIPATH
 
 config IP_ROUTE_MULTIPATH_CACHED
 	bool "IP: equal cost multipath with caching support (EXPERIMENTAL)"
-	depends on IP_ROUTE_MULTIPATH
+	depends on IP_ROUTE_MULTIPATH && !IP_LEF
 	help
 	  Normally, equal cost multipath routing is not supported by the
 	  routing cache. If you say Y here, alternative routes are cached
diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
index 7a06862..9ced7a2 100644
--- a/net/ipv4/Makefile
+++ b/net/ipv4/Makefile
@@ -50,6 +50,7 @@ obj-$(CONFIG_TCP_CONG_VENO) += tcp_veno.o
 obj-$(CONFIG_TCP_CONG_SCALABLE) += tcp_scalable.o
 obj-$(CONFIG_TCP_CONG_LP) += tcp_lp.o
 obj-$(CONFIG_NETLABEL) += cipso_ipv4.o
+obj-$(CONFIG_IP_LEF) += lef.o
 
 obj-$(CONFIG_XFRM) += xfrm4_policy.o xfrm4_state.o xfrm4_input.o \
 		      xfrm4_output.o
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index 1a3488a..ecf6d58 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -126,6 +126,10 @@ struct neigh_table *clip_tbl_hook;
 
 #include <linux/netfilter_arp.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 /*
  *	Interface to generic neighbour cache.
  */
@@ -525,6 +529,30 @@ int arp_bind_neighbour(struct dst_entry *dst)
 	return 0;
 }
 
+#ifdef CONFIG_IP_LEF
+int arp_bind_neighbour_lef(struct lef *lef, __be32 nexthop)
+{
+	struct net_device *dev = lef->dev;
+	struct neighbour *n = lef->neighbour;
+
+	if (dev == NULL)
+		return -EINVAL;
+	if (n == NULL) {
+		if (dev->flags&(IFF_LOOPBACK|IFF_POINTOPOINT))
+			nexthop = 0;
+		n = __neigh_lookup_errno(
+#if defined(CONFIG_ATM_CLIP) || defined(CONFIG_ATM_CLIP_MODULE)
+		    dev->type == ARPHRD_ATM ? clip_tbl_hook :
+#endif
+		    &arp_tbl, &nexthop, dev);
+		if (IS_ERR(n))
+			return PTR_ERR(n);
+		lef->neighbour = n;
+	}
+	return 0;
+}
+#endif
+
 /*
  * Check if we can use proxy ARP for this path
  */
diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c
index 3dad12e..28f00f7 100644
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@ -153,6 +153,11 @@ void free_fib_info(struct fib_info *fi)
 		if (nh->nh_dev)
 			dev_put(nh->nh_dev);
 		nh->nh_dev = NULL;
+#ifdef CONFIG_IP_LEF
+		if (nh->neighbour)
+			neigh_release(nh->neighbour);
+		nh->neighbour = NULL;
+#endif
 	} endfor_nexthops(fi);
 	fib_info_cnt--;
 	kfree(fi);
@@ -872,13 +877,31 @@ failure:
 	return ERR_PTR(err);
 }
 
+#ifdef CONFIG_IP_LEF
+/* dst_hash - for hashing a flowi */
+static inline unsigned char __ip4_hash(const unsigned char *ip)
+{
+	return ip[0] + ip[1] + ip[2] + ip[3];
+}
+
+static inline unsigned char __flowi_hash(const struct flowi *flp)
+{
+	return __ip4_hash((unsigned char*)&flp->fl4_dst) +
+		jiffies;
+}
+#endif
+
 /* Note! fib_semantic_match intentionally uses  RCU list functions. */
 int fib_semantic_match(struct list_head *head, const struct flowi *flp,
 		       struct fib_result *res, __be32 zone, __be32 mask,
 			int prefixlen)
 {
 	struct fib_alias *fa;
-	int nh_sel = 0;
+	int nh_sel;
+#ifdef CONFIG_IP_LEF
+	const struct fib_nh *_nh;
+	unsigned _fib_nhs;
+#endif
 
 	list_for_each_entry_rcu(fa, head, fa_list) {
 		int err;
@@ -899,12 +922,51 @@ int fib_semantic_match(struct list_head *head, const struct flowi *flp,
 			if (fi->fib_flags & RTNH_F_DEAD)
 				continue;
 
+#ifdef CONFIG_IP_LEF
+			_fib_nhs = fi->fib_nhs;
+#endif
+
+#ifndef CONFIG_IP_LEF
 			switch (fa->fa_type) {
 			case RTN_UNICAST:
 			case RTN_LOCAL:
 			case RTN_BROADCAST:
 			case RTN_ANYCAST:
 			case RTN_MULTICAST:
+#endif
+#ifdef CONFIG_IP_LEF
+				{
+					int _nh_i;
+
+					if (likely(_fib_nhs == 1)) {
+						_nh = fi->fib_nh;
+						if (likely(!(_nh->nh_flags&RTNH_F_DEAD))) {
+							if (!flp->oif || flp->oif == _nh->nh_oif) {
+								nh_sel = 0;
+								goto out_fill_res;
+							}
+						}
+					} else {
+						nh_sel = ((unsigned)__flowi_hash(flp) % _fib_nhs);
+						for (_nh_i = 0; _nh_i < _fib_nhs; _nh_i++) {
+							_nh = fi->fib_nh + nh_sel;
+
+							if (likely(!(_nh->nh_flags&RTNH_F_DEAD))) {
+								if (!flp->oif || flp->oif == _nh->nh_oif)
+									break;
+							}
+							nh_sel = (nh_sel + 1) % _fib_nhs;
+						}
+					}
+#ifdef CONFIG_IP_ROUTE_MULTIPATH
+					if (_nh_i < _fib_nhs)
+						goto out_fill_res;
+#else
+					if (_nh_i < 1)
+						goto out_fill_res;
+#endif
+				}
+#else
 				for_nexthops(fi) {
 					if (nh->nh_flags&RTNH_F_DEAD)
 						continue;
@@ -922,12 +984,15 @@ int fib_semantic_match(struct list_head *head, const struct flowi *flp,
 				}
 #endif
 				endfor_nexthops(fi);
+#endif
 				continue;
+#ifndef CONFIG_IP_LEF
 
 			default:
 				printk(KERN_DEBUG "impossible 102\n");
 				return -EINVAL;
 			};
+#endif
 		}
 		return err;
 	}
@@ -943,6 +1008,9 @@ out_fill_res:
 	res->netmask = mask;
 	res->network = zone & inet_make_mask(prefixlen);
 #endif
+#ifdef CONFIG_IP_LEF
+	res->nh = (struct fib_nh*)_nh;
+#endif
 	atomic_inc(&res->fi->fib_clntref);
 	return 0;
 }
@@ -1073,6 +1141,9 @@ int fib_sync_down(__be32 local, struct net_device *dev, int force)
 		struct hlist_head *head = &fib_info_devhash[hash];
 		struct hlist_node *node;
 		struct fib_nh *nh;
+#ifdef CONFIG_IP_LEF
+		struct neighbour *neigh;
+#endif
 
 		hlist_for_each_entry(nh, node, head, nh_hash) {
 			struct fib_info *fi = nh->nh_parent;
@@ -1095,6 +1166,12 @@ int fib_sync_down(__be32 local, struct net_device *dev, int force)
 					nh->nh_power = 0;
 					spin_unlock_bh(&fib_multipath_lock);
 #endif
+#ifdef CONFIG_IP_LEF
+					if ((neigh = nh->neighbour)) {
+						nh->neighbour = NULL;
+						neigh_release(neigh);
+					}
+#endif
 					dead++;
 				}
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.c
index 03d9659..55d99b2 100644
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@ -440,8 +440,10 @@ void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)
 	__be32 saddr;
 	u8  tos;
 
+#ifndef CONFIG_IP_LEF
 	if (!rt)
 		goto out;
+#endif
 
 	/*
 	 *	Find the original header. It is expected to be valid, of course.
@@ -462,7 +464,11 @@ void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)
 	/*
 	 *	Now check at the protocol level
 	 */
+#ifdef CONFIG_IP_LEF
+	if (rt && rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))
+#else
 	if (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))
+#endif
 		goto out;
 
 	/*
@@ -512,6 +518,11 @@ void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)
 	 */
 
 	saddr = iph->daddr;
+#ifdef CONFIG_IP_LEF
+	if (!rt) {
+		saddr = 0;
+	} else
+#endif
 	if (!(rt->rt_flags & RTCF_LOCAL)) {
 		struct net_device *dev = NULL;
 
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index f38e976..2e3749a 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -145,6 +145,9 @@
 #include <net/xfrm.h>
 #include <linux/mroute.h>
 #include <linux/netlink.h>
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
 
 /*
  *	SNMP management statistics
@@ -337,6 +340,9 @@ static inline int ip_rcv_finish(struct sk_buff *skb)
 	 *	how the packet travels inside Linux networking.
 	 */
 	if (skb->dst == NULL) {
+#ifdef CONFIG_IP_LEF
+		skb->lef.flags |= LEF_NEED;
+#endif
 		int err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos,
 					 skb->dev);
 		if (unlikely(err)) {
@@ -344,6 +350,10 @@ static inline int ip_rcv_finish(struct sk_buff *skb)
 				IP_INC_STATS_BH(IPSTATS_MIB_INADDRERRORS);
 			goto drop;
 		}
+#ifdef CONFIG_IP_LEF
+		if (!skb->dst)	// LEF has processed the packet
+			return lef_forward(skb);
+#endif
 	}
 
 #ifdef CONFIG_NET_CLS_ROUTE
diff --git a/net/ipv4/lef.c b/net/ipv4/lef.c
new file mode 100644
index 0000000..60aef35
--- /dev/null
+++ b/net/ipv4/lef.c
@@ -0,0 +1,124 @@
+/*
+ * Linux express forwarding code
+ *
+ * Mainly developed by krichy < krichy at cflinux dot hu >
+ *
+ * Currently it is under development, so do not expect much from it,
+ * or not anything else than a kernel panic. :)
+ *
+ * The code is subject to GPLv2 or any later one.
+ */
+
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <net/arp.h>
+#include <net/lef.h>
+#include <net/sock.h>
+#include <net/ip.h>
+#include <net/route.h>
+#include <net/icmp.h>
+#include <linux/icmp.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_bridge.h>
+
+static inline int	lef_output_finish2(struct sk_buff *skb)
+{
+	struct net_device *dev = skb->lef.dev;
+	struct neighbour *neigh;
+	int hh_len = LL_RESERVED_SPACE(dev);
+
+	/* Be paranoid, rather than too clever. */
+	if (unlikely(skb_headroom(skb) < hh_len && dev->hard_header)) {
+		struct sk_buff *skb2;
+
+		skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));
+		if (skb2 == NULL) {
+			kfree_skb(skb);
+			return -ENOMEM;
+		}
+		if (skb->sk)
+			skb_set_owner_w(skb2, skb->sk);
+		kfree_skb(skb);
+		skb = skb2;
+	}
+
+	if (likely((neigh = skb->lef.neighbour))) {
+		return neigh->output(skb);
+	}
+
+	printk("lef_output_finish2: no neighbour found\n");
+	kfree_skb(skb);
+
+	return NET_RX_DROP;
+}
+
+static inline int	lef_output_finish(struct sk_buff *skb)
+{
+	if (skb->len > skb->lef.mtu && !skb_is_gso(skb)) {
+		// TODO: fragment
+		kfree_skb(skb);
+		return NET_RX_DROP;
+	} else {
+		return lef_output_finish2(skb);
+	}
+}
+
+static inline int	lef_output(struct sk_buff *skb)
+{
+	struct net_device *dev = skb->lef.dev;
+
+	IP_INC_STATS(IPSTATS_MIB_OUTREQUESTS);
+
+	skb->dev = dev;
+	skb->protocol = htons(ETH_P_IP);
+
+	return NF_HOOK_COND(PF_INET, NF_IP_POST_ROUTING, skb, NULL, dev,
+		            lef_output_finish,
+			    !(IPCB(skb)->flags & IPSKB_REROUTED));
+}
+
+static inline int	lef_forward_finish(struct sk_buff *skb)
+{
+	IP_INC_STATS_BH(IPSTATS_MIB_OUTFORWDATAGRAMS);
+
+	return lef_output(skb);
+}
+
+int			lef_forward(struct sk_buff *skb)
+{
+	struct iphdr *iph;	/* Our header */
+
+	if (skb->pkt_type != PACKET_HOST)
+		goto drop;
+
+	skb->ip_summed = CHECKSUM_NONE;
+	iph = skb->nh.iph;
+
+	/*
+	 *	According to the RFC, we must first decrease the TTL field. If
+	 *	that reaches zero, we must reply an ICMP control message telling
+	 *	that the packet's lifetime expired.
+	 */
+	if (iph->ttl <= 1)
+                goto too_many_hops;
+
+	/* We are about to mangle packet. Copy it! */
+	if (skb_cow(skb, LL_RESERVED_SPACE(skb->lef.dev)))
+		goto drop;
+
+	/* Decrease ttl after skb cow done */
+	ip_decrease_ttl(iph);
+
+	skb->priority = rt_tos2priority(iph->tos);
+
+	return NF_HOOK(PF_INET, NF_IP_FORWARD, skb, skb->dev, skb->lef.dev,
+		       lef_forward_finish);
+
+too_many_hops:
+        /* Tell the sender its packet died... */
+        IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
+        icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
+drop:
+	kfree_skb(skb);
+	return NET_RX_DROP;
+}
diff --git a/net/ipv4/netfilter/Kconfig b/net/ipv4/netfilter/Kconfig
index 601808c..d3b4e2a 100644
--- a/net/ipv4/netfilter/Kconfig
+++ b/net/ipv4/netfilter/Kconfig
@@ -395,7 +395,7 @@ config NF_NAT_NEEDED
 
 config IP_NF_TARGET_MASQUERADE
 	tristate "MASQUERADE target support"
-	depends on (NF_NAT || IP_NF_NAT)
+	depends on (NF_NAT || IP_NF_NAT) && !IP_LEF
 	help
 	  Masquerading is a special case of NAT: all outgoing connections are
 	  changed to seem to come from a particular interface's address, and
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 37e0d4d..13ee263 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -107,6 +107,9 @@
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
 
 #define RT_FL_TOS(oldflp) \
     ((u32)(oldflp->fl4_tos & (IPTOS_RT_MASK | RTO_ONLINK)))
@@ -251,6 +254,15 @@ static DEFINE_PER_CPU(struct rt_cache_stat, rt_cache_stat);
 #define RT_CACHE_STAT_INC(field) \
 	(__raw_get_cpu_var(rt_cache_stat).field++)
 
+#ifdef CONFIG_IP_LEF
+static inline int rt_intern_hash(unsigned hash, struct rtable *rth,
+				struct rtable **res);
+
+static inline unsigned int rt_hash_code(u32 daddr, u32 saddr)
+{
+	return 0;
+}
+#else
 static int rt_intern_hash(unsigned hash, struct rtable *rth,
 				struct rtable **res);
 
@@ -259,6 +271,7 @@ static unsigned int rt_hash_code(u32 daddr, u32 saddr)
 	return (jhash_2words(daddr, saddr, rt_hash_rnd)
 		& rt_hash_mask);
 }
+#endif
 
 #define rt_hash(daddr, saddr, idx) \
 	rt_hash_code((__force u32)(__be32)(daddr),\
@@ -919,6 +932,23 @@ work_done:
 out:	return 0;
 }
 
+#ifdef CONFIG_IP_LEF
+static inline int rt_intern_hash(unsigned hash, struct rtable *rt, struct rtable **rp)
+{
+	int err;
+
+	err = arp_bind_neighbour(&rt->u.dst);
+	if (err) {
+		rt_drop(rt);
+		return err;
+	}
+
+	rt_free(rt);
+	*rp = rt;
+
+	return 0;
+}
+#else
 static int rt_intern_hash(unsigned hash, struct rtable *rt, struct rtable **rp)
 {
 	struct rtable	*rth, **rthp;
@@ -1049,6 +1079,7 @@ restart:
 	*rp = rt;
 	return 0;
 }
+#endif
 
 void rt_bind_peer(struct rtable *rt, int create)
 {
@@ -1893,6 +1924,52 @@ static inline int ip_mkroute_input(struct sk_buff *skb,
 #endif /* CONFIG_IP_ROUTE_MULTIPATH_CACHED  */
 }
 
+#ifdef CONFIG_IP_LEF
+static inline int __lef_mkroute_input(struct sk_buff *skb, struct fib_result *res, __be32 daddr)
+{
+	int	err;
+	__be32	gw;
+
+	if (FIB_RES_GW(*res) && FIB_RES_NH(*res).nh_scope == RT_SCOPE_LINK)
+		gw = FIB_RES_GW(*res);
+	else
+		gw = daddr;
+
+	err = arp_bind_neighbour_lef(&skb->lef, gw);
+	if (unlikely(err))
+		return err;
+
+	// TODO: not SMP safe
+	if (gw != daddr) { // only store if it is a real gateway
+		res->nh->neighbour = skb->lef.neighbour;
+		atomic_inc(&res->nh->neighbour->refcnt);
+	}
+
+	return 0;
+}
+
+static inline int lef_mkroute_input(struct sk_buff *skb, struct fib_result *res, struct in_device *in_dev, __be32 daddr)
+{
+	if (unlikely(!(skb->lef.flags & LEF_NEED)))
+		return -EAGAIN;
+
+	if (likely(skb->nh.iph->ihl <= 5 && !IN_DEV_RPFILTER(in_dev))) {
+		skb->lef.dev = FIB_RES_DEV(*res);
+		dev_hold(skb->lef.dev);
+		skb->lef.mtu = res->fi->fib_mtu ? res->fi->fib_mtu : skb->lef.dev->mtu;
+
+		if (likely(res->nh->neighbour)) {
+			skb->lef.neighbour = res->nh->neighbour;
+			atomic_inc(&skb->lef.neighbour->refcnt);
+			return 0;
+		} else {
+			return __lef_mkroute_input(skb, res, daddr);
+		}
+	}
+
+	return -EAGAIN;
+}
+#endif
 
 /*
  *	NOTE. We drop all the packets that has local source
@@ -1904,7 +1981,7 @@ static inline int ip_mkroute_input(struct sk_buff *skb,
  *	2. IP spoofing attempts are filtered with 100% of guarantee.
  */
 
-static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,
+static inline int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 			       u8 tos, struct net_device *dev)
 {
 	struct fib_result res;
@@ -1982,6 +2059,11 @@ static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 	if (res.type != RTN_UNICAST)
 		goto martian_destination;
 
+#ifdef CONFIG_IP_LEF
+	err = lef_mkroute_input(skb, &res, in_dev, daddr);
+	if (likely(err != -EAGAIN))
+		goto done;
+#endif
 	err = ip_mkroute_input(skb, &res, &fl, in_dev, daddr, saddr, tos);
 	if (err == -ENOBUFS)
 		goto e_nobufs;
@@ -2089,11 +2171,14 @@ martian_source:
 int ip_route_input(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 		   u8 tos, struct net_device *dev)
 {
+#ifndef CONFIG_IP_LEF
 	struct rtable * rth;
 	unsigned	hash;
 	int iif = dev->ifindex;
+#endif
 
 	tos &= IPTOS_RT_MASK;
+#ifndef CONFIG_IP_LEF
 	hash = rt_hash(daddr, saddr, iif);
 
 	rcu_read_lock();
@@ -2116,6 +2201,7 @@ int ip_route_input(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 		RT_CACHE_STAT_INC(in_hlist_search);
 	}
 	rcu_read_unlock();
+#endif /* !CONFIG_IP_LEF */
 
 	/* Multicast recognition logic is moved from route cache to here.
 	   The problem was that too many Ethernet cards have broken/missing
@@ -2555,6 +2641,7 @@ out:	return err;
 
 int __ip_route_output_key(struct rtable **rp, const struct flowi *flp)
 {
+#ifndef CONFIG_IP_LEF
 	unsigned hash;
 	struct rtable *rth;
 
@@ -2592,6 +2679,7 @@ int __ip_route_output_key(struct rtable **rp, const struct flowi *flp)
 		RT_CACHE_STAT_INC(out_hlist_search);
 	}
 	rcu_read_unlock_bh();
+#endif
 
 	return ip_route_output_slow(rp, flp);
 }
@@ -3193,6 +3281,9 @@ int __init ip_rt_init(void)
 	xfrm_init();
 	xfrm4_init();
 #endif
+#ifdef CONFIG_IP_LEF
+	printk(KERN_DEBUG "IPv4: LEF v0.2.1 is active\n");
+#endif
 	return rc;
 }
 
