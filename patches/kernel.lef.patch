diff -ruNP linux-2.6.18.orig/include/linux/skbuff.h linux-2.6.18/include/linux/skbuff.h
--- linux-2.6.18.orig/include/linux/skbuff.h	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/include/linux/skbuff.h	2006-11-06 21:23:47.000000000 +0100
@@ -30,6 +30,10 @@
 #include <net/checksum.h>
 #include <linux/dmaengine.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef_struct.h>
+#endif
+
 #define HAVE_ALLOC_SKB		/* For the drivers to know */
 #define HAVE_ALIGNABLE_SKB	/* Ditto 8)		   */
 
@@ -261,6 +265,9 @@
 
 	struct  dst_entry	*dst;
 	struct	sec_path	*sp;
+#ifdef CONFIG_IP_LEF
+	struct  lef		lef;
+#endif
 
 	/*
 	 * This is the control buffer. It is free to use for every
diff -ruNP linux-2.6.18.orig/include/net/lef.h linux-2.6.18/include/net/lef.h
--- linux-2.6.18.orig/include/net/lef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.18/include/net/lef.h	2006-11-06 21:48:26.000000000 +0100
@@ -0,0 +1,64 @@
+/*
+ * Linux express forwarding code
+ *
+ * Mainly developed by krichy < krichy at cflinux dot hu >
+ *
+ * Currently it is under development, so do not expect much from it,
+ * or not anything else than a kernel panic. :)
+ *
+ * The code is subject to GPLv2 or any later one.
+ */
+
+#ifndef _NET_LEF_H
+#define _NET_LEF_H
+
+#include <asm/types.h>
+#include <asm/processor.h>
+#include <net/neighbour.h>
+#include <linux/netdevice.h>
+#include <net/neighbour.h>
+#include <net/lef_struct.h>
+
+// some trivial lef-related functions
+
+/* lef_init
+ * is called when initialising a lef structure
+ * it just zeros all elements of it
+ * @l: struct lef
+ */
+static inline void		lef_init(struct lef* l)
+{
+	memset(l, 0, sizeof(*l));
+}
+
+/* lef_init_copy
+ * inits a lef from another one (actually copying old contents
+ * and allocating references
+ * @l: new lef
+ * @o: old lef
+ */
+static inline void		lef_init_copy(struct lef* l, const struct lef* o)
+{
+	l->gateway = o->gateway;
+	if ((l->dev = o->dev))
+		dev_hold(l->dev);
+	l->mtu = o->mtu;
+	if ((l->neighbour = o->neighbour))
+		neigh_hold(l->neighbour);
+}
+
+/* lef_destroy
+ * destroys (frees) elements of a lef
+ * @l: struct lef
+ */
+static inline void		lef_destroy(struct lef* l)
+{
+	if (likely(l->neighbour))
+		neigh_release(l->neighbour);
+	if (likely(l->dev))
+		dev_put(l->dev);
+}
+
+extern int			lef_forward(struct sk_buff *);
+
+#endif /* _NET_LEF_H */
diff -ruNP linux-2.6.18.orig/include/net/lef_struct.h linux-2.6.18/include/net/lef_struct.h
--- linux-2.6.18.orig/include/net/lef_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.18/include/net/lef_struct.h	2006-11-06 21:23:37.000000000 +0100
@@ -0,0 +1,27 @@
+/*
+ * Linux express forwarding code
+ *
+ * Mainly developed by krichy < krichy at cflinux dot hu >
+ *
+ * Currently it is under development, so do not expect much from it,
+ * or not anything else than a kernel panic. :)
+ *
+ * The code is subject to GPLv2 or any later one.
+ */
+
+#ifndef _NET_LEF_STRUCT_H
+#define _NET_LEF_STRUCT_H
+
+// forward declarations
+struct net_device;
+struct neighbour;
+
+// our express forwarding structure
+struct lef {
+	__u32			gateway;	// our gateway
+	struct net_device	*dev;		// our device
+	u32			mtu;		// our mtu
+	struct neighbour	*neighbour;	// our neigbour
+};
+
+#endif /* _NET_LEF_STRUCT_H */
diff -ruNP linux-2.6.18.orig/net/core/skbuff.c linux-2.6.18/net/core/skbuff.c
--- linux-2.6.18.orig/net/core/skbuff.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/core/skbuff.c	2006-11-06 21:46:11.000000000 +0100
@@ -67,6 +67,10 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 static kmem_cache_t *skbuff_head_cache __read_mostly;
 static kmem_cache_t *skbuff_fclone_cache __read_mostly;
 
@@ -369,6 +373,9 @@
 #ifdef CONFIG_XFRM
 	secpath_put(skb->sp);
 #endif
+#ifdef CONFIG_IP_LEF
+	lef_destroy(&skb->lef);
+#endif
 	if (skb->destructor) {
 		WARN_ON(in_irq());
 		skb->destructor(skb);
@@ -457,6 +464,9 @@
 #ifdef CONFIG_INET
 	secpath_get(skb->sp);
 #endif
+#ifdef CONFIG_IP_LEF
+	lef_init_copy(&n->lef, &skb->lef);
+#endif
 	memcpy(n->cb, skb->cb, sizeof(skb->cb));
 	C(len);
 	C(data_len);
@@ -524,6 +534,9 @@
 #ifdef CONFIG_INET
 	new->sp		= secpath_get(old->sp);
 #endif
+#ifdef CONFIG_IP_LEF
+	lef_init_copy(&new->lef, &old->lef);
+#endif
 	new->h.raw	= old->h.raw + offset;
 	new->nh.raw	= old->nh.raw + offset;
 	new->mac.raw	= old->mac.raw + offset;
@@ -1974,6 +1987,9 @@
 		nskb->priority = skb->priority;
 		nskb->protocol = skb->protocol;
 		nskb->dst = dst_clone(skb->dst);
+#ifdef CONFIG_IP_LEF
+		lef_init_copy(&nskb->lef, &skb->lef);
+#endif
 		memcpy(nskb->cb, skb->cb, sizeof(skb->cb));
 		nskb->pkt_type = skb->pkt_type;
 		nskb->mac_len = skb->mac_len;
diff -ruNP linux-2.6.18.orig/net/ipv4/arp.c linux-2.6.18/net/ipv4/arp.c
--- linux-2.6.18.orig/net/ipv4/arp.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/arp.c	2006-11-06 20:15:27.000000000 +0100
@@ -127,6 +127,10 @@
 
 #include <linux/netfilter_arp.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 /*
  *	Interface to generic neighbour cache.
  */
@@ -526,6 +530,31 @@
 	return 0;
 }
 
+#ifdef CONFIG_IP_LEF
+int arp_bind_neighbour_lef(struct lef *lef)
+{
+	struct net_device *dev = lef->dev;
+	struct neighbour *n = lef->neighbour;
+
+	if (dev == NULL)
+		return -EINVAL;
+	if (n == NULL) {
+		u32 nexthop = lef->gateway;
+		if (dev->flags&(IFF_LOOPBACK|IFF_POINTOPOINT))
+			nexthop = 0;
+		n = __neigh_lookup_errno(
+#if defined(CONFIG_ATM_CLIP) || defined(CONFIG_ATM_CLIP_MODULE)
+		    dev->type == ARPHRD_ATM ? clip_tbl_hook :
+#endif
+		    &arp_tbl, &nexthop, dev);
+		if (IS_ERR(n))
+			return PTR_ERR(n);
+		lef->neighbour = n;
+	}
+	return 0;
+}
+#endif
+
 /*
  * Check if we can use proxy ARP for this path
  */
--- linux-2.6.19/net/ipv4/Kconfig.orig	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19/net/ipv4/Kconfig	2006-12-03 10:22:07.000000000 +0100
@@ -51,6 +51,12 @@
 
 	  If unsure, say N here.
 
+config IP_LEF
+	bool "IP: Linux express forwarding"
+	depends on IP_ADVANCED_ROUTER && !SMP && PREEMPT_NONE
+	---help---
+	You should not turn this on
+
 choice 
 	prompt "Choose IP: FIB lookup algorithm (choose FIB_HASH if unsure)"
 	depends on IP_ADVANCED_ROUTER
@@ -87,7 +93,7 @@
 
 config IP_MULTIPLE_TABLES
 	bool "IP: policy routing"
-	depends on IP_ADVANCED_ROUTER
+	depends on IP_ADVANCED_ROUTER && !IP_LEF
 	select FIB_RULES
 	---help---
 	  Normally, a router decides what to do with a received packet based
@@ -106,7 +112,7 @@
 
 config IP_ROUTE_FWMARK
 	bool "IP: use netfilter MARK value as routing key"
-	depends on IP_MULTIPLE_TABLES && NETFILTER
+	depends on IP_MULTIPLE_TABLES && NETFILTER && !IP_LEF
 	help
 	  If you say Y here, you will be able to specify different routes for
 	  packets with different mark values (see iptables(8), MARK target).
@@ -125,7 +131,7 @@
 
 config IP_ROUTE_MULTIPATH_CACHED
 	bool "IP: equal cost multipath with caching support (EXPERIMENTAL)"
-	depends on IP_ROUTE_MULTIPATH
+	depends on IP_ROUTE_MULTIPATH && !IP_LEF
 	help
 	  Normally, equal cost multipath routing is not supported by the
 	  routing cache. If you say Y here, alternative routes are cached
--- linux-2.6.19/net/ipv4/Makefile.orig	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19/net/ipv4/Makefile	2006-12-03 10:24:10.000000000 +0100
@@ -49,6 +49,7 @@
 obj-$(CONFIG_TCP_CONG_SCALABLE) += tcp_scalable.o
 obj-$(CONFIG_TCP_CONG_LP) += tcp_lp.o
 obj-$(CONFIG_NETLABEL) += cipso_ipv4.o
+obj-$(CONFIG_IP_LEF) += lef.o
 
 obj-$(CONFIG_XFRM) += xfrm4_policy.o xfrm4_state.o xfrm4_input.o \
 		      xfrm4_output.o
--- linux-2.6.18/include/net/arp.h.orig	2006-11-07 09:39:59.000000000 +0100
+++ linux-2.6.18/include/net/arp.h	2006-11-07 09:40:22.000000000 +0100
@@ -16,6 +16,9 @@
 			 struct net_device *dev, u32 src_ip, 
 			 unsigned char *dest_hw, unsigned char *src_hw, unsigned char *th);
 extern int	arp_bind_neighbour(struct dst_entry *dst);
+#ifdef CONFIG_IP_LEF
+extern int	arp_bind_neighbour_lef(struct lef *);
+#endif
 extern int	arp_mc_map(u32 addr, u8 *haddr, struct net_device *dev, int dir);
 extern void	arp_ifdown(struct net_device *dev);
 
--- linux-2.6.18.orig/net/ipv4/icmp.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/icmp.c	2006-11-11 16:34:39.000000000 +0100
@@ -439,8 +439,10 @@
 	u32 saddr;
 	u8  tos;
 
+#ifndef CONFIG_IP_LEF
 	if (!rt)
 		goto out;
+#endif
 
 	/*
 	 *	Find the original header. It is expected to be valid, of course.
@@ -461,7 +463,11 @@
 	/*
 	 *	Now check at the protocol level
 	 */
+#ifdef CONFIG_IP_LEF
+	if (rt && rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))
+#else
 	if (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))
+#endif
 		goto out;
 
 	/*
@@ -511,7 +517,11 @@
 	 */
 
 	saddr = iph->daddr;
+#ifdef CONFIG_IP_LEF
+	if (!rt || !(rt->rt_flags & RTCF_LOCAL)) {
+#else
 	if (!(rt->rt_flags & RTCF_LOCAL)) {
+#endif
 		if (sysctl_icmp_errors_use_inbound_ifaddr)
 			saddr = inet_select_addr(skb_in->dev, 0, RT_SCOPE_LINK);
 		else
--- linux-2.6.18.orig/net/ipv4/netfilter/Kconfig	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/netfilter/Kconfig	2006-11-12 15:45:00.000000000 +0100
@@ -433,7 +433,7 @@
 
 config IP_NF_TARGET_MASQUERADE
 	tristate "MASQUERADE target support"
-	depends on IP_NF_NAT
+	depends on IP_NF_NAT && !IP_LEF
 	help
 	  Masquerading is a special case of NAT: all outgoing connections are
 	  changed to seem to come from a particular interface's address, and
--- linux-2.6.19/include/net/route.h.orig	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19/include/net/route.h	2006-12-03 10:34:38.000000000 +0100
@@ -117,6 +117,9 @@
 extern int		ip_route_output_key(struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
 extern int		ip_route_input(struct sk_buff*, __be32 dst, __be32 src, u8 tos, struct net_device *devin);
+#ifdef CONFIG_IP_LEF
+extern int		ip_route_input_lef(struct sk_buff*, __be32 dst, __be32 src, u8 tos, struct net_device *devin, int use_lef);
+#endif
 extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 
--- linux-2.6.19.orig/net/ipv4/route.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19/net/ipv4/route.c	2006-12-09 15:52:51.000000000 +0100
@@ -108,6 +108,9 @@
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
 
 #define RT_FL_TOS(oldflp) \
     ((u32)(oldflp->fl4_tos & (IPTOS_RT_MASK | RTO_ONLINK)))
@@ -252,6 +255,15 @@
 #define RT_CACHE_STAT_INC(field) \
 	(__raw_get_cpu_var(rt_cache_stat).field++)
 
+#ifdef CONFIG_IP_LEF
+static inline int rt_intern_hash(unsigned hash, struct rtable *rth,
+				struct rtable **res);
+
+static inline unsigned int rt_hash_code(u32 daddr, u32 saddr)
+{
+	return 0;
+}
+#else
 static int rt_intern_hash(unsigned hash, struct rtable *rth,
 				struct rtable **res);
 
@@ -260,6 +272,7 @@
 	return (jhash_2words(daddr, saddr, rt_hash_rnd)
 		& rt_hash_mask);
 }
+#endif
 
 #define rt_hash(daddr, saddr, idx) \
 	rt_hash_code((__force u32)(__be32)(daddr),\
@@ -922,6 +935,23 @@
 out:	return 0;
 }
 
+#ifdef CONFIG_IP_LEF
+static inline int rt_intern_hash(unsigned hash, struct rtable *rt, struct rtable **rp)
+{
+	int err;
+
+	err = arp_bind_neighbour(&rt->u.dst);
+	if (err) {
+		rt_drop(rt);
+		return err;
+	}
+
+	rt_free(rt);
+	*rp = rt;
+
+	return 0;
+}
+#else
 static int rt_intern_hash(unsigned hash, struct rtable *rt, struct rtable **rp)
 {
 	struct rtable	*rth, **rthp;
@@ -1052,6 +1082,7 @@
 	*rp = rt;
 	return 0;
 }
+#endif
 
 void rt_bind_peer(struct rtable *rt, int create)
 {
@@ -1721,7 +1752,11 @@
 				  struct fib_result* res, 
 				  struct in_device *in_dev, 
 				  __be32 daddr, __be32 saddr, u32 tos,
-				  struct rtable **result) 
+				  struct rtable **result
+#ifdef CONFIG_IP_LEF
+				  , int use_lef
+#endif
+				  )
 {
 
 	struct rtable *rth;
@@ -1740,6 +1775,9 @@
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_IP_LEF
+	if (!use_lef || IN_DEV_RPFILTER(in_dev)) {
+#endif
 
 	err = fib_validate_source(saddr, daddr, tos, FIB_RES_OIF(*res), 
 				  in_dev->dev, &spec_dst, &itag);
@@ -1758,6 +1796,9 @@
 	    (IN_DEV_SHARED_MEDIA(out_dev) ||
 	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))
 		flags |= RTCF_DOREDIRECT;
+#ifdef CONFIG_IP_LEF
+	}
+#endif
 
 	if (skb->protocol != htons(ETH_P_IP)) {
 		/* Not IP (i.e. ARP). Do not create route, if it is
@@ -1769,6 +1810,25 @@
 		}
 	}
 
+#ifdef CONFIG_IP_LEF
+	if (use_lef) {
+		if (likely(res->nh->neighbour)) {
+			skb->lef.neighbour = res->nh->neighbour;
+			atomic_inc(&skb->lef.neighbour->refcnt);
+		} else {
+			if (FIB_RES_GW(*res) &&
+					FIB_RES_NH(*res).nh_scope == RT_SCOPE_LINK)
+				skb->lef.gateway = FIB_RES_GW(*res);
+			else
+				skb->lef.gateway = daddr;
+		}
+		skb->lef.dev = (out_dev)->dev;
+		dev_hold(skb->lef.dev);
+		skb->lef.mtu = res->fi->fib_mtu ? res->fi->fib_mtu : skb->lef.dev->mtu;
+		err = 0;
+		goto cleanup;
+	}
+#endif
 
 	rth = dst_alloc(&ipv4_dst_ops);
 	if (!rth) {
@@ -1834,7 +1894,11 @@
 #endif
 
 	/* create a routing cache entry */
+#ifdef CONFIG_IP_LEF
+	err = __mkroute_input(skb, res, in_dev, daddr, saddr, tos, &rth, 0);
+#else
 	err = __mkroute_input(skb, res, in_dev, daddr, saddr, tos, &rth);
+#endif
 	if (err)
 		return err;
 
@@ -1910,8 +1974,13 @@
  *	2. IP spoofing attempts are filtered with 100% of guarantee.
  */
 
-static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,
+#ifdef CONFIG_IP_LEF
+static inline int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,
+			       u8 tos, struct net_device *dev, int use_lef)
+#else
+static inline int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 			       u8 tos, struct net_device *dev)
+#endif
 {
 	struct fib_result res;
 	struct in_device *in_dev = in_dev_get(dev);
@@ -1990,6 +2059,24 @@
 	if (res.type != RTN_UNICAST)
 		goto martian_destination;
 
+#ifdef CONFIG_IP_LEF
+	if (likely(use_lef)) {
+		err = __mkroute_input(skb, &res, in_dev, daddr, saddr, tos, NULL, 1);
+		if (unlikely(err))
+			goto done;
+
+		if (unlikely(!(skb->lef.neighbour))) {
+			err = arp_bind_neighbour_lef(&skb->lef);
+			if (unlikely(err))
+				goto done;
+			if (skb->lef.gateway && skb->lef.gateway != daddr) { // only store if it is a really gateway
+				res.nh->neighbour = skb->lef.neighbour;
+				atomic_inc(&res.nh->neighbour->refcnt);
+			}
+		}
+		goto done;
+	}
+#endif
 	err = ip_mkroute_input(skb, &res, &fl, in_dev, daddr, saddr, tos);
 	if (err == -ENOBUFS)
 		goto e_nobufs;
@@ -2096,14 +2183,22 @@
 	goto e_inval;
 }
 
+#ifdef CONFIG_IP_LEF
+int ip_route_input_lef(struct sk_buff *skb, __be32 daddr, __be32 saddr,
+		   u8 tos, struct net_device *dev, int use_lef)
+#else
 int ip_route_input(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 		   u8 tos, struct net_device *dev)
+#endif
 {
+#ifndef CONFIG_IP_LEF
 	struct rtable * rth;
 	unsigned	hash;
 	int iif = dev->ifindex;
+#endif
 
 	tos &= IPTOS_RT_MASK;
+#ifndef CONFIG_IP_LEF
 	hash = rt_hash(daddr, saddr, iif);
 
 	rcu_read_lock();
@@ -2128,6 +2223,7 @@
 		RT_CACHE_STAT_INC(in_hlist_search);
 	}
 	rcu_read_unlock();
+#endif /* !CONFIG_IP_LEF */
 
 	/* Multicast recognition logic is moved from route cache to here.
 	   The problem was that too many Ethernet cards have broken/missing
@@ -2160,8 +2256,21 @@
 		rcu_read_unlock();
 		return -EINVAL;
 	}
+#ifdef CONFIG_IP_LEF
+	return ip_route_input_slow(skb, daddr, saddr, tos, dev, use_lef);
+#else
 	return ip_route_input_slow(skb, daddr, saddr, tos, dev);
+#endif
+}
+
+#ifdef CONFIG_IP_LEF
+int ip_route_input(struct sk_buff *skb, u32 daddr, u32 saddr,
+		   u8 tos, struct net_device *dev)
+{
+	return ip_route_input_lef(skb, daddr, saddr, tos, dev, 0);
 }
+#endif
+
 
 static inline int __mkroute_output(struct rtable **result,
 				   struct fib_result* res, 
@@ -2571,6 +2680,7 @@
 
 int __ip_route_output_key(struct rtable **rp, const struct flowi *flp)
 {
+#ifndef CONFIG_IP_LEF
 	unsigned hash;
 	struct rtable *rth;
 
@@ -2610,6 +2720,7 @@
 		RT_CACHE_STAT_INC(out_hlist_search);
 	}
 	rcu_read_unlock_bh();
+#endif
 
 	return ip_route_output_slow(rp, flp);
 }
@@ -3215,6 +3326,9 @@
 	xfrm_init();
 	xfrm4_init();
 #endif
+#ifdef CONFIG_IP_LEF
+	printk(KERN_DEBUG "IPv4: LEF v0.1 is active\n");
+#endif
 	return rc;
 }
 
--- linux-2.6.18.orig/net/core/neighbour.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/core/neighbour.c	2006-11-14 13:33:31.000000000 +0100
@@ -34,6 +34,10 @@
 #include <linux/random.h>
 #include <linux/string.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 #define NEIGH_DEBUG 1
 
 #define NEIGH_PRINTK(x...) printk(x)
@@ -1139,7 +1143,11 @@
 	struct neighbour *neigh;
 	int rc = 0;
 
+#ifdef CONFIG_IP_LEF
+	if ((!dst || !(neigh = dst->neighbour)) && !(neigh = skb->lef.neighbour))
+#else
 	if (!dst || !(neigh = dst->neighbour))
+#endif
 		goto discard;
 
 	__skb_pull(skb, skb->nh.raw - skb->data);
@@ -1147,7 +1155,11 @@
 	if (!neigh_event_send(neigh, skb)) {
 		int err;
 		struct net_device *dev = neigh->dev;
+#ifdef CONFIG_IP_LEF
+		if (dst && dev->hard_header_cache && !dst->hh) {
+#else
 		if (dev->hard_header_cache && !dst->hh) {
+#endif
 			write_lock_bh(&neigh->lock);
 			if (!dst->hh)
 				neigh_hh_init(neigh, dst, dst->ops->protocol);
@@ -1182,8 +1194,17 @@
 {
 	int err;
 	struct dst_entry *dst = skb->dst;
-	struct neighbour *neigh = dst->neighbour;
-	struct net_device *dev = neigh->dev;
+	struct neighbour *neigh;
+	struct net_device *dev;
+
+#ifdef CONFIG_IP_LEF
+	if (!dst)
+		neigh = skb->lef.neighbour;
+	else
+#endif
+		neigh = dst->neighbour;
+
+	dev = neigh->dev;
 
 	__skb_pull(skb, skb->nh.raw - skb->data);
 
--- linux-2.6.18.orig/net/ipv4/lef.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.18/net/ipv4/lef.c	2006-11-14 13:48:09.000000000 +0100
@@ -0,0 +1,124 @@
+/*
+ * Linux express forwarding code
+ *
+ * Mainly developed by krichy < krichy at cflinux dot hu >
+ *
+ * Currently it is under development, so do not expect much from it,
+ * or not anything else than a kernel panic. :)
+ *
+ * The code is subject to GPLv2 or any later one.
+ */
+
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <net/arp.h>
+#include <net/lef.h>
+#include <net/sock.h>
+#include <net/ip.h>
+#include <net/route.h>
+#include <net/icmp.h>
+#include <linux/icmp.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_bridge.h>
+
+static inline int	lef_output_finish2(struct sk_buff *skb)
+{
+	struct net_device *dev = skb->lef.dev;
+	struct neighbour *neigh;
+	int hh_len = LL_RESERVED_SPACE(dev);
+
+	/* Be paranoid, rather than too clever. */
+	if (unlikely(skb_headroom(skb) < hh_len && dev->hard_header)) {
+		struct sk_buff *skb2;
+
+		skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));
+		if (skb2 == NULL) {
+			kfree_skb(skb);
+			return -ENOMEM;
+		}
+		if (skb->sk)
+			skb_set_owner_w(skb2, skb->sk);
+		kfree_skb(skb);
+		skb = skb2;
+	}
+
+	if (likely((neigh = skb->lef.neighbour))) {
+		return neigh->output(skb);
+	}
+
+	printk("lef_output_finish2: no neighbour found\n");
+	kfree_skb(skb);
+
+	return NET_RX_DROP;
+}
+
+static inline int	lef_output_finish(struct sk_buff *skb)
+{
+	if (skb->len > skb->lef.mtu && !skb_is_gso(skb)) {
+		// TODO: fragment
+		kfree_skb(skb);
+		return NET_RX_DROP;
+	} else {
+		return lef_output_finish2(skb);
+	}
+}
+
+static inline int	lef_output(struct sk_buff *skb)
+{
+	struct net_device *dev = skb->lef.dev;
+
+	IP_INC_STATS(IPSTATS_MIB_OUTREQUESTS);
+
+	skb->dev = dev;
+	skb->protocol = htons(ETH_P_IP);
+
+	return NF_HOOK_COND(PF_INET, NF_IP_POST_ROUTING, skb, NULL, dev,
+		            lef_output_finish,
+			    !(IPCB(skb)->flags & IPSKB_REROUTED));
+}
+
+static inline int	lef_forward_finish(struct sk_buff *skb)
+{
+	IP_INC_STATS_BH(IPSTATS_MIB_OUTFORWDATAGRAMS);
+
+	return lef_output(skb);
+}
+
+int			lef_forward(struct sk_buff *skb)
+{
+	struct iphdr *iph;	/* Our header */
+
+	if (skb->pkt_type != PACKET_HOST)
+		goto drop;
+
+	skb->ip_summed = CHECKSUM_NONE;
+	iph = skb->nh.iph;
+
+	/*
+	 *	According to the RFC, we must first decrease the TTL field. If
+	 *	that reaches zero, we must reply an ICMP control message telling
+	 *	that the packet's lifetime expired.
+	 */
+	if (iph->ttl <= 1)
+                goto too_many_hops;
+
+	/* We are about to mangle packet. Copy it! */
+	if (skb_cow(skb, LL_RESERVED_SPACE(skb->lef.dev)))
+		goto drop;
+
+	/* Decrease ttl after skb cow done */
+	ip_decrease_ttl(iph);
+
+	skb->priority = rt_tos2priority(iph->tos);
+
+	return NF_HOOK(PF_INET, NF_IP_FORWARD, skb, skb->dev, skb->lef.dev,
+		       lef_forward_finish);
+
+too_many_hops:
+        /* Tell the sender its packet died... */
+        IP_INC_STATS_BH(IPSTATS_MIB_INHDRERRORS);
+        icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
+drop:
+	kfree_skb(skb);
+	return NET_RX_DROP;
+}
--- linux-2.6.18.orig/net/ipv4/ip_input.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-2.6.18/net/ipv4/ip_input.c	2006-11-14 19:13:18.000000000 +0100
@@ -146,6 +146,10 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
+#ifdef CONFIG_IP_LEF
+#include <net/lef.h>
+#endif
+
 /*
  *	SNMP management statistics
  */
@@ -331,14 +335,22 @@
 static inline int ip_rcv_finish(struct sk_buff *skb)
 {
 	struct iphdr *iph = skb->nh.iph;
+	int ip_has_options = iph->ihl > 5;
 
 	/*
 	 *	Initialise the virtual path cache for the packet. It describes
 	 *	how the packet travels inside Linux networking.
+	 *	Only packets without IP options can be handled by LEF, so
+	 *	give the function this information.
 	 */ 
 	if (skb->dst == NULL) {
+#ifdef CONFIG_IP_LEF
+		int err = ip_route_input_lef(skb, iph->daddr, iph->saddr, iph->tos,
+					 skb->dev, !ip_has_options);
+#else
 		int err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos,
 					 skb->dev);
+#endif
 		if (unlikely(err)) {
 			if (err == -EHOSTUNREACH)
 				IP_INC_STATS_BH(IPSTATS_MIB_INADDRERRORS);
@@ -347,6 +359,9 @@
 	}
 
 #ifdef CONFIG_NET_CLS_ROUTE
+#ifdef CONFIG_IP_LEF
+	if (skb->dst) {
+#endif
 	if (unlikely(skb->dst->tclassid)) {
 		struct ip_rt_acct *st = ip_rt_acct + 256*smp_processor_id();
 		u32 idx = skb->dst->tclassid;
@@ -355,11 +370,19 @@
 		st[(idx>>16)&0xFF].i_packets++;
 		st[(idx>>16)&0xFF].i_bytes+=skb->len;
 	}
+#ifdef CONFIG_IP_LEF
+	}
+#endif
 #endif
 
-	if (iph->ihl > 5 && ip_rcv_options(skb))
+	if (ip_has_options && ip_rcv_options(skb))
 		goto drop;
 
+#ifdef CONFIG_IP_LEF
+	if (!skb->dst)
+		return lef_forward(skb);
+	else
+#endif
 	return dst_input(skb);
 
 drop:
--- linux-2.6.19.orig/net/ipv4/fib_semantics.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19/net/ipv4/fib_semantics.c	2006-12-09 13:21:44.000000000 +0100
@@ -153,6 +153,11 @@
 		if (nh->nh_dev)
 			dev_put(nh->nh_dev);
 		nh->nh_dev = NULL;
+#ifdef CONFIG_IP_LEF
+		if (nh->neighbour)
+			neigh_release(nh->neighbour);
+		nh->neighbour = NULL;
+#endif
 	} endfor_nexthops(fi);
 	fib_info_cnt--;
 	kfree(fi);
@@ -851,7 +856,11 @@
 			int prefixlen)
 {
 	struct fib_alias *fa;
-	int nh_sel = 0;
+	int nh_sel;
+#ifdef CONFIG_IP_LEF
+	const struct fib_nh *_nh;
+	unsigned _fib_nhs;
+#endif
 
 	list_for_each_entry_rcu(fa, head, fa_list) {
 		int err;
@@ -872,12 +881,49 @@
 			if (fi->fib_flags & RTNH_F_DEAD)
 				continue;
 
+#ifdef CONFIG_IP_LEF
+			_fib_nhs = fi->fib_nhs;
+#endif
+
 			switch (fa->fa_type) {
 			case RTN_UNICAST:
 			case RTN_LOCAL:
 			case RTN_BROADCAST:
 			case RTN_ANYCAST:
 			case RTN_MULTICAST:
+#ifdef CONFIG_IP_LEF
+				{
+					int _nh_i;
+
+					if (likely(_fib_nhs == 1)) {
+						_nh = fi->fib_nh;
+						if (likely(!(_nh->nh_flags&RTNH_F_DEAD))) {
+							if (!flp->oif || flp->oif == _nh->nh_oif) {
+								nh_sel = 0;
+								goto out_fill_res;
+							}
+						}
+					} else {
+						nh_sel = ((unsigned)jiffies % _fib_nhs);
+						for (_nh_i = 0; _nh_i < _fib_nhs; _nh_i++) {
+							_nh = fi->fib_nh + nh_sel;
+
+							if (likely(!(_nh->nh_flags&RTNH_F_DEAD))) {
+								if (!flp->oif || flp->oif == _nh->nh_oif)
+									break;
+							}
+							nh_sel = (nh_sel + 1) % _fib_nhs;
+						}
+					}
+#ifdef CONFIG_IP_ROUTE_MULTIPATH
+					if (_nh_i < _fib_nhs)
+						goto out_fill_res;
+#else
+					if (_nh_i < 1)
+						goto out_fill_res;
+#endif
+				}
+#else
 				for_nexthops(fi) {
 					if (nh->nh_flags&RTNH_F_DEAD)
 						continue;
@@ -895,6 +941,7 @@
 				}
 #endif
 				endfor_nexthops(fi);
+#endif
 				continue;
 
 			default:
@@ -916,6 +963,9 @@
 	res->netmask = mask;
 	res->network = zone & inet_make_mask(prefixlen);
 #endif
+#ifdef CONFIG_IP_LEF
+	res->nh = _nh;
+#endif
 	atomic_inc(&res->fi->fib_clntref);
 	return 0;
 }
@@ -1045,6 +1095,9 @@
 		struct hlist_head *head = &fib_info_devhash[hash];
 		struct hlist_node *node;
 		struct fib_nh *nh;
+#ifdef CONFIG_IP_LEF
+		struct neighbour *neigh;
+#endif
 
 		hlist_for_each_entry(nh, node, head, nh_hash) {
 			struct fib_info *fi = nh->nh_parent;
@@ -1067,6 +1120,12 @@
 					nh->nh_power = 0;
 					spin_unlock_bh(&fib_multipath_lock);
 #endif
+#ifdef CONFIG_IP_LEF
+					if ((neigh = nh->neighbour)) {
+						nh->neighbour = NULL;
+						neigh_release(neigh);
+					}
+#endif
 					dead++;
 				}
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
--- linux-2.6.19.orig/include/net/ip_fib.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19/include/net/ip_fib.h	2006-12-08 19:33:20.000000000 +0100
@@ -61,6 +61,9 @@
 #endif
 	int			nh_oif;
 	__be32			nh_gw;
+#ifdef CONFIG_IP_LEF
+	struct neighbour	*neighbour;
+#endif
 };
 
 /*
@@ -111,6 +114,7 @@
 #ifdef CONFIG_IP_MULTIPLE_TABLES
 	struct fib_rule	*r;
 #endif
+	struct fib_nh	*nh;
 };
 
 struct fib_result_nl {
@@ -130,7 +134,11 @@
 
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 
+#ifdef CONFIG_IP_LEF
+#define FIB_RES_NH(res)		(*((res).nh))
+#else
 #define FIB_RES_NH(res)		((res).fi->fib_nh[(res).nh_sel])
+#endif
 #define FIB_RES_RESET(res)	((res).nh_sel = 0)
 
 #else /* CONFIG_IP_ROUTE_MULTIPATH */
