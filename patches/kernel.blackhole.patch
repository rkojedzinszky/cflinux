--- linux-2.6.19/net/ipv4/tcp_ipv4.c.orig	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19/net/ipv4/tcp_ipv4.c	2006-12-03 10:01:03.000000000 +0100
@@ -80,6 +80,7 @@
 
 int sysctl_tcp_tw_reuse __read_mostly;
 int sysctl_tcp_low_latency __read_mostly;
+int sysctl_tcp_blackhole __read_mostly;
 
 /* Check TCP sequence numbers in ICMP packets. */
 #define ICMP_MIN_LENGTH 8
@@ -532,6 +533,10 @@
 	struct tcphdr rth;
 	struct ip_reply_arg arg;
 
+	/* never send reset if sysctl_tcp_blackhole is set */
+	if (sysctl_tcp_blackhole)
+		return;
+
 	/* Never send a reset in response to a reset. */
 	if (th->rst)
 		return;
--- linux-2.6.20.3/net/ipv4/sysctl_net_ipv4.c.orig	2007-03-13 19:27:08.000000000 +0100
+++ linux-2.6.20.3/net/ipv4/sysctl_net_ipv4.c	2007-03-20 21:37:15.000000000 +0100
@@ -31,6 +31,12 @@
 
 struct ipv4_config ipv4_config;
 
+/* From tcp_ipv4.c */
+extern int sysctl_tcp_blackhole;
+
+/* From udp.c */
+extern int sysctl_udp_blackhole;
+
 #ifdef CONFIG_SYSCTL
 
 static
@@ -803,6 +809,22 @@
 		.proc_handler   = &proc_allowed_congestion_control,
 		.strategy	= &strategy_allowed_congestion_control,
 	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "tcp_blackhole",
+		.data		= &sysctl_tcp_blackhole,
+		.maxlen		= sizeof(int),
+		.mode		= 0640,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "udp_blackhole",
+		.data		= &sysctl_udp_blackhole,
+		.maxlen		= sizeof(int),
+		.mode		= 0640,
+		.proc_handler	= &proc_dointvec
+	},
 	{ .ctl_name = 0 }
 };
 
--- linux-2.6.20.3/net/ipv4/udp.c.orig	2007-03-13 19:27:08.000000000 +0100
+++ linux-2.6.20.3/net/ipv4/udp.c	2007-03-20 21:32:35.000000000 +0100
@@ -113,6 +113,7 @@
 DEFINE_RWLOCK(udp_hash_lock);
 
 static int udp_port_rover;
+int sysctl_udp_blackhole;
 
 static inline int __udp_lib_lport_inuse(__u16 num, struct hlist_head udptable[])
 {
@@ -1250,7 +1251,8 @@
 		goto csum_error;
 
 	UDP_INC_STATS_BH(UDP_MIB_NOPORTS, is_udplite);
-	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);
+	if (!sysctl_udp_blackhole)
+		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);
 
 	/*
 	 * Hmm.  We got an UDP packet to a port to which we
